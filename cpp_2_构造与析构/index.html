<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>从c到c++ | Don't say sorry</title><meta name="keywords" content="C++, 面向对象"><meta name="author" content="srymaker0"><meta name="copyright" content="srymaker0"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="构造函数    作用：用来初始化对象，没有返回值，函数名字和类名一样   凡是一个对象，它的产生之初一定调用构造函数，然后经历一段时间的使用过程，最后一定会调用析构函数。  12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using names">
<meta property="og:type" content="article">
<meta property="og:title" content="从c到c++">
<meta property="og:url" content="http://example.com/cpp_2_%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84/index.html">
<meta property="og:site_name" content="Don&#39;t say sorry">
<meta property="og:description" content="构造函数    作用：用来初始化对象，没有返回值，函数名字和类名一样   凡是一个对象，它的产生之初一定调用构造函数，然后经历一段时间的使用过程，最后一定会调用析构函数。  12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using names">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-05-03T09:26:52.000Z">
<meta property="article:modified_time" content="2021-05-03T09:35:54.510Z">
<meta property="article:author" content="srymaker0">
<meta property="article:tag" content="C++, 面向对象">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/cpp_2_%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-03 17:35:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/pool.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/iconfont.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210503135612.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Don't say sorry</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">从c到c++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-03T09:26:52.000Z" title="发表于 2021-05-03 17:26:52">2021-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-03T09:35:54.510Z" title="更新于 2021-05-03 17:35:54">2021-05-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="从c到c++"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p><img src="https://i.loli.net/2021/03/07/uNwszhVPW7K8xnB.png"></p>
<ul>
<li>  作用：用来初始化对象，没有返回值，函数名字和类名一样</li>
<li>  凡是一个对象，它的产生之初一定调用构造函数，然后经历一段时间的使用过程，最后一定会调用析构函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">Data</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">d</span>(<span class="number">3</span>, <span class="number">4</span>) &#123;                                        <span class="comment">//d 是一个对象， 这里调用的是有参构造</span></span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; : constructor&quot;</span> &lt;&lt; endl;          <span class="comment">// this 是 对象的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> x) : <span class="built_in">d</span>(x, x) &#123;                                      <span class="comment">//转化构造函数  这里是把一个整型转换成A类型的对象</span></span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; : transform constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A &amp;a) : <span class="built_in">d</span>(a.d) &#123;                        <span class="comment">// &amp;a 是引用 const为了防止a对象被修改 const变量不允许被修改</span></span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; : copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;a) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; : operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; : destructor&quot;</span> &lt;&lt; endl;          <span class="comment">//在主函数运行结束后被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    Data d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键在于学习对象析构顺序 先构造的后析构</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;                             <span class="comment">//构造对象 调用默认构造函数</span></span><br><span class="line">    A b = a;                         <span class="comment">//调用拷贝构造 和 A b(a); 一样</span></span><br><span class="line">    <span class="comment">//b = a;                         //调用赋值运算符</span></span><br><span class="line">    A c = <span class="number">3</span>;</span><br><span class="line">    a = <span class="number">123</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b : &quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;end of main&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>  功能上的构造（逻辑上）：要完整的实现我们所认为的逻辑才算构造完</p>
</li>
<li><p>编译器所谓的构造（实际上）：其实在第13行就已经构造完成了，意思是我们可以在第14行就可以访问成员属性和方法了</p>
<ul>
<li>  当前对象真正的构造行为发生在初始化列表里，要保证进到大括号内时已经构造完了对象</li>
</ul>
</li>
<li><p>初始化参数列表：所有的构造行为我们应该放入初始化列表中去完成</p>
<ul>
<li>  在初始化参数列表中，我们可以显示的让对象调用指定的构造函数</li>
</ul>
</li>
<li><p>  :exclamation:成员属性的构造顺序跟初始化列表里的顺序没有关系，只跟成员属性声明顺序有关</p>
</li>
</ul>
<h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><ul>
<li><p>  本质上是不传递任何参数的构造函数</p>
</li>
<li><p>编译器自动帮我们生成的</p>
<ul>
<li>  如果我们写了有参构造函数，编译器会删除原来的默认构造函数</li>
<li>如果不想用默认构造函数，那么最好显示的删除默认构造函数（在后面会讲到）</li>
<li>  此时若我们还想用默认构造函数，就要显示性的写上默认构造函数</li>
</ul>
</li>
</ul>
<h2 id="有参构造函数"><a href="#有参构造函数" class="headerlink" title="有参构造函数"></a>有参构造函数</h2><ul>
<li><p>  参数可以是1个或者多个</p>
</li>
<li><p>参数只有1个的构造函数我们称之为转换构造函数如：$A(int x)$</p>
<ul>
<li>:question:为什么叫转换构造：等价于把另外一种类型转换成当前类型的功能</li>
</ul>
</li>
<li><p>分析a = 123这行代码到底经历了啥</p>
<ul>
<li>  代码38行为什么123一个整型能赋值给一个a对象？ :point_right:从逻辑上来讲是123转换为了A类型的值然后给a对象</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;a) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; : operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...........</span><br><span class="line">a = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先这行代码会调用赋值运算符，可以看到传入的参数是A类型，而123是整型</li>
<li>  此时由于A类型拥有转换构造函数，可以把123临时转换成A类型的对象，然后传给赋值运算符</li>
<li>  <img src="https://i.loli.net/2021/03/07/k4Armncuio9gex7.png"></li>
<li>  看输出的结果中地址尾号为67的就是创建的临时对象</li>
</ul>
</li>
</ul>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><ul>
<li>  特殊的有参构造:point_down:</li>
<li>  当传入的参数和对象的类型一致时，我们称这类构造函数为拷贝构造函数</li>
<li>  拷贝构造和“=”赋值运算符完全不等价</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>(<span class="keyword">const</span> A &amp;a) &#123;                                 <span class="comment">// &amp;a 是引用 const为了防止a对象被修改 const变量不允许被修改 正确写法</span></span><br><span class="line">    cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; : copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A(A a) &#123;&#125;  //不能这么写拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">A b = a; <span class="comment">//和 A b(a); 是等价的 但是只在定义的时候等价 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>:exclamation:假设你的拷贝构造函数按照第5行这么写<ul>
<li>  如果按第5行的代码执行，则运行第7行代码时，b会调用拷贝函数，并把a参数传入</li>
<li>而A(A  a‘)这句话等于A(A  a’ = a),然后a‘还会进行调用拷贝构造函数:point_right:会无限套娃下去</li>
<li>所以拷贝构造函数的参数不能值传递，不然会让参数调用拷贝构造，接着再调用参数的参数的拷贝构造</li>
</ul>
</li>
<li>为什么拷贝构造函数的参数要有const<ul>
<li>  1⃣️为了能处理const和非const类型的对象</li>
<li>  如果定义一个const类型的对象，而拷贝构造函数参数不加const修饰，则会产生bug，因为这样你就可以在构造函数中修改a变量的值了，从逻辑上讲这样不行。</li>
</ul>
</li>
</ul>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><ul>
<li>浅拷贝：两个对象一一对应，连指向的地址都是同一块，相当于在原对象上改数据<ul>
<li>  编译器默认的拷贝构造函数是浅拷贝</li>
</ul>
</li>
<li>  深拷贝：要自己写拷贝构造函数，重新给对象b分配一段存储空间</li>
</ul>
<p><img src="https://i.loli.net/2021/03/07/B4EZhVmoca8FSRp.png"></p>
<p><img src="https://i.loli.net/2021/03/07/JSe6uzMF3j8V1ri.png"></p>
<ul>
<li>  end: 当[]号访问越界时，统一返回end</li>
<li>这里的深拷贝其实有问题：data中没有调用构造函数，应该用原地构造<ul>
<li>  我们只是把数据拷贝过去了，而不是把对象拷贝过去</li>
</ul>
</li>
</ul>
<h1 id="default和-delete"><a href="#default和-delete" class="headerlink" title="=default和=delete"></a>=default和=delete</h1><ul>
<li>  c++的潜在规则如此之多，以至于我们可能在工程开发中搞不清在类中到底什么函数被默认调用或者被人为的调用，为了避免人为的疏忽和潜在规则之间产生的bug，c++给我们引入了两个关键字</li>
<li><img src="https://i.loli.net/2021/03/08/9nIYcMGxEZeXJrV.png"><ul>
<li>  这样我们就显示的删除了默认构造函数（delete），以及我们显示的使用了默认拷贝构造函数（default）</li>
<li>  :exclamation:尽管这样的代码并没有实际意义上的功能，但是方便日后我们找bug，c++设计哲学:smile:</li>
</ul>
</li>
<li>:star:实现让某个类完全不能发生拷贝行为<ul>
<li>  <img src="https://i.loli.net/2021/03/08/yCKlgUwTQHamGEF.png"></li>
<li>  让这个类的拷贝构造函数和赋值运算符全都失效，放入private中，让外部访问不到</li>
</ul>
</li>
</ul>
<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><ul>
<li><p>  功能：销毁对象，没有返回值，函数名和类名一样，只是多了一个‘～’</p>
</li>
<li><p>  调用时间：在主函数结束后</p>
</li>
<li><p><img src="https://i.loli.net/2021/03/07/nlDB1igQEXUItO5.png"></p>
<p>  <img src="https://i.loli.net/2021/03/07/k4Armncuio9gex7.png"></p>
</li>
<li><p>:exclamation:析构函数调用顺序</p>
<ul>
<li>  我们定义了两个对象a和b，根据38行，39行可知输出信息中a，b的地址，在看输出的倒数两行我们发现先初始化的对象反而后析构</li>
<li>思考：这是语言特性？还是特例？<ul>
<li>  和定义在哪没关系，就算将a，b定义在全局中也是b先析构，a后析构</li>
<li>  假设我们在设计一个很复杂的功能，那么b对象可能很复杂，并且可能依赖于a对象——b对象的构造可能依赖于a对象的信息那么b对象在析构的时候也可能会依赖于a的信息，所以在析构b对象之前一定不能先析构a对象，否则b对象无法完成析构</li>
</ul>
</li>
</ul>
</li>
<li><p>这肯定是语言特性:exclamation:</p>
<ul>
<li>  编译器只管哪个先构造就后析构。</li>
</ul>
</li>
</ul>
<h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><ul>
<li><p>函数重载：如果一个作用域内几个函数名字相同但是参数列表不同，称为函数重载</p>
<ul>
<li>  :exclamation:注意 : 与返回值没有关系</li>
</ul>
</li>
<li><p>重载的意义：</p>
<ul>
<li>  通过函数名对函数功能进行提示</li>
<li>  通过函数参数列表对函数的用法进行提示</li>
<li>  扩展已有的功能</li>
</ul>
</li>
<li><p><img src="https://i.loli.net/2021/03/08/QG9HDf4jiFAbuYa.png"></p>
<ul>
<li>  若函数参数有默认值，则会引起冲突。</li>
</ul>
</li>
</ul>
<ul>
<li><p>运算符重载</p>
<ul>
<li><img src="https://i.loli.net/2021/03/08/qVlzG5X2POkeU9J.png"><ul>
<li>  :star:sizeof也不能被重载，sizeof实际上是一个运算符</li>
<li>  new和delete也是运算符 </li>
</ul>
</li>
</ul>
</li>
<li><p>  <img src="https://i.loli.net/2021/03/08/2u9bHQnJSYL8V6I.png"></p>
</li>
<li><p>”+“类外重载</p>
<ul>
<li><p>  低优先级</p>
</li>
<li><p>  第一个参数表示”+“号左边的值， 第二个参数表示”+“右边的值</p>
</li>
</ul>
</li>
<li><p>”+“类内重载</p>
<ul>
<li>  高优先级</li>
<li>  只需要一个参数，红框里的x是成员属性，也可以使用this来指向成员属性</li>
<li>  从逻辑上来讲，在开发者视角来看可能不知道在哪进行定义类外重载，但是类内重载可以看到，并且好找BUG</li>
</ul>
</li>
<li><p>运算符重载函数返回值</p>
<ul>
<li>返回引用<ul>
<li>  从功能上来说，可以实现连续”=“，”+=“等的一些操作</li>
</ul>
</li>
</ul>
</li>
<li><p>特殊运算符的重载</p>
<ul>
<li>   <code>=</code>  赋值运算符  | 下标<code>[]</code>👉数组对象  |调用<code>()</code>👉函数对象→仿函数 |  间接引用<code>-&gt;</code>👉指针对象      -   例如：数组对象→当一个类重载了下标<code>[]</code>运算符时，这个类的对象就能使用<code>[]</code>,这个对象表现的像数组，但本质上还是一个对象，因此叫数组对象      -   函数对象又叫<strong>可调用对象</strong>也叫<strong>仿函数</strong>👉同上</li>
<li>  这四种运算符只支持类内重载</li>
</ul>
</li>
</ul>
<h1 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h1><ul>
<li>  能让类外的函数访问成员私有属性</li>
</ul>
<p><img src="https://i.loli.net/2021/03/08/sI1wiOD2yXjHtC8.png"></p>
<ul>
<li>  友元函数本质上是一个类外部的函数，但是其有friend修饰，可以访问类内部的私有成员属性</li>
</ul>
<h1 id="智能指针对象"><a href="#智能指针对象" class="headerlink" title="智能指针对象"></a>智能指针对象</h1><ul>
<li><p>  外在表现像一个指针，重载了<code>-&gt;</code>运算符以及<code>*</code>运算符</p>
</li>
<li><p>用来防止内存泄漏的</p>
<ul>
<li>内存泄漏👉一片存储区是属于我当前进程的，但是我当前进程却找不到我的存储区了</li>
<li>  <img src="https://i.loli.net/2021/03/08/9O8nDEovlp5Rh6c.png"></li>
<li>  可以看到这里只调用了默认构造函数，并没有发生析构，说明发生了内存泄漏</li>
</ul>
</li>
<li><p>  假设现在有两个智能指针P1, P2指向了同一个对象，那么只有当指向当前对象的指针数量为0的时候，这个时候智能指针对象就会把当前对象给析构掉</p>
</li>
<li><p>原理：</p>
<ul>
<li>  利用了引用计数：记录当前对象到底有多少个智能指针指向对象</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/03/09/WSGXV3THEcPiNZy.png"></p>
<p><img src="https://i.loli.net/2021/03/09/r3XvYz2Mo4UBSDL.png"></p>
<p><img src="https://i.loli.net/2021/03/19/c517Vg2ABajOtfR.png"></p>
<ul>
<li>  91行代码过后为什么p2的cnt也变成2个了</li>
<li>  :exclamation:因为此时调用的是拷贝构造函数    -   且cnt是是一个指针，两者的cnt指向同一片空间</li>
</ul>
<h1 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h1><ul>
<li>  实际是一个对象，只是表现的像一个函数</li>
</ul>
<p><img src="https://i.loli.net/2021/03/09/jrHNWRfZhTtiYX5.png"></p>
<p><img src="https://i.loli.net/2021/03/09/c4H1aCXTLK5gU6s.png"></p>
<p><img src="https://i.loli.net/2021/03/09/5DEybJhNvOIxkew.png"></p>
<h1 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三/五法则"></a>三/五法则</h1><ul>
<li>需要析构函数的类也需要拷贝构造函数和拷贝赋值函数<ul>
<li>  当我在类中有一些属性是要申请空间的时候，就需要析构函数进行资源回收。</li>
<li>  当这些属性发生拷贝行为时，必须要深拷贝</li>
</ul>
</li>
<li>需要拷贝操作的类也需要赋值操作，反之亦然<ul>
<li>  一般都要考虑重载赋值运算符</li>
</ul>
</li>
<li>  析构函数不能是删除的</li>
<li>如果一个类有删除的或不可访问的析构函数，那么其默认和拷贝构造函数会被 定义为删除的。<ul>
<li>  一个类如果不能自动销毁，那么其就不能自动产生（逻辑上）</li>
</ul>
</li>
<li>  如果一个类有const或引用成员，则不能使用合成的拷贝赋值操作</li>
</ul>
<h1 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h1><ul>
<li><p>在实际工程开发中，我们会将构造函数和析构函数设计的极其简单</p>
<ul>
<li>  原因：如果在构造函数中进行大资源的申请并出现了BUG， C++的异常捕获机制将很难捕获到，也很难处理</li>
<li>  解决： 额外的做一个伪构造函数和一个伪析构函数——类似设计模式中的工厂模式</li>
</ul>
</li>
<li><p>C++11标准是让C++重回神坛的一个标准</p>
<ul>
<li>  C++11之前没有区分左值和右值的概念，也就是常驻值和临时值 </li>
<li>  我们在使用stl工具时会发生大量拷贝操作——移动构造 </li>
</ul>
</li>
<li><p>C++学习重点</p>
<ul>
<li>  程序的处理流程 </li>
<li>  当C++调用一个函数时，背后可能发生的是非常复杂的处理流程</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">srymaker0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/cpp_2_%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84/">http://example.com/cpp_2_%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Don't say sorry</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++, 面向对象</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/cpp_1_%E4%BB%8Ec%E5%88%B0c++/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">从c到c++</div></div></a></div><div class="next-post pull-right"><a href="/CPP%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CPP个人笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/cpp_1_从c到c++/" title="从c到c++"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-03</div><div class="title">从c到c++</div></div></a></div><div><a href="/CPP个人笔记/" title="CPP个人笔记"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-03</div><div class="title">CPP个人笔记</div></div></a></div><div><a href="/cpp_4_继承/" title="继承"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-03</div><div class="title">继承</div></div></a></div><div><a href="/cpp_3_类与对象/" title="类与对象"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-03</div><div class="title">类与对象</div></div></a></div><div><a href="/cpp_5_多态/" title="问题引入"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-03</div><div class="title">问题引入</div></div></a></div><div><a href="/cpp_6_c++零碎知识点/" title="c++零碎知识点"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-03</div><div class="title">c++零碎知识点</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">默认构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">有参构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.4.</span> <span class="toc-text">深拷贝与浅拷贝</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#default%E5%92%8C-delete"><span class="toc-number">2.</span> <span class="toc-text">&#x3D;default和&#x3D;delete</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">4.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">智能指针对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">可调用对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E4%BA%94%E6%B3%95%E5%88%99"><span class="toc-number">8.</span> <span class="toc-text">三&#x2F;五法则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E7%9F%A5%E8%AF%86"><span class="toc-number">9.</span> <span class="toc-text">小知识</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By srymaker0</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/js/pool.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>