<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CPP个人笔记</title>
    <url>/posts/db87.html</url>
    <content><![CDATA[<h2 id="冲-兄弟们"><a href="#冲-兄弟们" class="headerlink" title="冲, 兄弟们"></a>冲, 兄弟们</h2><ul>
<li><a href="https://srymaker0.com/posts/85a7">1.从c到c++</a></li>
<li><a href="https://srymaker0.com/posts/3bd">2.构造与析构</a></li>
<li><a href="https://srymaker0.com/posts/8a1e">3.类与对象</a></li>
<li><a href="https://srymaker0.com/posts/6f17">4.继承</a></li>
<li><a href="https://srymaker0.com/posts/21f6">5.多态</a></li>
<li><a href="https://srymaker0.com/posts/b26a">6.auto、constexpr、nullptr、左值与右值、移动构造</a></li>
<li><a href="https://srymaker0.com/posts/e383">7.模板</a></li>
<li><a href="https://srymaker0.com/posts/130c">8.异常</a></li>
<li><a href="https://srymaker0.com/posts/4864">9.C++线程</a></li>
</ul>
]]></content>
      <tags>
        <tag>C++, 面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Taekwondo之540</title>
    <url>/posts/e584.html</url>
    <content><![CDATA[<h1 id="跆拳道540个人练习"><a href="#跆拳道540个人练习" class="headerlink" title="跆拳道540个人练习"></a>跆拳道540个人练习</h1><p>因为是一位码农，所以才会想要挑战自我！</p>
<ul>
<li>跆拳道业业业余爱好者！</li>
<li>逐帧剖析540错误练习</li>
</ul>
<p><span class="github-emoji"><span>📹</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/1f4f9.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<video width="320" height="240" controls="">
    <source src="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/1624548607220213.mp4" type="video/mp4">
</video>




<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210624221317.png" alt=""></p>
<ul>
<li>准备姿势我觉得还可以</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210624221600.png" alt=""></p>
<ul>
<li>迈步ok，感觉手还是没摆起来</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210624222120.png" style="zoom: 33%;"></p>
<p><span class="github-emoji"><span>⭐</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>我靠，我不知道我在干嘛，这一步其实也很关键，起跳脚不对会影响你的起跳高度，手不对会影响你的重心</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210624222408.png" alt=""></p>
<ul>
<li>准备起飞</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210624230443.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210624230518.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210624222606.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210624223726.png" alt=""></p>
<p>飞了飞了！！！</p>
<p>上图这时右手明显不对，这是整空中右手冲拳呢<span class="github-emoji"><span>❓</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>❓</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>👇</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/1f447.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p>——右手需要往左摆，带动腰转起来</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210624224251.png" alt=""></p>
<p>啊这，这里是整个540的关键地方，右脚大腿</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210624224505.png" alt=""></p>
<p>坠机ing</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210624224838.png" alt=""></p>
<p><span class="github-emoji"><span>❗</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>左脚想踢后旋，空中一定要转体——通过手的配合</p>
<p>——可以看到我的左手下垂，会加速落地，原因也是在空中没有转体</p>
<p>——这样才能在落地之前踢出来</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210624224943.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210624225411.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210624225523.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210624225706.png" alt=""></p>
<p>可以看到我是落地之后继续踢了后摆（自欺欺人）</p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>看到身体素质有待提高，腰腹力量需要加强！</p>
<p>特技一方面靠的是基础（后旋+360），一方面也需要靠技巧（预备式），还有一方面就是多练吧！</p>
]]></content>
      <tags>
        <tag>Taekwondo</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表与布隆过滤器</title>
    <url>/posts/69d8.html</url>
    <content><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><blockquote>
<p>哈希表是利用数组的快速存取的特性<span class="github-emoji"><span>👉</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>关键是利用哈希函数——设计感极强</p>
<p>哈希函数：将任意数据类型映射成数组下标，数据类型不同，映射过程也不相同</p>
<p><span class="github-emoji"><span>⭐</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>哈希的过程本质是 高维-&gt;低维的转换，哈希冲突一定会发生，但是可以通过很多方式预防这种冲突，但是这种冲突是无法避免的</p>
<p>冲突处理方法：开放定址法，再哈希法，建立公共溢出区，链式地址法（拉链法）</p>
</blockquote>
<p>可查看中<a href="https://srymaker0.com/posts/73f4">数据结构基础——C语言实验</a>哈希过程</p>
<h2 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h2><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210710205559.png" style="zoom:50%;"></p>
<p>注意扩容操作——装填因子：$\frac{存储元素个数}{哈希总容量}=0.75$ ，假设有100个容量存储数据，当容量为75个时就应该进行扩容操作</p>
<p>扩容的时间复杂度——算的是均摊时间复杂度$O(1)$, $\frac{n}{2}+\frac{n}{4}+\frac{n}{8}+…\approx n$ </p>
<p>估算：假设有n个元素，并且第一次发生扩容操作在$\frac{n}{2}$处，那么第一次的时间复杂度为$\frac{n}{2}$，依次类推所有元素进行的扩容操作为$O(n)$,但是算均摊，每一个元素进行的扩容操作为$O(1)$</p>
<h2 id="建立公共溢出缓冲区"><a href="#建立公共溢出缓冲区" class="headerlink" title="建立公共溢出缓冲区"></a>建立公共溢出缓冲区</h2><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210710222603.png" style="zoom:50%;"></p>
<p>当发生冲突，直接将元素放入set容器中（公共溢出缓冲区）</p>
<p>set底层是红黑树，单次查找，插入时间复杂度都是$O(logn)$</p>
<p>注意扩容的时候 缓冲区的值也要拷贝给新的哈希表</p>
<h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210710223124.png" style="zoom:50%;"></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210710223208.png" style="zoom:50%;"></p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>传统哈希表——存储空间与元素数量有关</p>
<p>布隆过滤器——存储空间与元素数量无关</p>
<p>关于爬虫：爬网站可以将这些存储在哈希表中，一样的url会被去重，但是动态网络的url可能非常庞大，使用传统哈希表存储可能占用几TB的存储空间</p>
<p>布隆过滤器的应用：大数据量；有信息安全要求</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210710224832.png" style="zoom: 33%;"></p>
<p>设计巧妙之处：一个数据经过3个哈希函数，得到3个数组下标，查找数组若这3个下标对应的值都为1，则说明这个数据大概率存在，若有一个是0，则一定不存在</p>
<p>缺点：存在误判，只能准确判断一个数据不存在</p>
]]></content>
  </entry>
  <entry>
    <title>IO多路复用</title>
    <url>/posts/0.html</url>
    <content><![CDATA[<h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><p><span class="github-emoji"><span>❓</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>为什么会出现IO多路复用</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210721145201.png" alt=""></p>
<ul>
<li><p>系统调用会带来额外的开销：</p>
<ul>
<li>操作系统层面(准确)：作为用户程序如何调用系统资源</li>
<li>更宏观的层面：调用系统函数(system call)</li>
</ul>
</li>
<li><p>内核态：执行特权指令 ｜ 用户态：执行非特权指令</p>
<ul>
<li>从用户态到内核态：通过系统调用（主要）、中断、异常</li>
</ul>
</li>
</ul>
<blockquote>
<p>  高并发需要考虑系统调用的开销<br>  因为从用户态下沉到内核态往往伴随着数据的拷贝，加上本身切换的时间成本，会影响性能，因此减少数据的拷贝次数是提高高并发性能的关键。</p>
</blockquote>
<ul>
<li>NIO（非阻塞IO）实现并发：在循环中采用轮询机制——同时和100个女朋友聊天，其中一个不理我，那就找下一个聊，过会再来看看(EAGAIN)<ul>
<li>弊端，需要自己反复的查看，而没有一种通知机制</li>
</ul>
</li>
<li>解决：使用IO多路复用</li>
</ul>
<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><blockquote>
<p>  船长奇特类比：假设我拥有很多女朋友（文件描述符），每天只关心三件事，女友想跟我说话（可读），女友想听我说话（可写），女友想跟我分手（异常），<code>select</code>会在女朋友的思想里（内核中）监控，告诉你有多少女朋友想跟你说话、你可以跟她说话、或者要跟你分手（这三个都是就绪态），但是不会具体指出哪一个。此时我想知道是哪个女朋友能跟我进行对话（就绪），我只能去问<code>select</code>，并且是一个一个问三种状态（可选择）。</p>
</blockquote>
<p>通过这个类比可以得出一些结论：</p>
<ul>
<li><p><code>select</code>时间复杂度高：假设有1000个女朋友，只有第999个是就绪态的，那么我需要从第一个轮询到第999个</p>
<ul>
<li><p>用户态和内核态都需要轮询</p>
</li>
<li><p>三种状态可以选择，若是只需要监听有哪些文件是可读的，只需要问一种状态即可，在较小的客户量下使用select完全可以处理过来</p>
</li>
</ul>
</li>
<li><p>拷贝次数多：<code>select</code>执行先从用户态拿到需要监听的集合，然后下沉到内核态进行监听，接着返回给用户态有哪些文件描述符是就绪的，这里发生了两次数据拷贝行为</p>
<ul>
<li>通过<code>FD_ISSET</code>去轮询</li>
</ul>
</li>
<li><p>并发量有上限</p>
</li>
</ul>
<p>原型</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210721150123.png" alt=""></p>
<ul>
<li>nfds: 文件描述符集合——底层使用数组维护，数量有一个上限，一般为1024</li>
<li>fd_set: 定义文件描述符的集合状态——可读，可写，异常</li>
<li>timeout: 时间间隔——一直等（NULL），等多久（&gt;0），立即返回（0）</li>
<li>四个宏操作集合<ul>
<li>FD_CLR——从集合中删除一个文件描述符</li>
<li>FD_ISSET——查看一个文件描述符是否在集合中</li>
<li>FD_SET——添加一个文件描述符到集合中</li>
<li>FD_ZERO——清空集合</li>
</ul>
</li>
</ul>
<p>描述</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210721151433.png"></p>
<p><code>select</code>和 <code>pselect</code> 允许程序监视多个文件描述符，等待一个或多个文件描述符变成“ready”进行某类 I/O 操作</p>
<ul>
<li>ready：就绪态，无阻塞的读或足够小的写</li>
</ul>
<p><code>select</code>和<code>pselect</code>的区别：</p>
<ol>
<li><p>精度不一样：前者的timeval结构体使用秒和微秒，后者的timespec使用秒和纳秒</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210721153619.png" style="zoom: 33%;"></p>
</li>
<li><p><code>select</code> 可能会更新超时参数以指示还剩多少时间。  <code>pselect</code>不会改变这个参数。</p>
</li>
<li><p><code>select</code>没有 <code>sigmask</code> 参数，其行为与使用<code>NULL sigmask</code>调用的<code>pselect</code> 一样。</p>
<ul>
<li><code>pselect</code>可以忽略<code>sigmask</code>设置的信号</li>
</ul>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210721152415.png" alt=""></p>
<p>select监视三组独立的文件描述集合</p>
<ol>
<li>可读的——文件描述符是否有内容</li>
<li>可写的——监视文件描述符中是否有可用空间写入</li>
<li>异常的——文件描述符是否存在异常</li>
</ol>
<p>退出的时候，每个文件描述符集合会被修改，只留下状态发生变化的文件描述符，起指示作用</p>
<ul>
<li>所以，如果循环使用select，每次调用select前需要重新初始化每个集合</li>
</ul>
<p><code>nfds</code>的值应该是最大文件描述符+1，因为文件描述符从0开始</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210721175220.png" alt=""></p>
<ul>
<li>使用<code>select</code>可以制作更加精确的计时器，并且可移植</li>
<li>nfds设置为0，三个集合设置为NULL，timeout非NUL</li>
</ul>
<p>返回值</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210721153718.png" alt=""></p>
<ul>
<li>成功时，select() 和 pselect() 返回三个返回的描述符集中包含的文件描述符的数量（readfds、writefds、exceptfds）</li>
<li><p>如果超时，可能返回0</p>
</li>
<li><p>出错，返回-1</p>
</li>
</ul>
<h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><blockquote>
<p>本质上和select是一样的，只是底层数据结构不一样</p>
<p>继承了基本上select的所有缺点，除了最大文件描述符的限制</p>
</blockquote>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210721212821.png" alt=""></p>
<ul>
<li>fds：一个结构体数组</li>
<li>nfds：数组大小</li>
<li>timeout：时间间隔</li>
</ul>
<p><code>struct pollfd</code>结构体成员</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210721213301.png" alt=""></p>
<ul>
<li>fd：打开文件的文件描述符<ul>
<li>若为负数，events字段被忽略，revents返回0</li>
</ul>
</li>
<li>events：输入参数，下沉到内核<ul>
<li>16位的位掩码，每一位可表示一个状态</li>
<li>指定感兴趣的事件文件描述符fd</li>
</ul>
</li>
<li>revents：输出参数，返回给用户态<ul>
<li>由内核填充实际发生的事件</li>
<li>返回包括事件中指定的任何值</li>
<li>还可以返回<code>POLLERR</code>,<code>POLLHUP</code>,<code>POLLNVAL</code>，这三个值在events中没有意义</li>
</ul>
</li>
</ul>
<p><code>标志位</code></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210721214246.png" alt=""></p>
<ul>
<li>POLLIN：可读标志位</li>
<li>POLLOUT：可写标志位</li>
</ul>
<p>返回值</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210721220024.png" alt=""></p>
<ul>
<li>&gt;0: 返回一个revents字段不是0的结构体个数<ul>
<li>可能包含events或者出错</li>
</ul>
</li>
<li>=0: 超时或者没有文件描述符就绪</li>
<li>-1：出错，设置errno值</li>
</ul>
<h1 id="star-epoll"><a href="#star-epoll" class="headerlink" title=":star:epoll"></a><span class="github-emoji"><span>⭐</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>epoll</h1><p>描述</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210722003304.png" alt=""></p>
<ul>
<li><code>epoll</code>——IO事件驱动设备</li>
<li>三个系统调用<ul>
<li><code>epoll_create</code>：创建一个实例，返回一个指向该实例的文件描述符</li>
<li><code>epoll_ctl</code>：注册感兴趣的文件描述符</li>
<li><code>epoll_wait</code>：等待IO事件，若当前没有可用事件，则一直阻塞</li>
</ul>
</li>
<li>两种触发模式——水平触发（LT）、边缘触发（ET）</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210722004313.png" alt=""></p>
<p>man手册中举了一种情况解释边缘触发：</p>
<ol>
<li>代表管道<code>rfd</code>读取端的文件描述符注册在<code>epoll</code> 实例上。</li>
<li>管道写入器在管道的写入端写入 2 kB 的数据。</li>
<li>调用<code>epoll_wait</code>将返回 <code>rfd</code> 作为<code>ready</code>的文件描述符。</li>
<li>管道读取器从 <code>rfd</code> 读取 1 kB 的数据。</li>
<li>完成对 <code>epoll_wait</code> 的调用。</li>
</ol>
<p>如果此时使用边缘触发，则<code>epoll_wait</code>将一直阻塞在第5步中，原因是边缘触发仅在受监视的文件描述符发生更改时才传递事件。</p>
<ul>
<li>在此例中，管道读取了数据，文件描述符发生了改变，并完成第5步。但是其实并没有把全部数据读取出来，并且在完成调用后文件描述符并没有发生改变，因此<code>epoll_wait</code>会一直阻塞</li>
</ul>
<p>要避免这种情况发生，必须设置相应的文件描述符为非阻塞</p>
<h2 id="epoll-creat"><a href="#epoll-creat" class="headerlink" title="epoll_creat"></a>epoll_creat</h2><p>描述</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210722010315.png" alt=""></p>
<ul>
<li>创建一个epoll实例<ul>
<li>返回一个文件描述符指向该实例</li>
<li>当不需要使用文件描述符时，调用close关闭</li>
<li>当所有的文件描述符都关闭时，才销毁实例</li>
</ul>
</li>
</ul>
<p>返回值</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210722010927.png" alt=""></p>
<ul>
<li>返回一个非负的文件描述符</li>
</ul>
<p>注意点</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210722011130.png" alt=""></p>
<ul>
<li>size的值<ul>
<li>此参数会提示内核分配多少空间给events</li>
<li>但是在现在的内核中会忽略此参数，因为内核可以动态调用events需要的空间，填上此值只是为了兼容旧内核的程序</li>
</ul>
</li>
</ul>
<h2 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h2><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210722011929.png" alt=""></p>
<ul>
<li>epfd：是创建实例返回的文件描述符</li>
<li><p>op：对应三种操作——增，删，改</p>
<ul>
<li><code>EPOLL_CTL_ADD</code>：在文件描述符 epfd 引用的 epoll 实例上注册目标文件描述符<code>fd</code>并关联<code>event</code></li>
<li><code>EPOLL_CTL_MOD</code>：更改与目标文件描述符<code>fd</code>关联的事件<code>event</code></li>
<li><code>EPOLL_CTL_DEL</code>：从<code>epfd</code>引用的<code>epoll</code>实例中移除（注销）目标文件描述符 fd。 </li>
</ul>
</li>
<li><p>event</p>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210722013901.png" alt=""></p>
<ul>
<li>events和poll中的events一样，都是位掩码<ul>
<li><span class="github-emoji"><span>❗</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>但是返回的状态信息也在此events中修改，原来的状态可以在data中找回</li>
</ul>
</li>
<li>data可以指向一个文件描述符指针，也可以等于一个文件描述符，很灵活</li>
<li>data中存储的是原fd的数据，可以通过data找回</li>
</ul>
<p>返回值</p>
<ul>
<li>成功，返回0. </li>
<li>失败，返回-1</li>
</ul>
<h2 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h2><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210722014639.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210722015226.png" alt=""></p>
<ul>
<li><p>返回epfd指向的实例中的所有就绪文件描述符个数</p>
</li>
<li><p>events中存放的是<code>ready</code>的文件描述符</p>
</li>
</ul>
<h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><p>思考点</p>
<ol>
<li>epoll使用了mmap吗？<ul>
<li>对于mmap，在早起的Linux内核版本中，需要用户自己使用mmap将自己的文件描述符给内核空间，内核升级之后，这个过程不需要用户自己去做了。</li>
<li>早起需要用户去做，现在是epoll自己已经实现的，但是需要注意的是，这个只是对fd的映射，也就是在进行ready状态的fd传递的时候做，并不会映射其他的</li>
<li>网上有很多文章会把这个点误解为：epoll使用了mmap，所以当用户在read和write的时候，可以直接从内核中拷贝。但是实际是，在文件描述符的传递上，做了这个操作，不需要像select，poll一样来回传递，但是对于fd真实的IO操作，不可能做到这一点</li>
<li>select/poll每次调用时都要传递你所要监控的所有socket给select/poll系统调用，这意味着需要将用户态的socket列表copy到内核态，但是epoll就不用，因为在epoll-ctl时已经在内核态存储了需要监控的sock列表。</li>
</ul>
</li>
<li>关于最大文件描述符，<code>epoll</code>真的可以无限存储吗？<ul>
<li><code>select</code> 的上限是默认是1024，这个值之所以默认是1024，是因为在早起的Linux中，默认打开最大文件数就是1024，所以FD_SETSIZE设置为1024,那么打开的文件数就不会超过1024。修改 FD_SETSIZE 重新编译内核可增大并发数，但因为 O(n) 轮询时间复杂度高治标不治本所以不采纳 </li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>shell</title>
    <url>/posts/9924.html</url>
    <content><![CDATA[<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><p><strong>我们用的是bash解释器 写的脚本</strong></p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/05/gsWrkvQLZd432Vb.png" alt=""></p>
<ul>
<li><p>创建👉 以<code>.sh</code>为文件结尾</p>
</li>
<li><p>执行👉 </p>
<ul>
<li><p>第一种 刚创建的<code>1.first.sh</code>没有可执行权限</p>
   <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod a+x 1.first.sh <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><p>输入上面的命令让所有人获得可执行的权限</p>
</li>
<li><p>接着可以输入<code>./1.first.sh</code>执行文件</p>
</li>
</ul>
</li>
<li><p>第二种</p>
   <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bash 1.first.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>直接用<code>bash</code>命令可以直接运行<code>.sh</code>文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="变量与局部变量"><a href="#变量与局部变量" class="headerlink" title="变量与局部变量"></a>变量与局部变量</h2><ul>
<li><p><strong>变量的定义</strong></p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a=12
a=helloworld
a=`pwd`  #pwd是一个命令  ``这两个点是命令替换符 把命令的输出替换到``中去 再赋值gei
a=$a:a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>注意⚡： <code>=</code>号两边的空格不能省略 否则会被终端理解为是一个命令而不是变量</p>
</li>
<li><p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/05/4ACLGdW1TgaBHJD.png" style="zoom: 50%;"></p>
</li>
<li><p><code>''</code>硬转义→将<code>''</code>内的直接解释成字符</p>
</li>
<li><p><code>""</code>软转义→在<code>""</code>内的变量会被解释成原来的值</p>
</li>
<li><p>==这是一种弱类型语言 <code>a=123</code> 可以理解为整型 也可以理解为字符  但是在系统中就认为a是一个普通变量==</p>
</li>
<li><p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/05/QI2RwChaFJ9bqGe.png" alt=""></p>
</li>
<li><p>在一个变量后面加上一个字符串 实际上做的是简单的字符串拼接</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash 

#这是注释  用#开始  #！这是固定格式 表示用什么解释器解释这个程序这里是用bin目录下的bash解释器

echo "Hello shit of Ynnubs!"
WorkDir=`pwd`
echo -e "In\033[31;32m ${WorkDir} \033[0m"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/05/lvutx3qCR64LecT.png" alt=""></p>
<p>​        </p>
<ul>
<li><p><strong>局部变量</strong></p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">local a=12<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>特殊变量</strong></p>
<ul>
<li><strong>位置变量</strong>：讲的是参数是怎么用的</li>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/05/BlEYjNO8VoRuCQI.png" style="zoom: 50%;"></li>
</ul>
</li>
<li><p>我们用脚本语言应该也能传参  那么如何传参呢</p>
<ul>
<li>如下图 我已经将arg1和arg2传进去了  只是我的程序并没有对参数进行处理  所以我要改写程序</li>
</ul>
</li>
<li><p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/05/B8ZOFqQDYPkWihV.png" alt=""></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash 

#这是注释  用#开始  #！这是固定格式 表示用什么解释器解释这个程序这里是用bin目录下的bash解释器

echo "Hello shit of Ynnubs!"
WorkDir=`pwd`
echo -e "In\033[31;32m ${WorkDir} \033[0m" #-e是打开转义的意思
echo "Program Name : $0"
echo "Arg1 : $1"
echo "Arg2 : $2"
echo "Arg3 : $3"
echo "Arg4 : $4"
echo "Arg5 : $5"
echo "Arg6 : $6"
echo "\$@ : $@"    # \ 为转义字符 你懂的 和c语言一样的
echo "\$* : $*"
echo "\$# : $#"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>运行效果</p>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210713125759.png" style="zoom:50%;"></p>
<p>​        </p>
<p>​         </p>
<p>​                    </p>
<ul>
<li><strong>输入输出</strong></li>
<li><p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/05/8nVIiBEpe7qKGMD.png" style="zoom: 33%;"></p>
</li>
<li><p><code>-p</code>和<code>-s</code>用的最多</p>
<ul>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/05/FI2rC3AmqvXwdNZ.png" style="zoom: 80%;"></li>
</ul>
</li>
<li><p><code>-t</code>用的也挺多  若超过响应时间 会自动判定执行失败</p>
<p>  <img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/05/hyXEI269qOBeKWj.png" style="zoom: 80%;"></p>
</li>
<li><p>输出：echo</p>
<ul>
<li>-e：开启转义</li>
</ul>
</li>
<li><p>输出：printf</p>
<ul>
<li>和C语言的printf非常像！</li>
<li><a href="https://gitee.com/doubleL3/blog-imgs/raw/master/img/eDTN857.png"><img src="/img/loading.gif" data-original="https://gitee.com/doubleL3/blog-imgs/raw/master/img/eDTN857.png" alt="图片"></a></li>
<li>[PS] !和\n放一起有特殊含义，需要分开<ul>
<li>bash下需要分开</li>
<li>zsh下可以分开，或用\转义</li>
<li>一般对于<a href="https://www.runoob.com/w3cnote/shell-special-char.html">特殊符号</a>——菜鸟教程，需要警觉！</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/05/JVNw3ILP9YhlpTu.png" style="zoom: 33%;"></li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash
  #最好保留function 和() 增加可读性
function __printf__() {  #两个下划线
      echo "$1"
      return
  }
  
  __printf__ "Hello shit of Ynnubs"  #这是函数的调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>没有形参</li>
<li>定义：写法很多，function、()、{}组合搭配，第3种更类似C语言写法</li>
<li>调用：函数名 参数…</li>
<li>加function方便阅读</li>
<li>❗【注意】shell中函数return的返回值有限制，范围是0-255，溢出会循环换算</li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a><strong>流程控制</strong></h2><ul>
<li><p><strong><code>if</code>语句</strong></p>
</li>
<li><p>建议写成这种形式 因为兼容性更强</p>
  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash
read a  #表示输入一个参数 个人感觉类似与scanf
if [[ ${a} -gt 10 ]];then
    echo "$a &gt; 10"
elif [[ ${a} -eq 10 ]];then
    echo "$a = 10"
else
    echo "${a} &lt; 10"
fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>​    </p>
<ul>
<li><p><code>[[  ]]</code>  这个里面写的是<code>test</code>表达式  可以通过<code>man</code>手册查阅   </p>
<ul>
<li>可判断类型：字符串、整型、文件</li>
<li>❗ 【注意】条件为真时，返回0，否则返回非0<ul>
<li>Linux中命令的返回值也是如此，0才代表成功</li>
</ul>
</li>
<li>[PS]<ul>
<li>STRING1 = STRING2 也可以用== 【推荐后者，两个中括号[[ ]]支持】</li>
<li>-G FILE：文件存在并且被有效组ID拥有</li>
<li>如果组被解散了，则组控制的文件的组ID就是无效的</li>
</ul>
</li>
</ul>
</li>
<li><p>我们再来举个例子</p>
   <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash
TargetFile="a.c"
if [[ -r ${TargetFile} ]];then    	# -r 文件存在并且可读
gcc a.c -o a 					 	# 编译a.c
    ./a 						     	# 执行
else
    echo "${TargetFile} not Found!" 	# 否则输出找不到
fi
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
   <pre class="line-numbers language-c" data-language="c"><code class="language-c">//a.c文件
#include &lt;stdio.h&gt;
int main() {
    printf("Czpei is my son!\n");
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/06/Lp3KBva6qQdgTDI.png" alt=""></li>
</ul>
</li>
<li><p><strong><code>case</code>语句</strong></p>
   <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash
read a
case $a in
    1)
        echo 1
        ;;
    2)
        echo 2
        ;;
    *) #默认情况
        echo "Not Found"
        ;;
esac
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>用的比较少 做菜单的时候可以使用case语句</li>
</ul>
</li>
<li><p><strong>循环</strong></p>
<ul>
<li><p><code>for</code>两种形式</p>
</li>
<li><p>双小括号<code>(())</code>中的内容只要符合C语言运算规则即可，变量可以不使用变量前缀$，可以写i++，平常不可以用++</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash
for i in $@;do    #$@表示对所有参数
    echo $i
done

for ((i=1; i&lt;=100; i++));do
echo $i
done
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>while</code>语句</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash
num=0
while [[ $num -lt 100 ]];do
    echo ${num}
    num=$[ ${num} + 1 ]
done
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>until</code>语句</p>
<ul>
<li><p>直到 满足某个条件才会结束循环</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash
num=0
until [[ $num -eq 100 ]];do  
    echo $num
    num=$[ ${num} + 1 ]
done
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>for循环求偶数和</p>
   <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash
#for i in `seq 1 100`  #seq表示生成1-100的序列 但是效率低下 因为seq是个进程 系统会每次调用
sum=0
for (( i=1; i&lt;=100; i++ ));do
    if [[ $[ ${i} % 2 ] -eq 0 ]];then
        sum=$[ ${sum} + ${i}]
    fi
done

echo "sum = ${sum}"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="求素数和"><a href="#求素数和" class="headerlink" title="求素数和"></a>求素数和</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash
function Usage(){
    echo "Usage : $0 start_num end_num" #$0获取当前执行shell脚本的文件名，包括路径
    exit
}

function is_prime(){
    num=$1
    local i
    for (( i=2; i&lt;${num}; i++ ));do
        if [[ $[ ${num} % $i ] -eq 0 ]];then
            return 1
        fi
    done
    return 0
}

if [[ $# -ne 2 ]];then # $#得到执行当前脚本的参数个数
    Usage
fi

Start=$1
End=$2

for ((i=${Start}; i&lt;=${End}; i++));do
    is_prime $i  #函数的调用
    if [[ $? -eq 0 ]];then
        sum=$[ ${sum} + $i ]
    fi
done

echo $sum
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>⚡注意这种方法求解素数效率低下  求10-20000 内的素数和 cpu就快爆了  但是利用算法是可以提高效率的 </p>
</li>
<li><p>$+变量名 == 取值</p>
</li>
<li><p>调试 </p>
<ul>
<li><p>全局调试<code>bash -x</code></p>
</li>
<li><p>局部调试</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">set -x
#...代码段..#
set +x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li></li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/06/IKH7jPWdJ9yCGaf.png" style="zoom: 50%;"></p>
<h2 id="让我们先来了解下数组"><a href="#让我们先来了解下数组" class="headerlink" title="让我们先来了解下数组"></a><strong>让我们先来了解下数组</strong></h2><ul>
<li>声明</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/06/qcQWA7PbMFXKSpw.png" style="zoom: 50%;"></p>
<ul>
<li><p>bash中对数组的一些操作</p>
<p>  <img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/06/vJK6j8L2HsDd3et.png" style="zoom: 80%;"></p>
<p>  <img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/06/ZDrE4X5g3IyOoQ1.png" alt=""></p>
</li>
</ul>
<h3 id="素数筛求解"><a href="#素数筛求解" class="headerlink" title="素数筛求解"></a><strong>素数筛求解</strong></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash
if [[ $# -ne 2 ]];then
    echo "Error"
    exit
fi

Start=$1
End=$2
declare -a Prime

function init_prime() {
    local end=$1 						# 此时的$1表示传进去的第一个参数
    local i
    Prime[1]=1
    for ((i=2; i&lt;=${end}; i++));do
        for ((j=$[ ${i} * ${i} ]; j&lt;=${end}; j+=i));do
            Prime[${j}]=1
        done
    done
}

init_prime ${End}  

for ((i=${Start}; i&lt;=${End}; i++));do
    if [[ ${Prime[$i]}x == x ]];then  #x表示字符串拼接 这句话判断Prime[i]是否为空 若为空 则为素数
        sum=$[ ${sum} + ${i} ]
    fi
done

echo ${sum}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="附加知识点"><a href="#附加知识点" class="headerlink" title="附加知识点"></a>附加知识点</h3><ul>
<li><p>.sh脚本可以直接bash或source执行，如果要使用./需要有可执行权限</p>
<ul>
<li><a href="https://www.cnblogs.com/pcat/p/5467188.html">source、sh、bash、./有什么区别</a>——cnblogs</li>
</ul>
</li>
<li><p>set -x可以开启shell调试</p>
</li>
<li><p>Shell命令替换：将命令的输出结果赋值给变量</p>
<p>  ——C语言中文网</p>
<ul>
<li>$() 支持嵌套，反引号``不行</li>
<li>$() 仅在 Bash 中有效 [似乎zsh、sh都支持]，而反引号``可在多种 Shell 中使用</li>
</ul>
</li>
<li><p>双小括号(())中的内容</p>
<ul>
<li>只要符合C语言运算规则即可</li>
<li>变量可以不使用变量前缀$</li>
<li>可以写i++，平常不可以用++</li>
</ul>
</li>
<li><p>⭐在Shell中，变量还未定义时，其值为空，echo输出表现为空行</p>
</li>
<li><p>⭐空格问题【严格】</p>
<ul>
<li>赋值语句：=左右不能有空格</li>
<li>TEST表达式：[[ ]]两端必须有空格</li>
</ul>
</li>
<li><p>对于变量名i，如果想将$i与_i拼接，用$i_i，会去找变量i_i，所以要用${i}_i</p>
</li>
</ul>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul>
<li>写Shell脚本<ul>
<li>不要太考虑性能，单纯做数学计算效率低</li>
<li>为的是快速解决一个问题，用来规划所有任务的流程</li>
<li>做操作前记得加【备份】操作</li>
<li>一般是让系统做事情，难于操作特定的程序做事情<ul>
<li>程序一般有自己的参数设置，但不具有普适性</li>
</ul>
</li>
</ul>
</li>
<li>API一般指服务</li>
<li>⭐<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-shell-styleguide/contents/">Shell 风格指南</a>——Google 开源项目风格指南——Shell编程规范</li>
<li><a href="https://sukbeta.github.io/shell-comment/">Shell脚本多行注释和单行注释的方法</a>——博客</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">:&lt;&lt;!
[要注释的代码]
!
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>可以了解<a href="https://www.runoob.com/linux/linux-comm-let.html">let</a>——菜鸟教程，方便的语法</li>
</ul>
]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之Leetcode刷题集</title>
    <url>/posts/1124.html</url>
    <content><![CDATA[<h1 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h1><ul>
<li><a href="https://srymaker0.com/posts/d64e">1.链表</a></li>
<li><a href="https://srymaker0.com/posts/9199">2.栈</a></li>
<li><a href="https://srymaker0.com/posts/682f">3.队列</a></li>
<li><a href="https://srymaker0.com/posts/2a0c">4.二叉树</a></li>
<li><a href="https://srymaker0.com/posts/3c7d">5.堆与优先队列</a></li>
<li><a href="https://srymaker0.com/posts/20cf">6.并查集</a></li>
<li><a href="https://srymaker0.com/posts/9271">7.快速排序+优化</a></li>
<li><a href="https://srymaker0.com/posts/27bc">8.归并排序</a></li>
<li><a href="https://srymaker0.com/posts/5930">9.有趣的排序</a></li>
<li><a href="https://srymaker0.com/posts/96d5">10.二分查找</a></li>
</ul>
]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>关于MySQL那点事儿</title>
    <url>/posts/d4d4.html</url>
    <content><![CDATA[<h1 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h1><p><a href="https://srymaker0.com/posts/54a3">1.关于MySQL架构</a></p>
<p><a href="https://srymaker0.com/posts/5a4f">2.InnoDB的RC和RR隔离级别的实现</a></p>
]]></content>
      <tags>
        <tag>Innodb</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络概述</title>
    <url>/posts/2a8a.html</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>推荐书籍</p>
<ul>
<li>《计算机网络——自顶向下方法》</li>
</ul>
<p>视频理解</p>
<ul>
<li>Youtube——How it works? Internet TCP/IP model explained, data transfer</li>
<li>以动画形式通俗易懂的解释访问网站数据包转移的过程</li>
</ul>
<p>如何学习计算机网络</p>
<ul>
<li>抱着认识计算机网络世界的心态学习</li>
<li>修炼的是内功，别想着学了计算机网络就能成仙！</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>网络中心</p>
<ul>
<li>可以理解为路由器</li>
</ul>
<p>网络边缘</p>
<ul>
<li>提供服务和享受服务的——家庭网络，移动网络（蜂窝），公司网络</li>
<li>边缘网络会通过某种形式进入互联网</li>
</ul>
<p>DSL（数字用户线接入）</p>
<ul>
<li>电话线和网线做频分复用<ul>
<li>0-4k：电话线数据传输</li>
<li>4-50k：上传数据</li>
<li>50k-1M：下行数据</li>
</ul>
</li>
<li>DSL调制解调器</li>
</ul>
<p>FTTH</p>
<ul>
<li>光纤到户</li>
<li>最常见的接入模式</li>
</ul>
<p>以太网</p>
<ul>
<li>公司，学校最常见——由机构ISP提供服务</li>
<li>拉的是专线（中国移动，联通，电信）</li>
</ul>
<h2 id="OSI七层参考模型"><a href="#OSI七层参考模型" class="headerlink" title="OSI七层参考模型"></a>OSI七层参考模型</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参考模型</th>
<th style="text-align:center">各层解释</th>
<th style="text-align:center">对应设备</th>
<th style="text-align:center">典型协议</th>
<th style="text-align:center">协议数据单元</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用层</td>
<td style="text-align:center">为应用程序提供服务</td>
<td style="text-align:center">计算机</td>
<td style="text-align:center">DHCP、DNS</td>
<td style="text-align:center">报文message</td>
</tr>
<tr>
<td style="text-align:center">表示层</td>
<td style="text-align:center">数据格式转换、数据加密</td>
<td style="text-align:center">计算机</td>
<td style="text-align:center">Telnet、SNMP</td>
<td style="text-align:center">报文message</td>
</tr>
<tr>
<td style="text-align:center">会话层</td>
<td style="text-align:center">建立、管理、维护会话</td>
<td style="text-align:center">计算机</td>
<td style="text-align:center">SMTP、SSH</td>
<td style="text-align:center">报文message</td>
</tr>
<tr>
<td style="text-align:center">传输层</td>
<td style="text-align:center">建立、管理、维护端到端的连接</td>
<td style="text-align:center">进程和端口</td>
<td style="text-align:center">TCP、UDP</td>
<td style="text-align:center">报文段segment、用户数据报</td>
</tr>
<tr>
<td style="text-align:center">网络层</td>
<td style="text-align:center">IP选址与路由选择</td>
<td style="text-align:center">路由器、防火墙、多层交换机</td>
<td style="text-align:center">IP、ICMP、ARP</td>
<td style="text-align:center">IP数据报</td>
</tr>
<tr>
<td style="text-align:center">数据链路层</td>
<td style="text-align:center">提供介质访问和链路管理</td>
<td style="text-align:center">网卡、网桥、交换机</td>
<td style="text-align:center">PPP、Internet</td>
<td style="text-align:center">帧frame</td>
</tr>
<tr>
<td style="text-align:center">物理层</td>
<td style="text-align:center">物理层</td>
<td style="text-align:center">中继器、集线器、网线</td>
<td style="text-align:center">IEEE 802</td>
<td style="text-align:center">比特bit</td>
</tr>
</tbody>
</table>
</div>
<p>物理层</p>
<ul>
<li>对信号和数据的传输——只有传输这一个作用，其它什么也不做</li>
<li>中继器：对信号的加强</li>
</ul>
<p>数据链路层（注意与物理层的区分）</p>
<ul>
<li><p>链路是人类抽象出来的，但是设备还是真实存在的</p>
</li>
<li><p>网卡（网络适配器）—— 可以对数据进行处理</p>
</li>
<li>网桥——用于网络与网络的连接</li>
</ul>
<p>网络层</p>
<ul>
<li><p>IP选址</p>
<ul>
<li><p>对某个明确的地址编址，必须有某种明确的协议，并让所有人知道</p>
</li>
<li><p>告诉你一个真实的地址，我们可以从任何地方到达这个地址</p>
</li>
</ul>
</li>
<li><p>路由选择</p>
<ul>
<li>比如从新疆到杭州，有很多路可以走，但我们肯定会选择最优路径</li>
</ul>
</li>
<li><p>防火墙</p>
<ul>
<li>通过我这个地方的数据是符合我的要求的</li>
</ul>
</li>
<li><p>交换机</p>
<ul>
<li><p>二层交换机：在数据链路层</p>
<ul>
<li>可以联想成一个村里的万事通，想找一个人，交换机会在记忆里寻找，若找到则会告诉你你要找的人的所在地</li>
<li>若找不到：会进行广播，在局域网里寻找这个人</li>
</ul>
</li>
<li><p>多层交换机：在网络层</p>
<ul>
<li>同样是找人，但是万事通在一个村里找不到这个人，就去找隔壁村的万事通</li>
<li>在两个村里可以进行交流</li>
</ul>
</li>
</ul>
</li>
<li><p>路由器（router）</p>
<ul>
<li>家用的就是常见路由器</li>
<li>企业、学校：插满网卡，网线的设备，很多入口、出口</li>
</ul>
</li>
</ul>
<p><span class="github-emoji"><span>⭐</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>传输层——什么叫作端到端的连接</p>
<ul>
<li>端到端-&gt;端口到端口的通讯</li>
<li>端口——房间号：可以理解为小区里的1单元1002号，但这个地址是局部的，全中国有很多个这个地址</li>
<li>比如两个人的通信，我在杭州某小区1单元1002号房间， 但是女朋友在北京某小区1单元1003号房间，看似隔得很近，但是却不在一个局域里，这时要想通信，就要先建立地址（具体到某条路什么小区）的连接（主机和主机）-&gt;经过网络层</li>
<li>进程：可以理解为房间内-&gt;进程空间</li>
<li>TCP：传输控制协议。UDP：用户数据报协议</li>
</ul>
<p>应用层</p>
<ul>
<li>给用户提供服务</li>
</ul>
<p>为什么是<strong>参考</strong>模型</p>
<ul>
<li><p>历史原因：创造网络的专家觉得应该设立一个标准，利于日后网络的维护，管理。</p>
<ul>
<li>但是却缺乏实际的经验，并且缺乏商业驱动力</li>
</ul>
</li>
<li><p>缺点：设计过于复杂，运行效率低，制定的周期长，划分不合理（有些重复）</p>
</li>
</ul>
<p>TCP/IP五层模型的出现（国际标准）</p>
<ul>
<li><p>将应用层、表示层、会话层合并成应用层</p>
<ul>
<li><p>简化了原来的模型</p>
</li>
<li><p>只有五层——物理、链路、网络、传输、应用</p>
</li>
</ul>
</li>
</ul>
<h2 id="数据包的封装"><a href="#数据包的封装" class="headerlink" title="数据包的封装"></a>数据包的封装</h2><p><img src="/img/loading.gif" data-original="https://i.loli.net/2021/04/15/jIZbXFQyixUf2qH.png" style="zoom: 25%;"></p>
<p>从源到目的地的数据包到底经历了什么<span class="github-emoji"><span>❓</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<ul>
<li><p>每一层都会给数据包打上一个标签（$H_t \space H_n$等）</p>
</li>
<li><p>可以把这比作给女朋友写信，由应用层发起（M），信写好之后传给传输层，建立端到端的连接（写上女朋友的房间号$H_t$），接着经过网络层再进一步补充地址（某个城市某条路上的小区）</p>
<ul>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2021/04/15/NYc2r74K8dqb5vR.png" style="zoom:33%;"></li>
<li>此时会判断女朋友是否在异地（外网还是内网）<ul>
<li>方法：用子网掩码与IP地址做位与运算，比如我们要访问8.8.8.8，与子网掩码相与为8.8.8.0 不等于 192.168.1.0，此时就可以判断要访问的IP是外网</li>
</ul>
</li>
<li>ok，现在就可以把信交给万事通了（此时为路由器），由路由器去选择路径，最后通过物理层传输到对方网关，然后进行数据包的解析，传到女朋友那！</li>
</ul>
</li>
</ul>
<p>封装分层的好处</p>
<ul>
<li>各层之间是独立的</li>
<li>灵活性好</li>
<li>结构上可分割开</li>
<li>易于实现和维护</li>
<li>能促进标准化工作</li>
</ul>
<p>各层的功能</p>
<ul>
<li>差错控制</li>
<li>流量控制</li>
<li>分段和复用</li>
<li>复用和分用</li>
<li>连接建立和释放</li>
</ul>
<p>网络协议的组成要素</p>
<ul>
<li>语法：数据与控制信息的结构</li>
<li>语义：发出何种控制信息做出何种动作</li>
<li>同步：事件发生的顺序，事件发生是由一定的顺序的</li>
</ul>
<h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>分组交换</p>
<ul>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2021/04/16/O2r7QvIjFlWUAXm.png" alt=""></li>
<li>把一个Message分成很多个小的Packet，让这些Packet自己决定选哪条路走，最后在一个目的地汇合</li>
<li>我们用TCP协议发送了一个数据，这个数据会分成很多个小的数据包，这些数据包不一定走一条路线<ul>
<li>网络瞬息万变，可能一条路走不通就换条路</li>
</ul>
</li>
</ul>
<p>存储转发机制</p>
<ul>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2021/04/16/pEhGyu8tOAQv2oX.png" alt=""></li>
<li>目的：防止数据被篡改，确保接收到的数据是有效的</li>
</ul>
<p>排队时延和分组丢失</p>
<ul>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2021/04/16/puXdaHhk7eQMKUo.png" alt=""></li>
<li>排队时延：最不可控<span class="github-emoji"><span>👉</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>ping值</li>
<li>如果排队队列满：路由器会决定丢弃什么数据</li>
<li><span class="github-emoji"><span>❓</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>排队时延是如何产生的<ul>
<li>假设家里是千兆网，而此时路由器带宽只有1.5Mbps，那么我们发的数据就会拥塞在路由器中（输出队列的排队），不能及时的发数据，就会产生分组丢失（丢包）</li>
<li>对于产生分组丢失：路由器会要求发送方重新发一个数据包</li>
</ul>
</li>
</ul>
<p>转发表、路由选择协议</p>
<ul>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2021/04/16/Obi2cSE6D9hgxyL.png" alt=""></li>
<li>当一个数据包传到路由器时，路由器会对数据包的地址和自身的转发表进行最长前缀匹配，若匹配到，则会重新进行封装，从这个链路传输出去</li>
<li>两者关系：路由选择协议会不断更新路由器的转发表</li>
</ul>
<h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>电路交换：端到端的连接</p>
<ul>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2021/04/16/dspuCrMYie4tVJh.png" alt=""></li>
<li>早期人类拨打电话</li>
<li>当线路被占满，其他人都不可用</li>
<li>真实的端到端的连接：有真实的线路</li>
</ul>
<h2 id="分组交换与电路交换的对比"><a href="#分组交换与电路交换的对比" class="headerlink" title="分组交换与电路交换的对比"></a>分组交换与电路交换的对比</h2><ul>
<li>分组交换提供了更好的带宽共享、灵活简单、实现成本低</li>
</ul>
<h2 id="再探时延"><a href="#再探时延" class="headerlink" title="再探时延"></a>再探时延</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时延类型</th>
<th style="text-align:center">时延量级</th>
<th style="text-align:center">影响因素</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">结点处理时延</td>
<td style="text-align:center">微秒或更低</td>
<td style="text-align:center">处理器能力</td>
</tr>
<tr>
<td style="text-align:center">排队时延</td>
<td style="text-align:center">微秒到毫秒</td>
<td style="text-align:center">流量的强度</td>
</tr>
<tr>
<td style="text-align:center">传输时延</td>
<td style="text-align:center">微秒到毫秒</td>
<td style="text-align:center">带宽</td>
</tr>
<tr>
<td style="text-align:center">传播时延</td>
<td style="text-align:center">毫秒</td>
<td style="text-align:center">距离远近</td>
</tr>
</tbody>
</table>
</div>
<p>结点处理时延：解开标签的过程，很快</p>
<p>排队时延：对于网络的波动的参照</p>
<ul>
<li>最不稳定、波动性大</li>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2021/04/16/98Xs6RICkSFwOHK.png" style="zoom:33%;"></li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>面向面试简答题之查漏补缺</title>
    <url>/posts/79b0.html</url>
    <content><![CDATA[<p><code>面试是一个相互引导的过程，面试官会通过相应的问题来考察你的知识广度和深度，而你需要引导面试官你擅长的领域。</code></p>
<h1 id="——计算机网络——"><a href="#——计算机网络——" class="headerlink" title="——计算机网络——"></a>——计算机网络——</h1><h1 id="简述tcp3次握手"><a href="#简述tcp3次握手" class="headerlink" title="简述tcp3次握手"></a>简述tcp3次握手</h1><p>三次握手 [SYN、ACK]</p>
<ul>
<li><a href="https://cdn.jsdelivr.net/gh/doubleLLL3/blogImgs@main/img/C51Xz7NYuU8B5eIK.png"><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/doubleLLL3/blogImgs@main/img/C51Xz7NYuU8B5eIK.png" alt="图片"></a></li>
<li><strong>第一次握手</strong>：客户端发送SYN包到服务器[客户端进入SYN_SEND状态，等待服务器确认]</li>
<li><strong>第二次握手</strong>：服务器收到，必须确认客户端，设置一个ACK，同时自己也设置一个SYN，即SYN+ACK包[服务端从LISTEN进入SYN_RECV状态]</li>
<li><strong>第三次握手</strong>：客户端收到服务器的SYN＋ACK包，向服务器发送ACK确认包，发送完毕后，客户端进入ESTABLISHED状态，服务器收到ACK后也进入ESTABLISHED状态</li>
<li>注意：每次的ACK序号，在需要确认的包的序号上加一，表示确认</li>
</ul>
<h2 id="简述tcp为什么要3次握手，为什么2次不行，4次可以么？"><a href="#简述tcp为什么要3次握手，为什么2次不行，4次可以么？" class="headerlink" title="简述tcp为什么要3次握手，为什么2次不行，4次可以么？"></a>简述tcp为什么要3次握手，为什么2次不行，4次可以么？</h2><p>首先网络是极其复杂且恶劣的环境，以至于设计出了tcp这样的可靠传输协议，全双工的协议，一条连接的建立，有去必有回才算建立</p>
<ul>
<li>先来看一次握手为什么不行，这当然是行不通的，假设客户端A传一个包给服务端B，此时建立一条连接，而B没有应答，在这个过程中可能出现了丢包的情况，A就无法确认数据包是否送达，有去无回，此时A自然认为自己无法正确连接B。</li>
<li><p>为什么2次不行：同样，客户端A想从服务端B请求数据，发了一个数据包，此时A与B建立一条连接（第一次握手），B收到了A的请求并给A一个应答，此时又建立了一条连接（第二次握手），若就这样结束，因为中途数据包可能丢失，或者因为A结束了与B的连接，那么B也无法判断我建立的这条连接是否能正确的发送数据包，也就无法断定是否建立了与A的连接。——B发了但是没收到应答，不算建立成功</p>
</li>
<li><p>4次可以么？：是可以的，但是没有必要，对A来讲，若B给了一个响应，那么A认为自己是可以连接到B的，同样的，若B给了A应答后收到了A的应答，那么B认为连接建立成功，这样A与B就可以正常通信了。对于4次握手来说，可能对于B应答的应答（第三次握手）这样的数据包在网络中可能丢失，B会再次传送一个应答，来尝试是否能与A进行连接，但这是网络原因，只要B收到了A的应答，那么就是可以进行正确的连接，4次握手可以，但是没有必要，还是无法保证网络的稳定性</p>
</li>
<li><span class="github-emoji"><span>⭐</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>扩展：TCP建立连接的过程中还要确认数据包的序号，防止接受不需要或者不想传的包——A与B建立了连接（发送数据包后），此时A直接断开，但是数据包在网络上流离，此时A又与B重新建立连接，由于网络的时延性，B很有可能收到在网络上流离的数据包，那么这样就不是我们想要的数据。<ul>
<li>所以要确认数据包的序号，这个序号是随着时间的变化而变化的，若是要收到相同序号的包，则需要4个小时，由于存在TTL，那些数据包早就灰飞烟灭了</li>
</ul>
</li>
</ul>
<h2 id="简述从输入网址到浏览器显示的过程"><a href="#简述从输入网址到浏览器显示的过程" class="headerlink" title="简述从输入网址到浏览器显示的过程"></a>简述从输入网址到浏览器显示的过程</h2><blockquote>
<p>  这个问题非常经典，但还是会经常问，因为考察你对计算机网络知识的广度，然后面试官再进一步问你更深入的问题</p>
</blockquote>
<p>总的来说整个过程如下：</p>
<p>DNS解析：将域名解析成IP地址</p>
<ul>
<li>本地hosts，本地DNS解析器缓存</li>
<li>本地DNS</li>
<li>迭代/递归：根DNS服务器，顶级DNS，权威DNS</li>
<li>直到找到域名对应的IP</li>
</ul>
<p>TCP连接：TCP三次握手（可以阐述为什么需要3次握手？）</p>
<p>发送HTTP请求——请求方法、URL、HTTP版本</p>
<p>服务器处理请求并返回HTTP报文</p>
<ul>
<li>解析用户请求，知道了需要调度哪些资源文件，并调用数据库信息，返回给浏览器客户端</li>
<li>返回响应结果——一般会有一个HTTP状态码，比如200、301、404等，通过这个状态码我们可以直到服务器端的处理是否正常，并能了解具体的错误</li>
</ul>
<p>浏览器解析渲染页面</p>
<p>断开连接：TCP四次挥手</p>
<p><span class="github-emoji"><span>⭐</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>上述过程如有不熟悉的，应当加以了解，这是计算机基础</p>
<h2 id="TCP与UDP有哪些区别？"><a href="#TCP与UDP有哪些区别？" class="headerlink" title="TCP与UDP有哪些区别？"></a>TCP与UDP有哪些区别？</h2><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210530151206.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210530151230.png" alt=""></p>
<ul>
<li>TCP是面向连接的，实现数据可靠传输，拥有拥塞控制等流量控制算法，会根据网络环境调节传输速度，比较复杂。</li>
</ul>
<h2 id="TCP四次挥手的过程是什么样的？"><a href="#TCP四次挥手的过程是什么样的？" class="headerlink" title="TCP四次挥手的过程是什么样的？"></a>TCP四次挥手的过程是什么样的？</h2><ul>
<li><p>四次挥手 [FIN、ACK]</p>
<ul>
<li><p><a href="https://cdn.jsdelivr.net/gh/doubleLLL3/blogImgs@main/img/GlWgLx87BeFdH15F.png"><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/doubleLLL3/blogImgs@main/img/GlWgLx87BeFdH15F.png" alt="图片"></a></p>
</li>
<li><p><strong>第一次挥手</strong>：假设客户端想要关闭连接，客户端发送一个FIN包，表示自己已经没有数据可以发送了 [此时仍然可以接收数据][客户端进入FIN_WAIT_1状态]</p>
</li>
<li><p>第二次挥手：服务端回复一个ACK包，表明自己接收到了客户端关闭连接的请求，但自己还需要做些准备来关闭连接[服务端进入CLOSE_WAIT状态]</p>
<ul>
<li>客户端接收到这个ACK后，进入FIN_WAIT_2状态，等待服务端关闭连接</li>
</ul>
</li>
<li><p><strong>第三次挥手</strong>：服务端准备好关闭连接时，向客户端再发送FIN[服务端进入LAST_ACK状态，等待客户端的确认]</p>
</li>
<li><p>第四次挥手：客户端接收到来自服务器端的关闭请求，发送一个ACK包[客户端进入 TIME_WAIT状态，为可能出现的超时重传的FIN包，等待2个MSL时间]</p>
<ul>
<li>服务端接收到这个ACK之后，关闭连接，进入CLOSED状态</li>
</ul>
</li>
<li>客户端等待了<strong>2个MSL</strong>后，如果没有收到服务端的FIN，则认为服务端已经正常关闭连接，于是自己也关闭连接，进入CLOSED状态；否则，再次发送ACK</li>
</ul>
</li>
<li><p>参考<a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html#三次握手与四次挥手?fileGuid=zdkyBEa86pCYmlA6">三次握手与四次挥手</a>——博客 [注：第四次挥手客户端等待的是超时重传的FIN而不是ACK]</p>
</li>
</ul>
<h3 id="附加：2个MSL的含义"><a href="#附加：2个MSL的含义" class="headerlink" title="附加：2个MSL的含义"></a>附加：2个MSL的含义</h3><p>TIME_WAIT是如何引起的，有什么作用，在编程时有什么弊端，怎么解决？</p>
<ul>
<li><p>引起原因：TCP的四次挥手时，已经完成前三次挥手，在第四次挥手时，客户端收到来自服务端的FIN，它在发送一个ACK后，就会进入TIME_WAIT状态</p>
<ul>
<li>此时客户端需要等待两个最大<strong>数据段生命周期</strong>（Maximum segment lifetime，MSL）的时间之后，才会进入CLOSED状态</li>
</ul>
</li>
<li><p>存在原因</p>
<ul>
<li><p>①阻止延迟数据段</p>
<ul>
<li>每一个TCP数据段都包含唯一的序列号，这个序列号能够保证TCP协议的可靠</li>
<li>为了保证新TCP连接的数据段不会与还在网络中传输的历史连接的数据段重复，TCP连接在分配新的序列号之前需要至少<strong>静默</strong>数据段在网络中能够存活的最长时间，即MSL</li>
<li>从而防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的TCP连接收到</li>
</ul>
</li>
<li><p>②保证连接关闭</p>
<ul>
<li>如果客户端等待的时间不够长，当服务端还没有收到ACK消息，而客户端重新与服务端建立TCP连接时，会发生：<ul>
<li>服务端因为没有收到ACK消息，所以仍然认为当前连接是合法的</li>
<li>客户端重新发送SYN消息请求握手时，会收到服务端的RST消息，连接建立的过程被终止</li>
</ul>
</li>
<li>所以要保证TCP连接的远程被正确关闭，即等待被动关闭连接的一方收到FIN对应的ACK消息</li>
</ul>
</li>
</ul>
</li>
<li><p>编程影响</p>
<ul>
<li>对于高并发的场景容易出现过多的TIME_WAIT</li>
<li>而MSL的时长一般是60s，这是难以接受的，可能一个TCP连接只为了通信几秒钟，但TIME_WAIT就需要等待2分钟</li>
</ul>
</li>
<li><p>解决方式</p>
<ul>
<li>基于一个<strong>时间戳变量</strong>，记录发送数据包、最近一次接收数据包的时间</li>
<li>然后配合两个参数<ul>
<li><strong>reuse</strong>：允许主动关闭连接的一方，再次向对方发起连接的时候，复用处于TIME_WAIT状态的连接</li>
<li><strong>recycle</strong>：内核会快速回收处于TIME_WAIT的连接，只需等待RTO时间 [数据包重传的超时时间]</li>
</ul>
</li>
</ul>
</li>
<li><p>参考</p>
<ul>
<li><a href="https://draveness.me/whys-the-design-tcp-time-wait/?fileGuid=zdkyBEa86pCYmlA6">为什么 TCP 协议有 TIME_WAIT 状态</a>——博客</li>
<li><a href="https://zhuanlan.zhihu.com/p/40013724?fileGuid=zdkyBEa86pCYmlA6">系统调优你所不知道的TIME_WAIT和CLOSE_WAIT</a>——知乎</li>
<li><a href="https://www.yisu.com/zixun/63792.html?fileGuid=zdkyBEa86pCYmlA6">理解TIME_WAIT，彻底弄清解决TCP: time wait bucket table overflow</a>——亿速云</li>
</ul>
</li>
</ul>
<h2 id="什么是HTTPS的SSL认证？"><a href="#什么是HTTPS的SSL认证？" class="headerlink" title="什么是HTTPS的SSL认证？"></a>什么是HTTPS的SSL认证？</h2><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210622002619.png" style="zoom:50%;"></p>
<p>参考——<a href="https://www.runoob.com/w3cnote/https-ssl-intro.html">HTTPS 与 SSL 证书概要</a></p>
<h1 id="——C-C-相关——"><a href="#——C-C-相关——" class="headerlink" title="——C/C++相关——"></a>——C/C++相关——</h1><h2 id="C-为什么不像JAVA一样有垃圾回收机制"><a href="#C-为什么不像JAVA一样有垃圾回收机制" class="headerlink" title="C++为什么不像JAVA一样有垃圾回收机制"></a>C++为什么不像JAVA一样有垃圾回收机制</h2><p>垃圾回收机制——在JAVA中，我们对资源的申请不需要人为的手动释放，JVM会自动释放这些资源</p>
<p>C++中有RAII（Resource Acquisition is Initialization——资源获取即初始化）技术管理资源</p>
<ul>
<li>在构造函数中申请分配资源，在析构函数中释放资源——这是C++语言机制保证的，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数，所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</li>
<li>C++中智能指针就利用这样的思想，实现自动的内存管理</li>
<li>可参考<a href="https://www.cnblogs.com/jiangbin/p/6986511.html">C++RAII介绍</a></li>
</ul>
<h2 id="map和unordered-map的区别"><a href="#map和unordered-map的区别" class="headerlink" title="map和unordered_map的区别"></a>map和unordered_map的区别</h2><p>两者底层实现不同：map——红黑树，unordered_map——哈希表</p>
<p>map：为什么要使用红黑树实现，用其它的呢？</p>
<ul>
<li>因为对于单次增删改查操作的时间复杂度都为$O(logn)$</li>
<li>红黑树是二叉查找树，中序遍历可以有序输出</li>
<li>对比BST（binary_search_tree）和AVL——BST会退化为链表，排除；而AVL由于其有严格的平衡条件，每次操作可能花费的时间都在平衡上了，影响效率，不适合</li>
</ul>
<p>Unordered_map</p>
<ul>
<li>哈希表使用拉链法解决哈希冲突，拉链的数据量超过8会使用拉链法，否则自动退化使用红黑树</li>
<li>Unordered_map查询时间复杂度可能做不到$O(1)$，因为其存在退化</li>
<li>做不到数据有序</li>
</ul>
<h2 id="C-STL-sort的实现"><a href="#C-STL-sort的实现" class="headerlink" title="C++ STL sort的实现"></a>C++ STL sort的实现</h2><p>可参考</p>
<p><a href="https://srymaker0.com/posts/9271">数据结构力扣刷题集——7.快速排序+优化</a></p>
<h2 id="const关键字的作用"><a href="#const关键字的作用" class="headerlink" title="const关键字的作用"></a>const关键字的作用</h2><p>修饰变量——该变量不能被改变</p>
<p>修饰指针——指针常量和常量指针</p>
<p>修饰引用</p>
<ul>
<li>形参引用使用const修饰：<code>foo(const int &amp;a)</code>，这样修饰表示传递过程中不会对值进行修改？</li>
</ul>
<p>修饰成员函数</p>
<ul>
<li>成员函数不会对成员变量进行修改</li>
</ul>
<h2 id="static关键字的作用"><a href="#static关键字的作用" class="headerlink" title="static关键字的作用"></a>static关键字的作用</h2><p>修饰普通变量</p>
<ul>
<li>修改变量的存储区域（变为静态区）和生命周期</li>
</ul>
<p>修饰普通函数</p>
<ul>
<li>仅在该函数的文件内可使用——多人开发中常见，两个人在A文件与B文件写了同名函数的情况，比如用static修饰A文件的同名函数可以别人使用你在A文件内的这个函数</li>
</ul>
<p>修饰成员变量</p>
<ul>
<li>对很多实例来说，被static修饰的成员变量只有一个，这么多的实例其实共享一个static成员变量（跟着类走的）</li>
</ul>
<p>修饰成员函数</p>
<ul>
<li>不需要生成对象就可以访问该函数（跟着类走的）</li>
<li>函数内部不能访问非static的成员属性</li>
</ul>
<h1 id="——操作系统相关——"><a href="#——操作系统相关——" class="headerlink" title="——操作系统相关——"></a>——操作系统相关——</h1><h2 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h2><h2 id="说一下零拷贝技术"><a href="#说一下零拷贝技术" class="headerlink" title="说一下零拷贝技术"></a>说一下零拷贝技术</h2>]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面向面试选择题之查漏补缺</title>
    <url>/posts/2dfc.html</url>
    <content><![CDATA[<blockquote>
<p>  选择题包含Linux， 计算机网络，C++语法，操作系统，数据结构等方面的知识点，非常适合查漏补缺</p>
<p>  这些错题个人感觉比较基础，对于操作系统知识需要加强，有一些个人不常见的Linux命令也会考到</p>
<p>  <span class="github-emoji"><span>⭐</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>需要了解对于图这样的数据结构，对于二叉树来说（结点=边数+1）经常考到</p>
<p>  计算机网络考查最多的——TCP、UDP等一系列知识，需重点注意</p>
</blockquote>
<h1 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h1><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210520105933.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210520105856.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210517133930.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210520105811.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210520110007.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210520110102.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210520110118.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210520110154.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210520110318.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="/Users/sorrymaker/Library/Application Support/typora-user-images/image-20210520110411001.png" alt="image-20210520110411001"></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210520110445.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210524134029.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210524134125.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201107.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201015.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201200.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201234.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201302.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201320.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201344.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201403.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201424.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201442.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201501.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201519.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201543.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201601.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201620.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201635.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201656.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201720.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201738.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201756.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201849.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201912.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620201930.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620202132.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620202151.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620202209.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620202230.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620202249.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620202306.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620202337.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620202355.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620202413.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620202429.png" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>mysql之基础篇</title>
    <url>/posts/3361.html</url>
    <content><![CDATA[<h1 id="mysql基础"><a href="#mysql基础" class="headerlink" title="mysql基础"></a>mysql基础</h1><blockquote>
<p>  mysql语言，多练才是王道！</p>
<p>  什么是<a href="https://en.wikipedia.org/wiki/MySQL">mysql</a>——from Wiki</p>
<p>  <img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210521205132.png" alt=""></p>
<p>  使用可视化工具——Datagrip，提高开发效率</p>
</blockquote>
<h1 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h1><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">
SHOW DATABASES;
use mysql;              /* 选择数据库 */
SELECT database();      # 查看当前使用的数据库
SHOW TABLES;

CREATE DATABASE mydb CHARACTER SET  utf8mb4;    # 创建数据库
CREATE DATABASE mydb2;

CREATE DATABASE IF NOT EXISTS mydb2 CHARACTER SET  utf8mb4;

DROP DATABASE mydb;
DROP DATABASE IF EXISTS mydb;                  # 删除数据库，先判断是否存在，这样不会报错

SHOW CREATE DATABASE mydb2;
ALTER DATABASE mydb2 CHARACTER SET utf8mb4;    # 修改数据库字符编码

-- 创建表student，字段包括 编号id、 姓名name、年龄age
CREATE TABLE student (
    id INT,
    name VARCHAR(100),
    age INT
);

-- 创建表users，字段包括 编号id、 姓名username、密码password
CREATE TABLE users (
    id INT,
    username VARCHAR(100),
    PASSWORD varchar(100)
);

SHOW CREATE TABLE users;
/*
CREATE TABLE `users` (
  `id` int(11) DEFAULT NULL,
  `username` varchar(100) DEFAULT NULL,
  `PASSWORD` varchar(100) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
*/

SHOW TABLES;
DROP  TABLE users;
SHOW  TABLES;

-- 添加新的列
ALTER TABLE student ADD `desc` VARCHAR(100);
SHOW CREATE TABLE student;
-- 修改列的数据类型
ALTER TABLE student MODIFY `desc` VARCHAR(50);
-- 修改列的名称
ALTER TABLE student CHANGE `desc` description VARCHAR(100);
-- 删除指定列
ALTER TABLE student DROP description;

-- 修改表的名称
RENAME TABLE student To stu;
-- 修改表的字符编码
ALTER TABLE stu CHARACTER SET gbk;
SHOW CREATE TABLE stu;

-- 插入表记录
INSERT INTO stu(id, name, age) VALUES(1, 'tom', 24);
INSERT INTO stu(name, age) VALUES('lili', 22);
INSERT INTO stu(id, name, age) VALUES(3, 'jim', NULL);

-- 插入多条记录
INSERT INTO stu VALUES(4, 'jack', 26);
INSERT INTO stu VALUES(5, 'zhangsan', 26),(6, 'lisi', 27);
INSERT INTO stu(id, name, age) VALUES (1, '李四', 20),(2, 'zhangsan', 30);

-- 更新表记录
UPDATE stu SET name='lili', age=21 WHERE id=1;
UPDATE stu SET age=25 WHERE age=27;

-- 删除记录
DELETE FROM stu WHERE id=1;
DELETE FROM stu WHERE age IS NULL;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="查询必知必会系列"><a href="#查询必知必会系列" class="headerlink" title="查询必知必会系列"></a>查询必知必会系列</h1><blockquote>
<p>查询操作是工作中使用最多的操作</p>
<p>这部分需要大量练习</p>
</blockquote>
<h2 id="原始数据——products"><a href="#原始数据——products" class="headerlink" title="原始数据——products"></a>原始数据——products</h2><p>基于这张表做一些查询练习<span class="github-emoji"><span>👇</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/1f447.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210521204623.png" alt=""></p>
<h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210521204449.png" style="zoom:67%;"></p>
<p><code>*</code> ——通配符，查找效率慢<span class="github-emoji"><span>👉</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>一般项目开发中都写出所有的列​</p>
<p><code>DISTINCT</code>——应用与所有列</p>
<h2 id="条件限制"><a href="#条件限制" class="headerlink" title="条件限制"></a>条件限制</h2><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210521210035.png" alt=""></p>
<p><span class="github-emoji"><span>❗</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>注意Mysql中行号从<code>0</code>开始</p>
<p>分页查询语句——<code>SELECT * FROM 表名 LIMIT startRow,pageSize;</code></p>
<ul>
<li>后台根据当前页，自动计算开始的行号</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><code>SELECT 列名,... FROM 表名 ORDER BY 排序字段 ASC|DESC;</code></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210521212553.png" alt=""></p>
<h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210521212959.png" alt=""></p>
<p><code>SELECT prod_name,vend_id,prod_price FROM products WHERE vend_id =1001 OR vend_id=1002 AND prod_price&gt;10;</code></p>
<p>不加括号</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210521202733.png" style="zoom:33%;"></p>
<p><code>SELECT prod_name,vend_id,prod_price FROM products WHERE (vend_id =1001 OR vend_id=1002) AND prod_price&gt;10;</code></p>
<p>加括号</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210521202822.png" style="zoom:33%;"></p>
<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p><code>SELECT 列名,... FROM 表名 WHERE 列名 LIKE 条件;</code></p>
<p>like语句中， <code>%</code>代表零个或多个任意字符，<code>_</code>代表一个字符</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210521214028.png" alt=""></p>
<p><span class="github-emoji"><span>❗</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>通配符虽然好用， 但不要滥用， 尽量不要把%放在最前面， 比如：where like 因为这也搜索效率会很慢</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><code>SELECT 列名 FROM 表名 WHERE 列名 REGEXP '条件';</code></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210521214244.png" alt=""></p>
<p>函数</p>
<p>这部分涉及到3张表——先前的products表以及下面两张</p>
<p><code>orderitems</code>表</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210614130751.png" style="zoom:50%;"></p>
<p><code>orders</code>表</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210614130541.png" style="zoom:50%;"></p>
<h2 id="文本函数"><a href="#文本函数" class="headerlink" title="文本函数"></a>文本函数</h2><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210526105505.png" alt=""></p>
<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><p><code>DATE_ADD()</code></p>
<p> 函数向日期添加指定的时间间隔。</p>
<p>格式：<code>DATE_ADD(date,INTERVAL expr type)</code> </p>
<p>解析：date 参数是合法的日期表达式。expr 参数是希望添加的时间间隔。</p>
<p>格式化时间</p>
<p><code>DATE_FORMAT()</code></p>
<p> 函数用于以不同的格式显示日期/时间数据。</p>
<p>格式： <code>DATE_FORMAT(date,format)</code></p>
<p>date 参数是合法的日期。format 规定日期/时间的输出格式。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210526111932.png" alt=""></p>
<h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><p>查询商品表， 并对商品价格进行四舍五入</p>
<p><code>SELECT round(prod_price) FROM products;</code></p>
<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>我们经常需要汇总数据而不用把它们实际检索出来，为此MySQL提供了专门的函数。 </p>
<p>聚集函数（aggregate function） 运行在行组上，计算和返回单个值的函数。</p>
<p>常见的聚合函数：<span class="github-emoji"><span>👇</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/1f447.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<h3 id="MAX"><a href="#MAX" class="headerlink" title="MAX()"></a>MAX()</h3><ul>
<li>MAX() 函数返回指定列的最大值。 </li>
<li>格式： SELECT MAX(column_name) FROM table_name;</li>
</ul>
<h3 id="MIN"><a href="#MIN" class="headerlink" title="MIN()"></a>MIN()</h3><ul>
<li>MIN() 函数返回指定列的最小值。 </li>
<li>格式： SELECT MIN(column_name) FROM table_name;</li>
</ul>
<h3 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT()"></a>COUNT()</h3><ul>
<li>COUNT() 函数返回匹配指定条件的行数。</li>
</ul>
<ol>
<li>COUNT(column_name) 函数返回指定列的值的数目（NULL 不计入）<br>格式： SELECT COUNT(column_name) FROM table_name;</li>
<li>COUNT(<code>*</code>) 函数返回表中的记录数（null也计入）<br> 格式： SELECT COUNT(<code>*</code>) FROM table_name;</li>
</ol>
<h3 id="SUM"><a href="#SUM" class="headerlink" title="SUM()"></a>SUM()</h3><ul>
<li>SUM() 函数返回数值列的总数。 </li>
<li>格式： SELECT SUM(column_name) FROM table_name;</li>
</ul>
<h3 id="AVG"><a href="#AVG" class="headerlink" title="AVG()"></a>AVG()</h3><ul>
<li>AVG() 函数返回数值列的平均值。AVG()函数忽略列值为NULL的行。 </li>
<li>格式： SELECT AVG(column_name) FROM table_name;</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210613154836.png" alt=""></p>
<h1 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h1><blockquote>
<p>  分组查询是指使用group by字句对查询信息进行分组。</p>
<p>  格式：SELECT 字段1,字段2… FROM 表名 GROUP BY分组字段 HAVING 分组条件;</p>
<p>  分组操作中的having子语句，是用于在分组后对数据进行过滤的，作用类似于where条 件。</p>
</blockquote>
<p><code>having</code>与<code>where</code>的区别:</p>
<ul>
<li>having是在分组操作执行后，对分组后的数据进行过滤；where是在分组操作执行前，对分组前的数据只能使用表原始列进行条件过滤</li>
<li>having后面可以使用聚合函数，where后面不可以使用聚合函数</li>
</ul>
<p>当一条SQL语句中, 既有where又有group by \ having时, 先执行where,再执行group by，最后执行having</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210613174739.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210613174832.png" alt=""></p>
<ul>
<li>where要写在group by前面, 不然会报错</li>
</ul>
<h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><blockquote>
<p>  到为止我们所看到的所有SELECT语句都是简单查询，即从单个数据库表中检索数据的单条语句。</p>
<p>  SQL还允许创建子查询（subquery），即嵌套在其他查询中的查询。</p>
</blockquote>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210614131909.png" style="zoom:50%;"></p>
<p>这里给出customers表</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210614132011.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210614134801.png" style="zoom:50%;"></p>
<blockquote>
<p>  解析：首先，它将执行小括号内的子查询 <code>SELECT order_num FROM orderitems WHERE prod_id=60005；</code></p>
<p>  并返回三个订单编号 ：20005,20007,20009</p>
<p>  然后，这三个值以IN操作符要 求的逗号分隔的格式传递给外部查询的WHERE子句。 </p>
<p>  外部查询变成：<code>SELECT cust_id FROM orders WHERE order_num IN (20005,20007,20009);</code></p>
</blockquote>
<p>在WHERE子句中使用子查询能够编写出功能很强并且很灵活的SQL语句。</p>
<p>对于能嵌套的子查询的数目没有限制，不过在实际使用时由于性能的限制，不能嵌套太多 的子查询。</p>
<p>提示：子查询一般与IN操作符结合使用，但也可以用于测试 等于、不等于。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210615131457.png" alt=""></p>
<h1 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h1><h2 id="UNION-操作符"><a href="#UNION-操作符" class="headerlink" title="UNION 操作符"></a>UNION 操作符</h2><p>UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。<br>默认：多个 SELECT 语句会删除重复的数据。（去重）</p>
<ul>
<li><p>格式</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">
SELECT 列名, 列名,...
FROM tables [WHERE 条件] 
UNION [ALL | DISTINCT] 
SELECT 列名, 列名,...
FROM tables [WHERE 条件];
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>解析：</p>
<ul>
<li><p><strong>DISTINCT:</strong> 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没什么影响。</p>
</li>
<li><p><strong>ALL:</strong> 可选，返回所有结果集，包含重复数据。（不进行去重）</p>
</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>假设现在我有两张表：customers、customers2，具有相同的表结构，里面各自存放着不同的数据，customers表里存放的是一月份的顾客数据，customers2表里存放的是二月份的顾客数据，现在我想查询一二月份所有顾客的数据。</p>
<p>知识小扩展：</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">
# 1.复制表结构及数据到新表
CREATE TABLE 新表 SELECT * FROM 旧表;
# 2.仅复制表结构
CREATE TABLE 新表 SELECT * FROM 旧表  WHERE 1=2;  # where后面是永远都不成立的条件
# 3.仅复制数据
INSERT INTO 新表(字段1,字段2,.......) SELECT 字段1,字段2,...... FROM 旧表; 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620084959.png" alt=""></p>
<p><span class="github-emoji"><span>❗</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>第一条复制表语句并不会复制表的约束，使用LIKE可以</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><p>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）。</p>
</li>
<li><p>UNION中的每个查询必须包含相同的列、表达式或聚集函数（各个列不需要以相同的次序列出，但出于业务需求，通常会以相同的顺序列出）。</p>
</li>
<li><p>列数据类型必须兼容：类型不必完全相同，但必须是数据库可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。</p>
</li>
<li><p>UNION和OR比较：在SELECT语句相对复杂的情况下，使用UNION逻辑不容易混乱，比较清楚</p>
</li>
</ul>
<h1 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h1><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><p>现在我们有两张表“顾客表”和“订单表”，为了表明订单属于哪个顾客，通常情况下，我们将在订单表上添加一列，用于存放cust_id的信息，此列称为：外键。</p>
<p><strong>外键（foreign key）：</strong>外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</p>
<p>主表（父表）：对于两个具有关联关系的表而言，相关联字段中的主键所在的那个表即是主表。</p>
<p>从表（子表）：对于两个具有关联关系的表而言，相关联字段中的外键所在的那个表即是从表。</p>
<p><strong>外键特点</strong>：</p>
<ul>
<li><p>从表外键的值是对主表主键的引用。</p>
</li>
<li><p>从表外键类型，必须与主表主键类型一致。</p>
</li>
</ul>
<p>外键的作用<span class="github-emoji"><span>⭐</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>: 保证数据引用的完整性、一致性。</p>
<ul>
<li><p>要考虑向从表添加数据时，外键字段必须是主表主键的引用，否则添加失败。</p>
</li>
<li><p>要考虑从主表中删除数据时，主键并未被从表引用，否则删除失败。</p>
</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 添加外键
alter table 从表 add [constraint][外键名称] foreign key (从表外键字段名) 
references 主表 (主表的主键);
--[外键名称]用于删除外键约束的，一般建议“_fk”结尾
-- 也可以在建表时添加外键约束，
--CONSTRAINT orders_customers_fk FOREIGN KEY (cust_id) REFERENCES customers (cust_id)

-- 删除外键
alter table 从表 drop foreign key 外键名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620103816.png" alt=""></p>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 添加外键
ALTER TABLE orders ADD CONSTRAINT orders_customers_fk FOREIGN KEY (cust_id) REFERENCES customers (cust_id);
# 删除外键
ALTER TABLE orders DROP FOREIGN KEY orders_customers_fk;

# 向主表添加数据
INSERT INTO customers (cust_id,cust_name) VALUES (666,'王老五');-- 成功
# 向从表添加数据
INSERT INTO orders(order_date, cust_id) VALUES (now(),666);-- 成功
# 向从表添加数据
INSERT INTO orders (order_date,cust_id) VALUES (now(),111);-- 失败
# 主表删除数据
DELETE FROM customers WHERE cust_id=666;-- 失败
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h2><blockquote>
<p>  实际开发中，一个项目通常需要很多张表才能完成。</p>
<p>  例如：一个商城项目就需要顾客表(customers)、商品表(products)、订单表(orders)等多张表。</p>
<p>  且这些表的数据之间存在一定的关系，接下来我们将在单表的基础上，一起学习多表方面的知识。</p>
</blockquote>
<h3 id="一对一关系"><a href="#一对一关系" class="headerlink" title="一对一关系"></a>一对一关系</h3><ul>
<li><p>在实际的开发中不多.因为一对一可以创建成一张表.</p>
</li>
<li><p>常见实例：商品表和商品描述表</p>
</li>
</ul>
<p>两种建表原则：</p>
<ul>
<li><p>外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一unique。</p>
</li>
<li><p>外键是主键：主表的主键和从表的外键，形成主外键关系。</p>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620103849.png" style="zoom:50%;"></p>
<h3 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h3><ul>
<li><p>常见实例：客户和订单，分类和商品，部门和员工, 省份和城市</p>
</li>
<li><p>一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键.</p>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620103922.png" style="zoom:50%;"></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620103953.png" style="zoom:50%;"></p>
<h3 id="多对多关系"><a href="#多对多关系" class="headerlink" title="多对多关系"></a>多对多关系</h3><ul>
<li><p>常见实例：商品和订单，学生和课程，用户和角色</p>
</li>
<li><p>多对多关系建表原则：需要创建第三张表,中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键</p>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620104122.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620104137.png" style="zoom:50%;"></p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 1.添加外键
ALTER TABLE orderitems  ADD CONSTRAINT orderiterms_orders_fk FOREIGN KEY (order_num) REFERENCES orders (order_num);
ALTER TABLE orderitems ADD CONSTRAINT orderiterms_products_fk FOREIGN KEY (prod_id) REFERENCES products(prod_id);
# 2.向订单表插入数据
INSERT INTO orders (order_num, order_date, cust_id) VALUES (101,now(),666);
# 3.向商品表插入数据
INSERT INTO products (prod_id,prod_name,vend_id,prod_price) VALUES (101,'大刀',1002,100);

# 4.向中间表插入一条数据（数据存在）
INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price) VALUES (101,1,101,1,100);
# 5.向中间表插入一条数据（数据不存在）  执行失败
INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price) VALUES (101,1,102,1,100);-- 产品表不存在102
INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price) VALUES (102,1,101,1,100);-- 订单表不存在102
# 6.删除商品表   执行失败
DELETE FROM products WHERE prod_id=101;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="实战1：省和市"><a href="#实战1：省和市" class="headerlink" title="实战1：省和市"></a>实战1：省和市</h2><ul>
<li>方案1：多张表，一对多</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620104226.png" alt=""></p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 创建省份表
create table province(
  pid int PRIMARY KEY,
  pname varchar(32), -- 省份名称
  description varchar(100) -- 描述
);

-- 创建城市表
create table city (
  cid int PRIMARY KEY,
  cname varchar(32), -- 城市名称
  description varchar(100), -- 描述
  province_id int,
  CONSTRAINT city_province_fk foreign key(province_id) references province(pid)
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>方案2：一张表，自关联一对多</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620104251.png" style="zoom:50%;"></p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table area (
  id int PRIMARY key AUTO_INCREMENT,
  `name` varchar(32),
  description varchar(100),
  parent_id int,
  CONSTRAINT area_area_fk FOREIGN KEY(parent_id) REFERENCES area(id)
);

INSERT into area values(null, '辽宁省', '这是一个省份', null);
INSERT into area values(null, '大连市', '这是一个城市', 1);
INSERT into area values(null, '沈阳市', '这是一个城市', 1);
INSERT into area values(null, '河北省', '这是一个省份', null);
INSERT into area values(null, '石家庄市', '这是一个城市', 4);
INSERT into area values(null, '保定市', '这是一个城市', 4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>parent_id int</code>多用于描述父子菜单</p>
<h2 id="实战2：用户和角色"><a href="#实战2：用户和角色" class="headerlink" title="实战2：用户和角色"></a>实战2：用户和角色</h2><ul>
<li>多对多关系</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620104311.png" style="zoom:50%;"></p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 用户表
create table `user` (
  uid varchar(32) PRIMARY KEY,
  username varchar(32),
  `password` varchar(32)
);

-- 角色表
create table role (
  rid varchar(32) PRIMARY KEY,
  rname varchar(32)
);

-- 中间表
create table user_role(
  user_id varchar(32),
  role_id varchar(32),
  CONSTRAINT user_role_pk PRIMARY KEY(user_id,role_id),
  CONSTRAINT user_id_fk FOREIGN KEY(user_id) REFERENCES `user`(uid),
  CONSTRAINT role_id_fk FOREIGN KEY(role_id) REFERENCES role(rid)
);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>中间表用于维护这些角色</p>
<p>18行的<code>user_role_pk</code>是一个联合主键，同时关联了<code>user_id</code>,<code>role_id</code></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620144732.png" style="zoom:33%;"></p>
<p>联合主键可以保证中间表可以有重复</p>
<h2 id="exclamation-特别提醒"><a href="#exclamation-特别提醒" class="headerlink" title=":exclamation:特别提醒"></a><span class="github-emoji"><span>❗</span><img src="/img/loading.gif" data-original="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>特别提醒</h2><p>现在这种创建外键的方式已经不提倡，甚至被禁止了，因为在维护数据时，限制条件太多，效率较低。关联关系通过SQL语句来实现。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><blockquote>
<p>  事务: 指的是逻辑上的⼀组操作,组成这组操作的各个单元要么全都成功,要么全都失败.</p>
<p>  事务作⽤：保证在⼀个事务中多次SQL操作要么全都成功,要么全都失败.</p>
<p>  比如：银行转账，小明有50元，小红有10元，小明向小红转账10元，在数据库操作中相当于执行了两条SQL语句</p>
</blockquote>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">UPDATE account SET money=money-10 WHERE id=1;-- 小明账户减10元
UPDATE account SET money=money+10 WHERE id=2;-- 小红账户加10元<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>我们想让这两个操作要么全成功，要么全失败。如何保证呢？就需要把他们放到同一个事务里面进行操作。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210620134230.png" style="zoom:50%;"></p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 创建账号表
create table account(
 id int primary key auto_increment  COMMENT '主键',
 name varchar(20) COMMENT '姓名',
 money double COMMENT '余额'
);
# 初始化数据
insert into account values (1,'小明',50);
insert into account values (2,'小红',10);


# MySQL有一个系统变量autocommit，用来自动提交事务。
SHOW VARIABLES LIKE 'autocommit';
# 默认是开启的，也就意味着在默认情况下，如果不显示地执行  START TRANSACTION 或者 BEGIN 开启一个事务，那么每条SQL语句都算是一个独立的事务，这种特性被称作事务的自动提交；
#  如果想关闭这种自动提交的功能，可以使用两种办法
# 1. 显式使用START TRANSACTION 或者 BEGIN 开启一个事务
# 这样在本次事务中提交或者回滚前会暂时关闭自动提交的u
# 2. 把系统变量 autocommit 设置为 OFF
SET AUTOCOMMIT = off; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一旦开启一个事务，中间的sql语句都不会自动提交，需要自己手动提交【使用commit】</p>
<h2 id="事务有四大特性（ACID）"><a href="#事务有四大特性（ACID）" class="headerlink" title="事务有四大特性（ACID）"></a>事务有四大特性（ACID）</h2><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，</p>
<h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>一个事务的执行不能被其他事务干扰。一个事务内部的操作及使用的数据，对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>关于事务的隔离性数据库提供了多种隔离级别。</p>
<h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h2><h3 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚"></a>事务回滚</h3> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from account;
+----+--------+-------+
| id | name   | money |
+----+--------+-------+
|  1 | 小明   |    50 |
|  2 | 小红   |    10 |
+----+--------+-------+
2 rows in set (0.00 sec)

mysql&gt; update account set money=money-10 where id =1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; update account set money=money+10 where id =2;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; select * from account;
+----+--------+-------+
| id | name   | money |
+----+--------+-------+
|  1 | 小明   |    40 |
|  2 | 小红   |    20 |
+----+--------+-------+
2 rows in set (0.00 sec)

mysql&gt; rollback;
Query OK, 0 rows affected (0.01 sec)

mysql&gt; select * from account;
+----+--------+-------+
| id | name   | money |
+----+--------+-------+
|  1 | 小明   |    50 |
|  2 | 小红   |    10 |
+----+--------+-------+
2 rows in set (0.00 sec)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="事务提交"><a href="#事务提交" class="headerlink" title="事务提交"></a>事务提交</h3> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from account;
+----+--------+-------+
| id | name   | money |
+----+--------+-------+
|  1 | 小明   |    50 |
|  2 | 小红   |    10 |
+----+--------+-------+
2 rows in set (0.00 sec)

mysql&gt; update account set money=money-10 where id=1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; update account set money=money+10 where id=2;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; select * from account;
+----+--------+-------+
| id | name   | money |
+----+--------+-------+
|  1 | 小明   |    40 |
|  2 | 小红   |    20 |
+----+--------+-------+
2 rows in set (0.00 sec)

mysql&gt; commit;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from account;
+----+--------+-------+
| id | name   | money |
+----+--------+-------+
|  1 | 小明   |    40 |
|  2 | 小红   |    20 |
+----+--------+-------+
2 rows in set (0.00 sec)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h2><p>当我们使用start transaction或者begin语句时开启了一个事务。或者把系统变量的值设置为off时，事物就不会进行自动提交。</p>
<p>如果我们输入了某些语句，且这些语句会导致之前的事物，悄悄的提交（就像输入了commit命令一样），那么因为某种特殊的语句而导致，事务提交的情况称为隐式提交。</p>
<p>会导致隐式提交的语句有：</p>
<ul>
<li><p>数据库定义语言DDL，像create、alter、drop</p>
</li>
<li><p>事务控制或关于锁定的语句，比如，前一个事务未提交，又开启了一个新的事务（写了两个begin）</p>
</li>
<li><p>加载数据的语句，比如load data（千万级的数据量会较快）</p>
</li>
<li><p>关于MySQL复制的一些语句 ：slave</p>
</li>
</ul>
<h2 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h2><p>如果你已经开启了一个事物，并且输入了很多语句，这是忽然发现前面已经执行完的某个语句。参数写错了，只好使用rollback语句，让数据库状态恢复到事务执行之前的样子，然后一切从头再来。</p>
<p>这种感觉很不爽，因此就有了保存点的概念。</p>
<ul>
<li><p>语法：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 定义保存点
savepoint  保存点名称;
-- 回滚到某个保存点，如果rollback后面不跟随保存点名称，则直接回滚到事务之前的状态
rollback [work] to [savepoint] 保存点名称 ;
-- 删除保存点
release savepoint 保存点名称; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<ul>
<li><p>案例演示</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; update account set money=money-10 where id =1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; savepoint s1;
Query OK, 0 rows affected (0.01 sec)

mysql&gt; select * from account;
+----+--------+-------+
| id | name   | money |
+----+--------+-------+
|  1 | 小明   |    40 |
|  2 | 小红   |    10 |
+----+--------+-------+
2 rows in set (0.00 sec)

mysql&gt; update account set money=money+1 where id =2;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
-- 回退到保存点
mysql&gt; rollback to s1;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from account;
+----+--------+-------+
| id | name   | money |
+----+--------+-------+
|  1 | 小明   |    40 |
|  2 | 小红   |    10 |
+----+--------+-------+
2 rows in set (0.00 sec)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h1 id="表关联查询"><a href="#表关联查询" class="headerlink" title="表关联查询"></a>表关联查询</h1><h2 id="表别名"><a href="#表别名" class="headerlink" title="表别名"></a>表别名</h2><p>当表的名字很长或者执行一些特殊查询时，为了方便操作或者需要多次使用相同的表时，可以为表指定别名，以替代表原来的名称。</p>
<ul>
<li><p>在为表取别名时，要保证不能与数据库中的其他表的名称冲突。</p>
</li>
<li><p>对单表做简单的别名查询通常是无意义的。一般是对一个表要当作多个表来操作，或者是对多个表进行操作时，才设置表别名。</p>
</li>
<li><p>当为表取别名后，列名前面最好都加上表的别名，做以区分。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT p.*,v.vend_name 
FROM products p ,vendors v  
WHERE p.vend_id=v.vend_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>使用表别名查询，可以使 SQL 变得简洁而更易书写和阅读，尤其在 SQL 比较复杂的情况下。除了使用别名来简化 SQL 外，有些时候例如一个表做自身关联时，必须要使用别名来当作两个表进行关联操作。</p>
<h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/srymaker0/blogImgs@main/Img/20210624140956.png" alt=""></p>
<h3 id="两表内联"><a href="#两表内联" class="headerlink" title="两表内联"></a>两表内联</h3><h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><p>假设现在我想查询给我们供货的供应商的名称，以及商品名称和商品价格。此时我们发现，要查询的字段不在同一张表里。供应商名称在vendors表里，而商品名称和商品价格在products表里，这时可以使用内联查询，将两张表进行关联之后进行查询。</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 这里没有使用表别名
SELECT vend_name, prod_name, prod_price
FROM products,
     vendors
WHERE vendors.vend_id = products.vend_id;

# 这种方式叫等值连接。当然也可以用表别名，来达到同样效果
SELECT v.vend_name, p.prod_name, p.prod_price
FROM products p,
     vendors v
WHERE p.vend_id = v.vend_id;
# 这种连接方式也被称为内部连接，可以用以下语法来明确指定连接类型 -- inner可以省略
SELECT vend_name, prod_name, prod_price
FROM products  INNER JOIN vendors ON vendors.vend_id = products.vend_id;

# 这两种方式都叫内连接，一种是隐式内联，一种是显示内联 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这条语句的FROM子句列出了两个表，分别是vendors和products。它们就是这条SELECT语句联结的两个表的名字。这两个表用WHERE子句正确联结，WHERE子句指示MySQL匹配vendors表中的vend_id和products表中的vend_id。</p>
<h4 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h4><ol>
<li>编写SQL语句，返回customers表中的顾客名称cust_name 和orders表中的相关订单号order_num，并按顾客名称再按订单号对结果进行排序。</li>
</ol>
<p>等值连接查询：</p>
   <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT cust_name,order_num FROM customers ,orders WHERE customers.cust_id=orders.cust_id;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>inner join 语法查询：</p>
   <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT cust_name,order_num FROM customers  INNER JOIN orders ON customers.cust_id=orders.cust_id;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><p>在数据库表的定义中不存在能指示MySQL如何对表进行联结的东西。我们必须自己通过SQL做这件事情。</p>
<p>在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。WHERE子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行。没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。</p>
<p><strong>笛卡儿积</strong>（cartesian product） 由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT v.vend_name, p.prod_name, p.prod_price
FROM products p,  vendors v ORDER BY vend_name,prod_name;
 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>从上面的输出中可以看到，相应的笛卡儿积不是我们所想要的。这里返回的数据用每个供应商匹配了每个产品，它包括了供应商不正确的产品。实际上有的供应商根本就没有产品。所以两表联查时，一定要注意where条件。</p>
<h3 id="多表内联"><a href="#多表内联" class="headerlink" title="多表内联"></a>多表内联</h3><p>SQL对一条SELECT语句中可以联结的表的数目没有限制。创建联结的基本规则也相同。</p>
<h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><p>假设现在要查询订单编号为20005的产品名称，产品价格、产品数量、供应商名称。该如何查询呢？</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 首先，先确认要查询的字段来自哪几张表？经分析可以得出，可以从orderitems、products、venders中获取数据
# 其次，再确定三张表的关联关系
# 然后，确定过滤条件
-- 隐式连接
SELECT prod_name, vend_name, prod_price, quantity
FROM vendors,
     products,
     orderitems
WHERE vendors.vend_id = products.vend_id
  AND products.prod_id = orderitems.prod_id
  AND order_num = 20005;
-- 显示连接
SELECT prod_name, vend_name, prod_price, quantity
FROM orderitems o
         JOIN products p ON o.prod_id = p.prod_id
         JOIN vendors v ON p.vend_id = v.vend_id
WHERE o.order_num = 20005;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 查询所有客户，的订单情况，包括没有订单的客户
SELECT customers.cust_id, orders.order_num
FROM customers
         LEFT OUTER JOIN orders ON customers.cust_id = orders.cust_id;
# OUTER 可以省略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><p>在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）。</p>
<p>上面的例子使用LEFT OUTER JOIN从FROM子句的左边表（customers表）中选择所有行。为了从右边的表中选择所有行，应该使用RIGHT OUTER JOIN，如下例所示：</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT customers.cust_id, orders.order_num
FROM customers
         RIGHT OUTER JOIN orders ON customers.cust_id = orders.cust_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><h3 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h3><p>假设你发现商品id为60001的商品存在质量缺陷，现在需要查找，60001供应商所提供的所有商品的名称和商品id。请问如何编写SQL语句？</p>
<h3 id="分析过程-1"><a href="#分析过程-1" class="headerlink" title="分析过程"></a>分析过程</h3> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 1.使用现有的知识储备，子查询
SELECT vend_id FROM products WHERE prod_id=60001;
SELECT prod_id,prod_name FROM products WHERE vend_id=1001;

SELECT prod_id,prod_name FROM products WHERE vend_id=(SELECT vend_id FROM products WHERE prod_id=60001);

# 2.采用自连接
SELECT p1.prod_id, p1.prod_name, p1.vend_id
FROM products p1,
     products p2
WHERE p1.vend_id = p2.vend_id
  AND p2.prod_id = 60001;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="课堂练习-1"><a href="#课堂练习-1" class="headerlink" title="课堂练习"></a>课堂练习</h2><ol>
<li><p>使用innor join 编写SQL，查询每个顾客的名称，和所有订单号；</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT cust_name,order_num FROM customers INNER JOIN orders ON customers.cust_id=orders.cust_id; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<ol>
<li><p>修改上一题的SQL语句，列出所有顾客，即使他们没有下过订单</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT cust_name,order_num FROM customers LEFT JOIN orders ON customers.cust_id=orders.cust_id;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<ol>
<li><p>使用outer  join 连接products表和orderitems表，返回产品名称prod_name 和与之相关的订单号order_num的列表，并按商品名称排序。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT prod_name,order_num FROM products LEFT JOIN orderitems ON products.prod_id = orderitems.prod_id ORDER BY prod_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<ol>
<li><p>修改上一题中创建的SQL语句，使其返回每一项产品的总订单数（不是订单号）。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT prod_name, COUNT(order_num) AS orders
FROM products
         LEFT OUTER JOIN orderitems
                         ON products.prod_id = orderitems.prod_id
GROUP BY prod_name
ORDER BY prod_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<ol>
<li>编写SQL语句，列出供应商id（vend_id）及其可供产品的数量，包括没有产品的供应商。</li>
</ol>
<p>提示：使用外连接和分组。</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT vendors.vend_id, COUNT(prod_id)
FROM vendors
         LEFT OUTER JOIN products ON vendors.vend_id = products.vend_id
GROUP BY vendors.vend_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="视图作用"><a href="#视图作用" class="headerlink" title="视图作用"></a>视图作用</h2><p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p>
<p>就拿上节课查询订购了某个特定订单信息来说，任何需要这个数据的人都必须理解相关表的结构，并且知道如何创建查询和对表进行联结。</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT prod_name, vend_name, prod_price, quantity
FROM orderitems o
         JOIN products p ON o.prod_id = p.prod_id
         JOIN vendors v ON p.vend_id = v.vend_id
WHERE o.order_num = 20005;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了检索其他产品（或多个产品）的相同数据，必须修改最后的WHERE子句。</p>
<p>现在，假如可以把整个查询包装成一个名为order_detail的虚拟表，则可以直接地检索出相应的数据：</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT prod_name, vend_name, prod_price, quantity 
FROM order_detail 
WHERE order_num=20005;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在视图创建之后，可以用与表基本相同的方式利用它们。可以对视图执行SELECT操作，过滤和排序数据，将视图联结到其他视图或表，甚至能添加和更新数据。</p>
<p>重要的是知道视图仅仅是用来查看存储在别处的数据的一种设施。视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。</p>
<p>因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。所以不要滥用视图。</p>
<h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><p>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</p>
</li>
<li><p>对于可以创建的视图数目没有限制。</p>
</li>
<li><p>为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。</p>
</li>
<li><p>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。</p>
</li>
<li><p>ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。</p>
</li>
<li><p>视图不能索引，也不能有关联的触发器或默认值。</p>
</li>
<li><p>视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。</p>
</li>
</ul>
<h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><p>在理解什么是视图（以及管理它们的规则及约束）后，我们来看一下视图的创建。</p>
<ul>
<li><p>视图用CREATE VIEW语句来创建。</p>
</li>
<li><p>使用SHOW CREATE VIEW viewname；来查看创建视图的语句。</p>
</li>
<li><p>用DROP删除视图，其语法为DROP VIEW viewname;。</p>
</li>
<li><p>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">#查询订单编号为20005的：产品名称，供应商名称，产品价格，购买数量
SELECT order_num,prod_name, vend_name, prod_price, quantity
FROM orderitems o
         JOIN products p ON o.prod_id = p.prod_id
         JOIN vendors v ON p.vend_id = v.vend_id
WHERE o.order_num = 20005;

# 创建视图，包含所有订单的产品名称，供应商名称，产品价格，购买数量
CREATE VIEW order_detail AS
    SELECT order_num,prod_name, vend_name, prod_price, quantity
FROM orderitems o
         JOIN products p ON o.prod_id = p.prod_id
         JOIN vendors v ON p.vend_id = v.vend_id;

# 查看视图的所有数据
SELECT * FROM order_detail;

# 从视图中过滤数据
SELECT * FROM order_detail WHERE order_num=20005;

# 删除视图
DROP VIEW order_detail; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引用于快速找出在某个列中有一特定值的行。不使用索引，MySQL必须从第1条记录开始读完整个表，直到找出相关的行。</p>
<p>表越大，查询数据所花费的时间越多，如果表中查询的列有一个索引，MySQL能快速到达。某个位置去搜寻数据文件，而不必查看所有的数据，这节课我们来介绍与索引相关的内容。</p>
<p><strong>索引</strong>是对数据库中一列或多列的值进行排序的一种结构，使用索引可提高数据库中特定数据的查询速度。</p>
<p>索引是一个单独的存储在磁盘上的数据库结构，包含着对数据表里所有记录的引用指针。使用索引可以快速找出在某个或多个列中的某个值。所有MySQL列类型都可以被索引，对相关列使用索引是<strong>提高查询操作速度</strong>的最佳途径。</p>
<p>索引是在存储引擎中实现的，因此每一种存储引擎的索引，都不一定完全相同。</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="普通索引和唯一索引"><a href="#普通索引和唯一索引" class="headerlink" title="普通索引和唯一索引"></a>普通索引和唯一索引</h3><p>普通索引是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值。</p>
<p>唯一索引要求索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合，必须唯一。主键索引是一种特殊的索引唯一，不允许有空值。</p>
<h3 id="单列索引和组合索引"><a href="#单列索引和组合索引" class="headerlink" title="单列索引和组合索引"></a>单列索引和组合索引</h3><p>单列索引及一个索引只包含单个列，一个表可以有多个单列索引。</p>
<p>组合索引是指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。使用组合索引时遵循最左前缀原则。</p>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><h3 id="创建表时创建"><a href="#创建表时创建" class="headerlink" title="创建表时创建"></a>创建表时创建</h3> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">--普通索引
CREATE TABLE book(
    id int AUTO_INCREMENT PRIMARY KEY ,
    bookname varchar(255) NOT NULL ,
    INDEX (bookname)
);
--唯一索引
CREATE TABLE book2(
    id int AUTO_INCREMENT PRIMARY KEY ,
    bookname varchar(255) NOT NULL ,
   UNIQUE INDEX (bookname)
); 
-- 给索引起名字
CREATE TABLE book3(
    id int AUTO_INCREMENT PRIMARY KEY ,
    bookname varchar(255) NOT NULL ,
   UNIQUE INDEX  name_idx (bookname)
); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意：index 和key是等价的</p>
<h3 id="单独创建索引"><a href="#单独创建索引" class="headerlink" title="单独创建索引"></a>单独创建索引</h3><h4 id="1-普通索引"><a href="#1-普通索引" class="headerlink" title="1.普通索引"></a>1.普通索引</h4> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE INDEX index_name
ON table_name (column_name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="2-唯一索引"><a href="#2-唯一索引" class="headerlink" title="2.唯一索引"></a>2.唯一索引</h4> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE UNIQUE INDEX index_name
ON table_name (column_name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="3-组合索引"><a href="#3-组合索引" class="headerlink" title="3.组合索引"></a>3.组合索引</h4> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE INDEX index_name
ON table_name (column_name1,column_name2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="修改表结构创建"><a href="#修改表结构创建" class="headerlink" title="修改表结构创建"></a>修改表结构创建</h3> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE table_name ADD INDEX name_idx(column_name);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE table_name DROP INDEX index_name;
DROP INDEX index_name ON table_name; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>MySQL的触发器和存储过程一样，都是嵌入到MySQL的一段程序。触发器是由事件来触发某个操作，这些事件包括INSERT,UPDATE和DELETE语句。如果定义了触发程序，当数据库执行这些语句的时候就会激发触发器执相应的操作，触发程序是与表有关的命名数据库对象，当表上出现特定事件时，将激活该对象。</p>
<p>触发器是个特殊的存储过程，不同的是，执行存储过程要使用CALL语句来调用，而触发器的执行不需要使用CALL语句来调用，也不需要手工启动，只要当一个预定义的事件发生的时候，就会被MySQL自动调用。</p>
<h1 id="创建只有一个执行语句的触发器"><a href="#创建只有一个执行语句的触发器" class="headerlink" title="创建只有一个执行语句的触发器"></a>创建只有一个执行语句的触发器</h1><p>语法</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TRIGGER trigger_name trigger_time trigger_event
ON tab_name FOR EACH ROW trigger_stmt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>trigger_name：触发器名称，用户自行指定；<br>trigger_time ：触发时机，可以指定为before或after；<br>trigger_event：触发事件，包括INSERT,UPDATE和DELETE；<br>tab_name：要建立触发器的表名；<br>trigger_stmt：触发器执行语句。</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE book2(
    id int AUTO_INCREMENT PRIMARY KEY ,
    bookname varchar(255) NOT NULL
);
ALTER TABLE book  ADD INDEX name_idx(bookname);
# 创建触发器，在book表中插入一条数据时自动在book2中插入一条
CREATE TRIGGER book_insert_select AFTER INSERT ON book FOR EACH ROW INSERT INTO book2(bookname) SELECT bookname FROM book;
INSERT INTO book(bookname)VALUES ('《平凡的世界2》');
# 查看触发器
SHOW TRIGGERS ;
# 也可以在triggers表中查看触发器
SELECT * FROM information_schema.triggers;
# 删除触发器
DROP TRIGGER book_insert_select;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="创建有多个执行语句的触发器"><a href="#创建有多个执行语句的触发器" class="headerlink" title="创建有多个执行语句的触发器"></a>创建有多个执行语句的触发器</h1><p><strong>语法</strong></p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TRIGGER trigger_name trigger_time trigger_event
ON tab_name FOR EACH ROW 
BEGIN    

语句执行列表
END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>trigger_name：触发器名称，用户自行指定；<br>trigger_time ：触发时机，可以指定为before或after；<br>trigger_event：触发事件，包括INSERT,UPDATE和DELETE；<br>tab_name：要建立触发器的表名；<br>这个可以在BEGIN，END之间包含多条语句。</p>
<p><strong>示例</strong></p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TRIGGER book_insert_select AFTER INSERT ON book FOR EACH ROW
BEGIN
INSERT INTO book2(bookname) SELECT bookname FROM book;
INSERT INTO book3(bookname) SELECT bookname FROM book;
END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>简单的说存储过程就是一条或者多条语句的集合，可视为批文件，但是其作用不仅限于批处理。</p>
<p><strong>1、创建存储过程</strong></p>
<p>MySQL中，创建存储过程的基本形式如下：</p>
   <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE PROCEDURE  存储过程名 (参数列表)
BEGIN    
  SQL语句代码块
END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中参数列表的形式如下：</p>
<p>[IN|OUT|INOUT] param_name type</p>
<p>其中in表示输入参数，out表示输出参数，inout表示既可以输入也可以输出；param_name表示参数名称；type表示参数的类型，该类型可以是MYSQL数据库中的任意类型。</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 创建存储过程
CREATE PROCEDURE my_test()
BEGIN
    SELECT * FROM book;
END;
# 调用存储过程
CALL my_test();
# 删除存储过程
DROP PROCEDURE my_test;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 创建存储过程
CREATE PROCEDURE my_test()
BEGIN
#   declare 定义变量i 
    DECLARE i int DEFAULT 0;
    WHILE i&lt;10 do
        INSERT INTO book (bookname) VALUES (concat('悲惨的世界',i));
        SET i=i+1;
    end WHILE ;
END;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><p>datagrip快捷键</p>
<ul>
<li>代码格式化：ctrl+alt+L（Windows）/  cmd+opt+L（Mac）</li>
<li>快速执行：comman + enter（Mac）</li>
<li>查看表关系：右键一张表——点击最下面diagrams——点击show Visulization即可</li>
</ul>
<p>推荐书籍</p>
<ul>
<li>高性能MySQL</li>
<li>MySQL技术内幕INNODB引擎</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>数据结构基础——C语言实现</title>
    <url>/posts/73f4.html</url>
    <content><![CDATA[<p>程序 = 算法 + 数据结构</p>
<p>程序设计 = 算法 + 数据结构 + 编程范式</p>
<p>算法解决的是计算机的计算资源  而数据结构解决的是计算机的存储资源  解决这两个问题才是一个好的程序 这也就是为什么要学习数据结构的原因</p>
<p>⚡数据结构 = 结构定义 + 结构操作 (对于什么是数据 后面会有更深的理解) </p>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>一种功能更为高级的一种数组 它需要开辟一段连续的空间并且空间的每个位置可以存储任意类型</p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/21/BvEkmQTbLlAu1PU.png" style="zoom:67%;"></p>
<p>size表示顺序表的大小        length表示当前元素的个数      data_type表示元素的类型</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

#define COLOR(a, b) "\033[" #b "m" a "\033[0m"

#define GREEN(a) COLOR(a, 32)

typedef struct Vector {
    int *data;//指向的是一段自己开辟的类型的空间的首地址
    int size, length;
} Vec;


Vec *init(int n) {
    Vec *v = (Vec *)malloc(sizeof(Vec));
    v-&gt;data = (int *)malloc(sizeof(int) * n);
    v-&gt;size = n;
    v-&gt;length = 0;
    return v;
}

int expand(Vec *v) {
    int extr_size = v-&gt;size;
    //return v-&gt;data = (int *)realloc(v-&gt;data, sizeof(int) * (v-&gt;size + extr_size));
    int *p;
    while (extr_size) {
        //realloc会自动将原来的空间回收掉
        p = (int *)realloc(v-&gt;data, sizeof(int) * (v-&gt;size + extr_size));
        //如果p不为空地址 则我们开辟成功 直接break退出循坏 否则一直开辟原来的1/2倍
        if (p) break;
        extr_size &gt;&gt;= 1;
    }
    //如果extr_size == 0 则说明真的开不下了 直接返回0值
    if (extr_size == 0) return 0;
    v-&gt;data = p;
    v-&gt;size += extr_size;
    return 1;
}

int insert(Vec *v, int val, int ind) {
    if (v == NULL) return 0;
    if (ind &lt; 0 || ind &gt; v-&gt;length) return 0;
    if (v-&gt;length == v-&gt;size) {
        if (!expand(v)) return 0;
        printf(GREEN("success to expand! the Vector size is %d\n"), v-&gt;size);
    }
    for (int i = v-&gt;length; i &gt; ind; i--) {
        v-&gt;data[i] = v-&gt;data[i - 1];
    }
    v-&gt;data[ind] = val;
    v-&gt;length += 1;
    return 1;
}

int erase(Vec *v, int ind) {
    if (v == NULL) return 0;
    if (ind &lt; 0 || ind &gt;= v-&gt;length) return 0;
    for (int i = ind + 1; i &lt; v-&gt;length; i++) {
        v-&gt;data[i - 1] = v-&gt;data[i];
    }
    v-&gt;length -= 1;
    return 1;
}

//动态开辟空间需要自己手动释放 避免内存泄漏
void clear(Vec *v) {
    if (v == NULL) return;
    free(v-&gt;data);
    free(v);
    return ;
}

void output(Vec *v) {
    if (v == NULL) return;
    printf("Vector : [");
    for (int i = 0; i &lt; v-&gt;length; i++) {
        i &amp;&amp; printf(", ");
        printf("%d", v-&gt;data[i]);
    }
    printf("]\n");
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    Vec *v = init(2);
    for (int i = 0; i &lt; max_op; i++) {
        int val = rand() % 100;
        int ind = rand() % (v-&gt;length + 3) - 1;
        int op = rand() % 4;
        switch (op) {
            case 1:
            case 2:
            case 0: {
                printf("insert %d at %d to Vector = %d\n", val, ind, insert(v, val, ind));
            } break;
            case 3: {
                printf("erase a iterm at %d from Vector = %d\n", ind, erase(v, ind));
            } break;
        }
        output(v);
        printf("\n");
    }
    clear(v);

    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>malloc动态内存申请 malloc只是划分一个空间告诉你这个空间是可以用的 </p>
<ul>
<li>成功时，返回指向新分配内存开头的指针。</li>
<li>为了避免内存泄漏，必须使用free（） 或 realloc（）释放返回的指针。 </li>
<li>失败时，返回一个空指针。</li>
</ul>
</li>
<li><p>而calloc在开辟空间的时候会将这段空间清0或者是空地址</p>
</li>
<li><p>realloc(地址,大小)指的是重新给你分配一段空间</p>
<ul>
<li><p>第一个参数传进去一个地址 是我们要对哪片空间进行重新划分 而这片空间的首地址就是我们的第一个参数  </p>
</li>
<li><p>第二个参数是 将现在的这片空间扩大多大的字节数  返回值是新开辟出来的空间的首地址</p>
</li>
<li>可以在原来的基础上开辟额外的空间 如果还是存不下则会返回NULL值 此时必须格外注意， 不能让原数据域指向它</li>
<li>如果开辟了额外空间还是存不下 则会重新分配一段和原空间一样大的空间并且扩大两倍 不过我们在这里让它扩大原来的1/2倍  </li>
</ul>
</li>
<li></li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/20/SxkqLQKFN7lEhea.png" style="zoom: 67%;"></p>
<ul>
<li><p>链表可以分为两部分 </p>
<ul>
<li><p><strong>程序内部</strong> 这里指的就是头指针 我们在程序内部能看到的只有头指针所连接的链表</p>
<ul>
<li>我们可以通过头指针去操作链表</li>
</ul>
</li>
<li><p><strong>内存内部</strong> 这部分是链表的本质 在逻辑上如上图一样</p>
<ul>
<li>最后一个节点的指针域为NULL</li>
<li>单向链表的指针域又名“后继”；双向链表有“前驱”和“后继”</li>
</ul>
</li>
</ul>
</li>
<li><p>对于普通的链表中的指针域 我们称之为后继（当前指针域指向后面节点的地址）</p>
</li>
<li><p>插入</p>
<ul>
<li>①走到待插入位置的<strong>前一个</strong>位置的节点p</li>
<li>②先将新的节点x的指针域指向待插入位置的节点p.next</li>
<li>③将p的指针域指向新的节点x</li>
<li>顺序不能变！否则可能引发内存泄漏（你想用已经用不了，但系统却以为你在用）</li>
</ul>
</li>
</ul>
<p>  删除</p>
<ul>
<li><p>走到待删除节点位置的<strong>前一个</strong>位置</p>
<p>翻转</p>
</li>
<li><p>方法一</p>
<ul>
<li>用一个新链表存，使用头插法</li>
<li>不断在index = 0 的位置插入节点</li>
<li>不足：浪费空间，麻烦</li>
</ul>
</li>
<li>方法二<ul>
<li>原地翻转，用两个变量倒，也是头插法</li>
<li>前提：每次操作不要造成内存泄漏</li>
<li>NULL地址还是在最后面，不会翻转</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

#define COLOR(a, b) "\033[" #b "m" a "\033[0m"
#define GREEN(a) COLOR(a, 32)

//链表的结构定义
typedef struct ListNode {
    int data;
    struct ListNode *next;//struct 结构体类型关键字  虽然我们重命名了ListNode 但是12行还没有生效
} ListNode;

//链表整体的结构定义
typedef struct List {
    //ListNode *head;//头指针 因为插入的原则是 在待插入元素前进行插入 当链表为空时 很不好操作
    ListNode head;//虚拟头节点 为了方便插入和删除第一个元素  
    int length;
} List;

//链表的结构操作

//初始化
ListNode *getNewNode(int);
List *getLinkList();
void clear_node(ListNode *);
void clear(List*);
int insert(List *, int, int);
int erase(List *, int);
void output(List *);
void reverse(List *);

int main() {
    srand(time(0));
    #define max_op 20
    List *l = getLinkList();
    for (int i = 0; i &lt; max_op; i++) {
        int val = rand() % 100;
        int ind = rand() % (l-&gt;length + 3) - 1;
        int op = rand() % 4;
        switch (op) {
            case 0:
            case 1: {
                printf("insert %d at %d to List = %d\n", val, ind, insert(l, ind, val));
            } break;
            case 2: {
                printf("erase a iterm at %d from List = %d\n", ind, erase(l, ind));
            } break;
            case 3: {
                printf(GREEN("reverse the list!\n"));
                reverse(l);
            } break;
        }
        output(l), printf("\n");
    } 
    #undef max_op
    clear(l);
    return 0;
}


ListNode *getNewNode(int val) {
    ListNode *p = (ListNode *)malloc(sizeof(ListNode));
    p-&gt;data = val;
    p-&gt;next = NULL;
    return p;
}

List *getLinkList() {
    List *l = (List *)malloc(sizeof(List));
    l-&gt;head.next = NULL;//因为虚拟头节点是一个没有实际意义的节点 所以虚拟头节点指向的后面的那个节点才是真的头节点
    l-&gt;length = 0;
    return l;
}

int insert(List *l, int ind, int val) {
    if (l == NULL) return 0;
    if (ind &lt; 0 || ind &gt; l-&gt;length) return 0;//下标是0 ~ length-1
    ListNode *p = &amp;(l-&gt;head), *node = getNewNode(val);
    while (ind--) p = p-&gt;next;
    node-&gt;next = p-&gt;next;
    p-&gt;next = node;
    l-&gt;length += 1;
    return 1;
}

int erase(List *l, int ind) {
    if (l == NULL) return 0;
    if (ind &lt; 0 || ind &gt;= l-&gt;length) return 0;
    ListNode *p = &amp;(l-&gt;head), *q;
    while (ind--) p = p-&gt;next;
    q = p-&gt;next;
    p-&gt;next = q-&gt;next;
    free(q);
    l-&gt;length -= 1;
    return 1;
}

//链表原地翻转 先将头节点指向空 用p 和 q去维护整个链表
void reverse(List *l) {
    if (l == NULL) return;
    ListNode *p = l-&gt;head.next, *q;
    l-&gt;head.next = NULL;
    while (p) {
        q = p-&gt;next;
        p-&gt;next = l-&gt;head.next;
        l-&gt;head.next = p;
        p = q;
    }
    return ;
}


void output(List *l) {
    if (l == NULL) return ;
    printf("List(%d) = [", l-&gt;length);
    for (ListNode *p = l-&gt;head.next; p; p = p-&gt;next) {
        printf("%d-&gt;", p-&gt;data);
    }
    printf("NULL]\n");
    return ;
}

void clear_node(ListNode *node) {
    if (node == NULL) return;
    free(node);
    return;
}

void clear(List *l) {
    if (l == NULL) return;
    ListNode *p = l-&gt;head.next, *q;//q中间变量
    while (p) {
        q = p-&gt;next;
        clear_node(p);
        p = q;
    }
    free(l);
    return ;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>⭐初始化数据结构[比如链表、链表结点]时，为什么要动态开辟内存[用malloc等]，而不是定义普通变量？<ul>
<li>首先，排除盲区：用指针才能接受malloc返回的地址，但指针也能指向普通变量</li>
<li>关键：【malloc申请的内存在堆空间，普通变量定义在栈空间(在函数里面定义的)】</li>
<li>栈空间：大小只有8MB；出了函数[作用域]变量就被自动释放了</li>
<li>堆空间：可分配<strong>大内存</strong>；变量<strong>生命周期长</strong>，一般需手动释放</li>
</ul>
</li>
<li>❓虚拟头结点定义为普通变量和指针变量的区别<ul>
<li>个人理解，用指针变量，是为了接收malloc返回的地址</li>
<li>而虚拟头结点，在这只是一个指示作用，不需要大空间，所以用普通变量即可而</li>
</ul>
</li>
</ul>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>队列    先进先出的数据结构（First in First out） 从队尾加入（push）一个元素 从队首弹出（pop）一个元素</p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/20/3EqzIo9YdxFZyJD.png" style="zoom: 50%;"></p>
<p>head记录队首元素的位置 tail记录队尾元素的位置</p>
<ul>
<li>出队： 让head指向下一个元素  长度和容量都不变</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/20/XKRBqOWmpY4AjPk.png" style="zoom: 33%;"></p>
<ul>
<li>入队：让tail指向后一个地址 在此地址中进行加入元素 </li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/20/kXSwFfRxU2ZLaTi.png" style="zoom:33%;"></p>
<ul>
<li><p>假溢出问题：当队列如下图时 弹出了3个元素且加入了4个元素使得队列满了 我们可以发现<code>tail</code>已经走到了末尾 如果此时我们还想插入一个元素10 该怎么办呢？<br>  其实之前我们弹出了3个元素 这3个空间是可以使用的 那么我们是否可以将tail指向被弹出的元素的地址（队列的头部）呢？ </p>
<p>  ​    答案是可以的  当我们这么做时 此时的队列就变成了==循环队列==</p>
<p>  ​    循环队列就是用于解决这种假溢出问题的</p>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/20/iCZMTqLX2KJuUVt.png" style="zoom:33%;"></p>
<p>那么我们如何去判断一个队列是否是满的呢？ 在循环队列中我们还需要加入一个字段<code>count</code>用于记录有效元素个数</p>
<p>==普通队列==</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;time.h&gt;
typedef struct Queue {
    int *data;
    int head, tail, length;//length 容量
} Queue;

Queue *init(int n) {
    Queue *q = (Queue *)malloc(sizeof(Queue));
    q-&gt;data = (int *)malloc(sizeof(int) * n);
    q-&gt;length = n;
    q-&gt;head = q-&gt;tail = 0;//tail有两种实现方式 1.指向最后一个元素的地址 2.指向最后一个元素的下一个地址 这里我们选择第二种
    return q;
}

int front(Queue *q) {
    //if (q == NULL) return 0;
    return q-&gt;data[q-&gt;head];
}

int empty(Queue *q) {
    return q-&gt;head == q-&gt;tail; //tail 指向的是最后一个元素的下一个
}

int push(Queue *q, int val) {
    if (q == NULL) return 0;
    if (q-&gt;tail == q-&gt;length) return 0;
    q-&gt;data[q-&gt;tail++] = val;//将val放入tail指向的位置 然后将tail++操作
    return 1;
}

int pop(Queue *q) {
    if (q == NULL) return 0;
    if (empty(q)) return 0;//判断当前队列是否为空 
    q-&gt;head++;
    return 1;
}

void output(Queue *q) {
    if (q == NULL) return;
    printf("Queue : [");
    for (int i = q-&gt;head, j = 0; i &lt; q-&gt;tail; i++, j++) {
        j &amp;&amp; printf(", "); //打印逗号和空格
        printf("%d", q-&gt;data[i]);
    }
    printf("]\n");
    return ;
}

void clear(Queue *q) {
    if (q == NULL) return ;
    free(q-&gt;data);
    free(q);
    return;
}

int main() {
    srand(time(0));
    #define max_op 20
    Queue *q = init(max_op);
    for (int i = 0; i &lt; max_op; i++) {
        int val = rand() % 100;
        int op = rand() % 4;
        switch (op) {
            case 0:
            case 1:
            case 2: {
                printf("push %d to the Queue! ", val);
                printf("result = %d\n", push(q, val));
            } break;
            case 3: {
                printf("pop %d from the Queue! ", front(q));
                printf("result = %d\n", pop(q));
            } break;
        }
        output(q), printf("\n");
    }
    #undef max_op
    clear(q);
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>循环队列</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;


#define COLOR(a, b) "\033[" #b "m" a "\033[0m"
#define GREEN(a) COLOR(a, 32)

typedef struct Queue {
    int *data;//队列数据域
    int head, tail, length;//length 容量
    int cnt;//循环队列的字段
} Queue;

Queue *init(int n) {
    Queue *q = (Queue *)malloc(sizeof(Queue));
    q-&gt;data = (int *)malloc(sizeof(int) * n);
    q-&gt;length = n;
    q-&gt;head = q-&gt;tail = 0;//tail有两种实现方式 1.指向最后一个元素的地址 2.指向最后一个元素的下一个地址，方便循环队列判空
    q-&gt;cnt = 0;
    return q;
}

int front(Queue *q) {
    //if (q == NULL) return 0;
    return q-&gt;data[q-&gt;head];
}

int empty(Queue *q) {
    // return q-&gt;head == q-&gt;tail; //tail 指向的是最后一个元素的下一个 
    return q-&gt;cnt == 0;//循环队列判空
}


//遇到真溢出
//realloc不适用 尽管它能重新给我们分配一段大的空间 但是进行数据拷贝时是从0地址到尾地址进行拷贝 tail可能在head的前面
int expand(Queue *q) {
    int extr_size = q-&gt;length;
    int *p;
    while (extr_size) {
        p = (int *)malloc(sizeof(int) * (q-&gt;length + extr_size));
        if (p) break;
        extr_size &gt;&gt;= 1;
    }
    if (p == NULL) return 0;
    for (int i = q-&gt;head, j = 0; j &lt; q-&gt;cnt; j++) {
        p[j] = q-&gt;data[(i + j) % q-&gt;length];
    }
    free(q-&gt;data);
    q-&gt;data = p;
    q-&gt;length += extr_size;
    q-&gt;head = 0;
    q-&gt;tail = q-&gt;cnt;
    return 1;
}

int push(Queue *q, int val) {
    if (q == NULL) return 0;
    //if (q-&gt;tail == q-&gt;length) return 0;
    if (q-&gt;cnt == q-&gt;length) {
        if (!expand(q)) return 0; //扩容操作
        printf(GREEN("expand successfully! Queue-&gt;size(%d)\n"), q-&gt;length);
    }
    q-&gt;data[q-&gt;tail++] = val;//将val放入tail指向的位置 然后将tail++操作
    if (q-&gt;tail == q-&gt;length) q-&gt;tail = 0;
    q-&gt;cnt += 1;
    return 1;
}

int pop(Queue *q) {
    if (q == NULL) return 0;
    if (empty(q)) return 0;//判断当前队列是否为空 
    q-&gt;head++;
    if (q-&gt;head == q-&gt;length) q-&gt;head = 0;//head也可能越界
    q-&gt;cnt -= 1;
    return 1;
}

void output(Queue *q) {
    if (q == NULL) return;
    printf("Queue : [");
    for (int i = q-&gt;head, j = 0; j &lt; q-&gt;cnt; i++, j++) {
        j &amp;&amp; printf(", "); //打印逗号和空格
        printf("%d", q-&gt;data[i % q-&gt;length]); //取模得到真实的位置
    }
    printf("]\n");
    return ;
}

void clear(Queue *q) {
    if (q == NULL) return ;
    free(q-&gt;data);
    free(q);
    return;
}

int main() {
    srand(time(0));
    #define max_op 20
    Queue *q = init(2);
    for (int i = 0; i &lt; max_op; i++) {
        int val = rand() % 100;
        int op = rand() % 4;
        switch (op) {
            case 0:
            case 1:
            case 2: {
                printf("push %d to the Queue! ", val);
                printf("result = %d\n", push(q, val));
            } break;
            case 3: {
                printf("pop %d from the Queue! ", front(q));
                printf("result = %d\n", pop(q));
            } break;
        }
        output(q), printf("\n");
    }
    #undef max_op
    clear(q);
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>==栈==</p>
<ul>
<li>一种先进后出的数据结构 （FILO） <ul>
<li>如果是一个空栈 top = -1 因为顺序结构下标从0~n-1进行访问</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/20/ZLvfEimw6OVbrn7.png" style="zoom: 33%;"></p>
<ul>
<li><p>出栈</p>
<ul>
<li><p>将栈顶指针向下移动一位</p>
</li>
<li><p>出栈要进行判空操作</p>
<p>  <img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/20/UM3SzBDqkFVtQH7.png" style="zoom:33%;"></p>
</li>
</ul>
</li>
<li><p>入栈</p>
<ul>
<li>将栈顶指针向上移动</li>
<li>要进行判断边界操作</li>
</ul>
</li>
</ul>
<h3 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h3><p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/20/6BQE7XzOlnkr1gI.png" style="zoom: 33%;"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
struct Stack {
    char *val;
    int p, maxSize;
};

void initStack(struct Stack *s, int maxSize) {
    s-&gt;val = malloc(maxSize);
    s-&gt;p = 0;
}

bool emptyStack(struct Stack *s) {
    return !(s-&gt;p);
}

void pushStack(struct Stack *s, char c) {
    s-&gt;val[s-&gt;p++] = c;
}

void popStack(struct Stack *s) {
    --(s-&gt;p);
}

char seekStack(struct Stack *s) {
    return s-&gt;val[s-&gt;p - 1];
}

bool isValid(char * s){
    struct Stack stack;
    int len = strlen(s);
    initStack(&amp;stack, len);
    for (int i = 0; i &lt; len; i++) {
        switch (s[i]) {
            case '(':
            case '[':
            case '{':
                pushStack(&amp;stack, s[i]);
                break;
            case ')':
                if (emptyStack(&amp;stack)) return false;
                if (seekStack(&amp;stack) != '(') return false;
                popStack(&amp;stack);
                break;
            case ']':
                if (emptyStack(&amp;stack)) return false;
                if (seekStack(&amp;stack) != ']') return false;
                popStack(&amp;stack);
                break;
            case '}':
                if (emptyStack(&amp;stack)) return false;
                if (seekStack(&amp;stack) != '}') return false;
                popStack(&amp;stack);
                break;
        }
    }
    return emptyStack(&amp;stack);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>栈的代码</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

#define COLOR(a, b) "\033[" #b "m" a "\033[0m"
#define GREEN(a) COLOR(a, 32)

typedef struct Stack {
    int *data;
    int size, top;//size容量 top栈顶指针
} Stack;

Stack *init(int n) {
    Stack *s = (Stack *)malloc(sizeof(Stack));
    s-&gt;data = (int *)malloc(sizeof(int) * n);
    s-&gt;size = n;
    s-&gt;top = -1;
    return s;
}

int top(Stack *s) {
    return s-&gt;data[s-&gt;top];
}

int empty(Stack *s) {
    return s-&gt;top == -1;
}

int expand(Stack *s) {
    int extr_size = s-&gt;size;
    int *p;
    while (extr_size) {
        p = (int *)realloc(s-&gt;data, sizeof(int) * (s-&gt;size + extr_size));
        if (p) break;
        extr_size &gt;&gt;= 1;
    }
    if (p == NULL) return 0;
    s-&gt;data = p;
    s-&gt;size += extr_size;
    return 1;
}

int push(Stack *s, int val) {
    if (s == NULL) return 0;
    if (s-&gt;top == s-&gt;size - 1) {
        if (!expand(s)) return 0;
        printf(GREEN("expand successfully! stack-&gt;size = (%d)\n"), s-&gt;size);
    }
    s-&gt;data[++(s-&gt;top)] = val;
    return 1;
}

int pop(Stack *s) {
    if (s == NULL) return 0;
    if (empty(s)) return 0;
    s-&gt;top -= 1;
    return 1;
}

void output(Stack *s) {
    if (s == NULL) return ;
    printf("[");
    for (int i = 0; i &lt;= s-&gt;top; i++) {
        i &amp;&amp; printf(", ");
        printf("%d", s-&gt;data[i]);
    }
    printf("]\n");
    return ;
}

void clear(Stack *s) {
    if (s == NULL ) return;
    free(s-&gt;data);
    free(s);
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    Stack *s = init(4);
    int flag;
    for (int i = 0; i &lt; max_op; i++) {
        int val = rand() % 100;
        int op = rand() % 4;
        switch (op) {
            case 0:
            case 1:
            case 2: {
                printf("push %d to the Stack = %d\n", val, push(s, val));
            } break;
            case 3: {
                flag = !empty(s);
                flag &amp;&amp; printf("pop %d frome the Stack", top(s));
                printf("result = %d\n", pop(s));
            } break;
        }
        output(s), printf("\n");
    }
    #undef max_op
    clear(s);
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><p>树的组成：结点 + 边</p>
<ul>
<li>结点 👉 集合，边 👉 关系</li>
<li>根结点：全集；子结点：子集<ul>
<li>根结点的所有子结点的集合并集 = 全集</li>
<li>【思想】大问题抽象为树，小问题抽象为子结点</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/20/AwHZhstcYrVjqCl.png" style="zoom:33%;"></p>
<ul>
<li>深度、高度<ul>
<li>树的深度和高度是一个值：最大层数</li>
<li>结点的深度和高度不一样<ul>
<li>深度：从根结点往下数，该结点是第几层</li>
<li>高度：从最深的层数往上数，该结点是第几层</li>
</ul>
</li>
</ul>
</li>
<li>度：有几个子孩子<ul>
<li>节点的度：一个节点含有的子树的个数称为该节点的度；</li>
<li>叶节点或终端节点：度为0的节点称为叶节点；</li>
<li>非终端节点或分支节点：度不为0的节点  ；</li>
<li>双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>
<li>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li>兄弟节点：具有相同父节点的节点互称为兄弟节点；</li>
<li>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>
<li>树的高度或深度：树中节点的最大层次；</li>
<li>堂兄弟节点：双亲在同一层的节点互为堂兄弟；</li>
<li>节点的祖先：从根到该节点所经分支上的所有节点；</li>
<li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。</li>
<li>森林：由m（m&gt;=0）棵互不相交的树的集合称为森林。</li>
</ul>
</li>
<li>⭐【重要公式】结点数 = 边数 + 1</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/20/qg7FrRpnvO8Gc42.png" style="zoom:33%;"></p>
<ul>
<li>二叉树<ul>
<li>任何树都可以变成一颗二叉树</li>
</ul>
</li>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/20/5ZjCn74VBRxJUtN.png" style="zoom:33%;"></li>
</ul>
<ul>
<li>这是一颗三叉树  可以把它变成二叉树二进制可以转换成任何进制，二叉树同理<ul>
<li>首先简单</li>
<li>且可以表示所有的树形结构<ul>
<li>方法：左孩子、右兄弟法，又称十字链表法</li>
<li>从上往下，从左往右，结点的孩子放在左边，结点的相邻兄弟放在右边</li>
</ul>
</li>
</ul>
</li>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/20/FUlzSDVTWxOC8Z3.png" style="zoom:33%;"></li>
</ul>
<p>⭐【重要公式】二叉树中，度为0的结点比度为2的结点多1个</p>
<ul>
<li>利用另一重要公式：结点数 = 边数 + 1</li>
<li>令ni表示度为i的结点个数</li>
<li>则：[结点数] n0 + n1 + n2 = n1 + 2 * n2 + 1 [边数 + 1]</li>
<li>得：n0 = n2 + 1</li>
</ul>
<ul>
<li>完全二叉树：只差最后一个右孩子</li>
<li>满二叉树： 只有度为0 和度为2 的节点</li>
<li>完美二叉树： 不多不少很完美</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/20/8mJlVoA5ErQ394W.png" style="zoom: 33%;"></p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/20/iDOCLrVKkWxp96e.png" style="zoom:33%;"></p>
<ul>
<li>对于一颗二叉树<ul>
<li>若根节点表示i<ul>
<li>左孩子为 2*i</li>
<li>右孩子为 2*i + 1 </li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>==binary_tree==</strong></p>
<ul>
<li>实现的是二叉查找树（二叉排序树）</li>
<li><strong>维护的性质</strong>: 对于一个三元组来说👇   <ul>
<li>左孩子小于根节点  </li>
<li>右孩子大于根节点</li>
<li>对于中序遍历而言 ： 可以实现从小到大排序</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
//节点
typedef struct Node {
    int data;
    struct Node *lchild, *rchild;//二叉 指针域 左孩子 右孩子
} Node;

typedef struct tree {
    Node *root;//指向根节点的指针变量
    int n;//节点个数
} Tree;

Node *getNewNode(int val) {
    Node *p = (Node *)malloc(sizeof(Node));
    p-&gt;data = val;
    p-&gt;lchild = p-&gt;rchild = NULL;
    return p;
}

Tree *getNewTree() {
    Tree *tree = (Tree *)malloc(sizeof(Tree));
    tree-&gt;root = NULL;
    tree-&gt;n = 0;
    return tree;
}

void clearNode(Node *node) {
    if (node == NULL) return ;
    clearNode(node-&gt;lchild);//沿着当前节点的左子树进行递归回收
    clearNode(node-&gt;rchild);
    free(node);//回收当前节点
    return ;
}

void clear(Tree *tree) {
    if (tree == NULL) return ;
    clearNode(tree-&gt;root);
    free(tree);
    return ;
}

Node *insert_node(Node *root, int val, int *flag) {
    if (root == NULL){
        *flag = 1;//root为空表示插入成功 
        return getNewNode(val);//若root节点为空 则将val封装成根节点
    }
    if (root-&gt;data == val) return root;//如果根节点的值等于val 则返回root
    
    //如果当前的val值小于当前根节点所指向的值
    //那么我们需要将val值递归插入到根节点的左子树中 
    if (val &lt; root-&gt;data) root-&gt;lchild = insert_node(root-&gt;lchild, val, flag);
    else root-&gt;rchild = insert_node(root-&gt;rchild, val, flag);
    return root;
}

//二叉查找树 左孩子小于根节点 右孩子大于根节点
void insert(Tree *tree, int val) {
    int flag = 0;//传出参数
    tree-&gt;root = insert_node(tree-&gt;root, val, &amp;flag);
    //若插入成功 则此时flag = 1 且将节点个数加1
    tree-&gt;n += flag;
    return ;
}

void pre_order_node(Node *node) {
    if (node == NULL) return ;
    printf("%d ", node-&gt;data);
    pre_order_node(node-&gt;lchild);
    pre_order_node(node-&gt;rchild);
    return ;
}

//前序遍历
void pre_order(Tree *tree) {
    if (tree == NULL) return ;
    printf("pre_order :");
    pre_order_node(tree-&gt;root);
    printf("\n");
    return;
}

void in_order_node(Node *node) {
    if (node == NULL) return ;
    in_order_node(node-&gt;lchild);
    printf("%d ", node-&gt;data);
    in_order_node(node-&gt;rchild);
    return ;
}

//中序遍历
void in_order(Tree *tree) {
    if (tree == NULL) return ;
    printf("in_order :");
    in_order_node(tree-&gt;root);
    printf("\n");
    return;
}

void post_order_node(Node *node) {
    if (node == NULL) return ;
    post_order_node(node-&gt;lchild);
    post_order_node(node-&gt;rchild);
    printf("%d ", node-&gt;data);
    return ;
}

//后序遍历
void post_order(Tree *tree) {
    if (tree == NULL) return ;
    printf("post_order :");
    post_order_node(tree-&gt;root);
    printf("\n");
    return;
}


//打印广义表
void output_node(Node *root) {
    if (root == NULL) return ;
    printf("%d", root-&gt;data);
    if (root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) return;
    //打印左子树时先输出`(`
    printf("(");
    output_node(root-&gt;lchild);
    printf(", ");
    //打印右子树后输出`)`
    output_node(root-&gt;rchild);
    printf(")");
    return ;
}

void output(Tree *tree) {
    if (tree == NULL) return ;
    printf("tree(%d) : ", tree-&gt;n);
    output_node(tree-&gt;root);
    printf("\n");
    return ;
}

int main() {
    srand(time(0));
    Tree *tree =getNewTree();
    #define max_op 10
    for (int i = 0; i &lt; max_op; i++) {
        int val = rand() % 100;
        insert(tree, val);
        output(tree);
    }
    pre_order(tree);
    in_order(tree);
    post_order(tree);
    #undef max_op
    clear(tree);
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>😎三种遍历方式中 任选两种（其中必须包含中序遍历）可以还原一颗二叉树 </li>
</ul>
<p>广义表转二叉树</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
typedef struct Node {
    char data;
    struct Node *lchild, *rchild;
} Node;

typedef struct Tree {
    Node *root;
    int n;
} Tree;

typedef struct Stack {
    Node **data;
    int top, size;
} Stack;

Node *getNewNode(char val) {
    Node *p = (Node *)malloc(sizeof(Node));
    p-&gt;data = val;
    p-&gt;lchild = p-&gt;rchild = NULL;
    return p;
}

Tree *getNewTree() {
    Tree *tree = (Tree *)malloc(sizeof(Tree));
    tree-&gt;root = NULL;
    tree-&gt;n = 0;
    return tree;
    
}

Stack *init_stack(int n) {
    Stack *s = (Stack *)malloc(sizeof(Stack));
    s-&gt;data = (Node **)malloc(sizeof(Node *) * n);
    s-&gt;top = -1;
    s-&gt;size = n;
    return s;
}

Node *top(Stack *s) {
    return s-&gt;data[s-&gt;top];
}

int empty(Stack *s) {
    return s-&gt;top == -1;
}

int push(Stack *s, Node *val) {
    if (s == NULL) return 0;
    if (s-&gt;top == s-&gt;size - 1) return 0;
    s-&gt;data[++(s-&gt;top)] = val;
    return 1;
}

int pop(Stack *s) {
    if (s == NULL) return 0;
    if (empty(s)) return 0;
    s-&gt;top -= 1;
    return 1;
}

void clear_stack(Stack *s) {
    if (s == NULL) return;
    free(s-&gt;data);
    free(s);
    return ;
}

void clear_node(Node *node) {
    if (node == NULL) return ;
    clear_node(node-&gt;lchild);
    clear_node(node-&gt;rchild);
    free(node);
    return ;
}

void clear_tree(Tree *tree) {
    if (tree == NULL) return ;
    clear_node(tree-&gt;root);
    free(tree);
    return ;
}

Node *build(const char *str, int *node_num) {
    Stack *s = init_stack(strlen(str));
    int flag = 0;
    Node *temp = NULL, *p = NULL;
    while (str[0]) {
        switch (str[0]) {
            case '(': {
                push(s, temp);
                flag = 0;
            } break;
            case ')': {
                p = top(s);
                pop(s);
            } break;
            case ',': {
                flag = 1;
            } break;
            case ' ': break;
            default:
                temp = getNewNode(str[0]);
                if (!empty(s) &amp;&amp; flag == 0) {
                    top(s)-&gt;lchild = temp;
                } else if (!empty(s) &amp;&amp; flag == 1) {
                    top(s)-&gt;rchild = temp;
                }
                ++(*node_num);
                break;
        }
        ++str;
    }
    clear_stack(s);
    if (temp &amp;&amp; !p) p = temp;
    return p;
}

void pre_order_node(Node *root) {
    if (root == NULL) return ;
    printf("%c ", root-&gt;data);
    pre_order_node(root-&gt;lchild);
    pre_order_node(root-&gt;rchild);
    return ;
}

void pre_order(Tree *tree) {
    if (tree == NULL) return ;
    printf("pre_order : ");
    pre_order_node(tree-&gt;root);
    printf("\n");
    return ;
}

void in_order_node(Node *root) {
    if (root == NULL) return ;
    in_order_node(root-&gt;lchild);
    printf("%c ", root-&gt;data);
    in_order_node(root-&gt;rchild);
    return ;
}

void in_order(Tree *tree) {
    if (tree == NULL) return ;
    printf("in_order : ");
    in_order_node(tree-&gt;root);
    printf("\n");
    return ;
}

void post_order_node(Node *root) {
    if (root == NULL) return ;
    post_order_node(root-&gt;lchild);
    post_order_node(root-&gt;rchild);
    printf("%c ", root-&gt;data);
    return ;
}

void post_order(Tree *tree) {
    if (tree == NULL) return ;
    printf("post_order : ");
    post_order_node(tree-&gt;root);
    printf("\n");
    return ;
}



int main() {
    char str[1000] = {0};
    int node_num = 0;
    scanf("%[^\n]s", str);
    Tree *tree = getNewTree();
    tree-&gt;root = build(str, &amp;node_num);
    tree-&gt;n = node_num;
    pre_order(tree);
    in_order(tree);
    post_order(tree);
    clear_tree(tree);
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="排序与查找"><a href="#排序与查找" class="headerlink" title="排序与查找"></a>排序与查找</h2><h3 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h3><p>==稳定排序==</p>
<p><strong><em>对于相同的元素 经过排序操作后 他们的相对位置保持不变 这样的排序我们称为稳定排序</em></strong></p>
<ul>
<li><p>插入排序</p>
<ul>
<li>时间复杂度O(n^2)  至少要n-1轮操作</li>
</ul>
</li>
<li><p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/23/5wKdYO3y1HSV7hx.png" style="zoom: 67%;"></p>
</li>
<li><p>冒泡排序</p>
<p>  <img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/23/rwxdzJe9CVO1X3T.png" style="zoom: 67%;"></p>
</li>
<li><p>归并排序</p>
<ul>
<li>时间复杂度O(nlog·N)  分治思想 不是基于比较跟交换的排序方式</li>
<li><p>==★==这是一个外部排序（很重要）</p>
</li>
<li><p><a href="https://www.wikiwand.com/zh-hans/%E5%A4%96%E6%8E%92%E5%BA%8F#/%E5%A4%96%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">外部排序</a>:   我们可以将数据分为多段加载到内存中</p>
<ul>
<li><p>内部排序：需要将数据整个加载到内存中进行排序</p>
</li>
<li><p>比如我们有40G的数据要进行排序 怎么办？ 我们可以使用归并排序 把40G的数据分成20G 再不行就分成10G </p>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/23/v4FDiWRKdS6Ualx.png" style="zoom: 50%;"></p>
</li>
</ul>
</li>
</ul>
<pre><code><pre class="line-numbers language-c" data-language="c"><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

#define swap(a, b) {\
    a ^= b; b ^= a; a ^= b;\
}

#define TEST(arr, n, func, args...) {\
    int *num = (int *)malloc(sizeof(int) * n);\
    memcpy(num, arr, sizeof(int) * n);\
    output(num, n);\
    printf("%s= ", #func);\
    func(args);\
    output(num, n);\
    free(num);\
}

//插入排序
void insert_sort(int *num, int n) {
    for (int i = 1; i &lt; n; i++) {
        for (int j = i ; j &gt; 0 &amp;&amp; num[j] &lt; num[j - 1]; j--) {
            swap(num[j], num[j - 1]);
        }
    }
    return ;
}

//冒泡 我们在这里设置一个记录交换次数的值 若是一个从小到大的有序数组 times交换次数必定为0 且时间复杂度为O(n) 
void bubble_sort(int *num, int n) {
    int times = 1; // 进行交换的次数
    for (int i = 1; i &lt; n &amp;&amp; times; i++) {//times == 0 结束循环
        times = 0;
        for (int j = 0; j &lt; n - i; j++) {
            if (num[j] &lt;= num[j + 1]) continue; //减少缩进
            swap(num[j], num[j + 1]);
            times++;            
        }
    }
    return ;
}

//归并排序 分治思想 用递归 
void merge_sort(int *num, int l, int r) {
    //边界条件 只剩两个元素
    if (r - l &lt;= 1) {
        if (r - l == 1 &amp;&amp; num[r] &lt; num[l]) {
            swap(num[r], num[l]);
        }
        return;
    } 
    int mid = (l + r) &gt;&gt; 1;
    merge_sort(num, l, mid);//从l 到 mid 进行排序
    merge_sort(num, mid + 1, r);//从 mid + 1 到 r 进行排序
    //合并
    int *temp = (int *)malloc(sizeof(int) * (r - l + 1));
    //p1 指向的是
    int p1 = l, p2 = mid + 1, k = 0;
    while (p1 &lt;= mid || p2 &lt;= r) {
        if (p2 &gt; r || (p1 &lt;= mid &amp;&amp; num[p1] &lt;= num[p2])) {
            temp[k++] = num[p1++];
        } else {
            temp[k++] = num[p2++];
        }
    }
    //将temp拷贝回num里
    memcpy(num + l, temp, sizeof(int) * (r -l + 1));
    free(temp);
    return ;
}

void randint(int *num, int n) {
    while (n--) num[n] = rand() % 100;
    return ;
}

void output(int *num, int n) {
    printf("[");
    for (int i = 0; i &lt; n; i++) {
        printf("%d ", num[i]);
    }
    printf("]\n");
}

int main() {
    srand(time(0));
    #define max_n 20
    int arr[max_n];
    randint(arr, max_n);
    TEST(arr, max_n, insert_sort, num, max_n);
    TEST(arr, max_n, bubble_sort, num, max_n);
    TEST(arr, max_n, merge_sort, num, 0, max_n - 1);
    #undef max_n
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre><h3 id="不稳定排序"><a href="#不稳定排序" class="headerlink" title="不稳定排序"></a>不稳定排序</h3><ul>
<li><p>选择排序</p>
<ul>
<li><p>时间复杂度：O(n^2) </p>
</li>
<li><p>不稳定排序 比如 5 3 2 5 1 经过排序后 第一个5的位置变到了最后一个 两个5的相对位置发生了改变</p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/24/XQqkKLCAZt37cnO.png" style="zoom: 67%;"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li>快速排序<ul>
<li>时间复杂度：O(nlog·N)     选一个基数  让左半边小于这个基数 右半边大于这个基数<ul>
<li>①选择头部元素作为基数</li>
<li>②有头尾两个指针  尾指针找第一个小于基数的值然后放入头部中  头指针找第一个大于基数的值放入刚刚移走的值的位置</li>
<li>③最后指针重叠 放入基数</li>
</ul>
</li>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/24/VL7Kw68MOvGptnb.png" alt=""></li>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/24/OiI1czLE4nohYTd.png" alt=""></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;

//^= 两个值不能异或自己
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

#define TEST(arr, n, func, args...) {\
    int *num = (int *)malloc(sizeof(int) * n);\
    memcpy(num, arr, sizeof(int) * n);\
    output(num, n);\
    printf("%s = ", #func);\
    func(args);\
    output(num, n);\
    free(num);\
}

void select_sort(int *num, int n) {
    for (int i = 0; i &lt; n - 1; i++) {
        int ind = i;
        for (int j = i + 1; j &lt; n; j++) {
            if (num[ind] &gt; num[j]) ind = j;
        }
        swap(num[i], num[ind]);
    }
    return ;
}

void quick_sort(int *num, int l, int r) {
    if (l &gt; r) return ;
    int x = l, y = r, z = num[x];
    while (x &lt; y) {
        while (x &lt; y &amp;&amp; num[y] &gt; z) y--;
        if (x &lt; y) num[x++] = num[y];
        while (x &lt; y &amp;&amp; num[x] &lt; z) x++;
        if (x &lt; y) num[y--] = num[x];
    }
    num[x] = z;
    quick_sort(num, l, x - 1);
    quick_sort(num, x + 1, r);
    return ;
}

void randint(int *num, int n) {
    while (n--) num[n] = rand() % 100;
    return ;
}

void output(int *num, int n) {
    printf("[");
    for (int i = 0; i &lt; n; i++) {
        printf("%d ", num[i]);
    }
    printf("]\n");
    return ;
}

int main() {
    srand(time(0));
    #define max_n 20
    int arr[max_n];
    randint(arr, max_n);
    TEST(arr, max_n, select_sort, num, max_n);
    TEST(arr, max_n, quick_sort, num, 0, max_n - 1);
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>快速排序优化</p>
<p>  <img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/24/sa2YOr7Hmw1txeV.png" alt=""></p>
</li>
</ul>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul>
<li><p><strong>二分查找</strong></p>
<ul>
<li><p>虚拟头尾指针 一堆0的情况<img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/24/EuSNpFWqjLMUI9b.png" style="zoom: 67%;"></p>
</li>
<li><p>特殊情况①    1111111100000000</p>
<ul>
<li><p>1 表示满足某种性质    0  表示不满足某种性质</p>
</li>
<li><p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/24/LeC3JicxfpGzoOH.png" alt=""></p>
</li>
<li>如果我们的数据全是0   0000000000000  最后mid指向第一个0 我们说不清到底是找到了答案还是没找到 所以我们引入了虚拟头指针 去判断它是否等于-1</li>
<li><img src="/img/loading.gif" data-original="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1606189109262.png" alt="1606189109262"></li>
</ul>
</li>
<li><p>特殊情况②   00000000011111111111</p>
<p>  <img src="/img/loading.gif" data-original="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1606189376625.png" alt="1606189376625"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>三分查找</strong><br>  <img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/24/C2aWlMRGDsZpJ9O.png" style="zoom:50%;"></li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
#include &lt;stdio.h&gt;

#define P(func) {\
    printf("%s = %d\n", #func, func);\
}

int binary_search1(int *num, int n, int x) {
    int head = 0, tail = n - 1, mid;
    while (head &lt;= tail) {
        mid = (head + tail) &gt;&gt; 1;
        if (num[mid] == x) return mid;
        if (num[mid] &lt; x) head = mid + 1;
        else tail = mid - 1;
    }
    return -1;
}

//111111000000
//head 虚拟头指针
int binary_search2(int *num, int n) {
    int head = -1, tail = n - 1, mid;
    while (head &lt; tail) {
        mid = (head + tail + 1) &gt;&gt; 1;
        if (num[mid] == 1) head = mid;
        else tail = mid - 1;
    }
    return head;
}

//00000011111111
//tail 虚拟尾指针
int binary_search3(int *num, int n) {
    int head = 0, tail = n, mid;
    while (head &lt; tail) {
        mid = (head + tail) &gt;&gt; 1;
        if (num[mid] == 1) tail = mid;
        else head = mid + 1;
    }
    return head == n ? -1 : head;
}

int main() {
    int arr1[10] = {1, 3, 5, 7, 9, 11, 13, 17, 19, 21};
    int arr2[10] = {1, 1, 1, 1, 0, 0, 0, 0, 0, 0};
    int arr3[10] = {0, 0, 0, 0, 0, 0, 1, 1, 1, 1};
    P(binary_search1(arr1, 10, 7));
    P(binary_search2(arr2, 10));
    P(binary_search3(arr3, 10));
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><ul>
<li>时间复杂度：趋近与O(1)</li>
<li>是一种用来查找的数据结构（下标与值的访问）</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/25/ndoXIQCP7jWybAG.png" style="zoom: 33%;"></p>
<ul>
<li><p>可以将任意一种类型映射成数组下标的形式进行访问 </p>
<ul>
<li>冲突处理方法（无法避免，但是可以减少发生的概率） </li>
<li><strong><em>放入元素</em></strong> ：当前我要插入16这个值  用16取模与当前的容量 放入到下标为【7】的位置中</li>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/25/hS4Otfx91HkzP2Y.png" style="zoom:33%;"></li>
<li><strong><em>发生冲突</em></strong>： 我要插入7这个值  7%9 = 7  此时我要把7放入到下标为【7】的位置中 但是【7】的位置中已存在值  这时冲突便发生了</li>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/25/Fueh2iabNVHj9TK.png" style="zoom:33%;"></li>
</ul>
</li>
<li><p>这是就引出了哈希表很重要的结构： <strong><em>冲突处理方法</em></strong></p>
<ul>
<li>①<strong><em>开放定址</em></strong>： 当前7的位置有值 那我就去寻找后面的位置 是否有值 如果没有值就将7放入8的位置<ul>
<li>容易产生数据堆聚问题 ：数据会集中存储在空间中的某一块区域 </li>
</ul>
</li>
<li>②<strong><em>再哈希法</em></strong>：在我的哈希表中 我设置了不止一种哈希函数 一种不行 我再用下一种</li>
<li>③<strong><em>拉链法</em></strong>：在当前位置我不存储一个元素，我们去存储一个链表，将这个值封装一个节点存在链表的后面</li>
<li>④<strong><em>建立公共溢出区</em></strong>：这个区域专门用来存储冲突元素的——用一种额外的数据结构维护（红黑树）</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;


typedef struct Node {
    char *str;
    struct Node *next;
} Node;

typedef struct HashTable {
    Node **data;//哈希表(也是顺序表)里面存储的是一个地址 地址所指向的类型是Node*类型 拉链法
    int size;
} HashTable;

Node *init_node(char *str, Node *head) {
    Node *p = (Node *)malloc(sizeof(Node));
    p-&gt;str = strdup(str);
    p-&gt;next = head; //头插法
    return p;
}

HashTable *init_hashtable(int n) {
    HashTable *h = (HashTable *)malloc(sizeof(HashTable));
    //利用率和哈希函数冲突概率有关 我们把n扩大一倍 使其只有50%利用率
    h-&gt;size = n &lt;&lt; 1;//哈希表的空间利用率不可能达到100% 一般的空间利用率为50%——90% 工业上达到70%才可以使用
    h-&gt;data = (Node **)calloc(h-&gt;size,sizeof(Node *));//数据的每一位都为0值 都是空地址
    return h;
}

//哈希函数
int BKDRHash(char *str) {
    //seed是一个素数就行
    int seed = 31, hash = 0;
    for (int i = 0; str[i]; i++) hash = hash * seed + str[i];
    //hash有可能超出整型范围 变成一个负数 
    //这里的0x7fffffff 表示的是符号位为0 其余位为1的数 
    return hash &amp; 0x7fffffff;    
}

int insert(HashTable *h, char *str) {
    int hash = BKDRHash(str);
    int ind = hash % h-&gt;size;
    //将字符串插入到下标为ind的这个位置所对应的链表中
    h-&gt;data[ind] = init_node(str, h-&gt;data[ind]);
    return 1;
}

int search(HashTable *h, char *str) {
    int hash = BKDRHash(str);
    int ind = hash % h-&gt;size;
    //p指向ind这位链表里存的头节点
    Node *p = h-&gt;data[ind];
    //沿着链表的头节点 遍历链表的每一位 strcmp返回值不为0时代表没找到
    while (p &amp;&amp; strcmp(p-&gt;str, str)) p = p-&gt;next;
    //如果p 不等于NULL 说明是因为strcmp返回值为0退出的循环  也就是说找到了值
    return p != NULL;
}

void clear_node(Node *node) {
    if (node == NULL) return ;
    Node *p = node, *q;
    while (p) {
        q = p-&gt;next;
        free(p-&gt;str);
        free(p);
        p = q;
    }
    return ;
}

void clear_hashtable(HashTable *h) {
    if (h == NULL) return ;
    for (int i = 0; i &lt; h-&gt;size; i++) {
        clear_node(h-&gt;data[i]);
    }
    free(h-&gt;data);
    free(h);
    return ;
}

int main() {
    int op;
    #define max_n 100
    char str[max_n + 5] = {0};
    HashTable *h = init_hashtable(max_n + 5);
    while (~scanf("%d%s", &amp;op, str)) {
        switch (op) {
            case 0:
                printf("insert %s to HashTable\n", str);
                insert(h, str);
            break;
            case 1:
            printf("search %s from HashTable result = %d\n", str, search(h, str));
            break;
        }
    }
    #undef max_n
    clear_hashtable(h);
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/11/27/LyTdRX2YDeafEzG.png" alt=""></p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/04/9ZMPRS3cLxaWEzg.png" alt=""></p>
<h2 id="堆与优先队列"><a href="#堆与优先队列" class="headerlink" title="堆与优先队列"></a>堆与优先队列</h2><p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/ZwJXE47fyLK1Io6.png" alt="图片" style="zoom: 33%;"></p>
<ul>
<li>完全二叉树默认从1开始编号<ul>
<li>这样可以保证左孩子、右孩子编号简洁</li>
<li>[否则] 左孩子编号需为2 <em> i + 1，右孩子编号需为2 </em> i + 2</li>
</ul>
</li>
</ul>
<p>==数据结构： 你定义了一种性质，并且能维护这一种性质，那么这种结构就是一个新的数据结构==</p>
<ul>
<li>优先队列是堆的一个别名</li>
<li>堆在思维逻辑上就是一颗完全二叉树</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/01/i5F9A1S7zVvZWEN.png" alt=""></p>
<ul>
<li><strong>尾部插入元素</strong>(O(logn))   <ul>
<li>一开始以7为根节点 13为左孩子  右孩子为空 这个三元组进行调整 </li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/01/OeKuCUMVABwcJ7R.png" style="zoom:25%;"></p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/01/c2NArZGuEwPIJSK.png" style="zoom:25%;"></p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/01/h6m3Xrqi1oPJLlW.png" style="zoom:25%;"></p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/01/xQ7PGAMoih9fKyb.png" style="zoom:25%;"></p>
<ul>
<li><p>头部弹出调整（删除操作）</p>
<ul>
<li>从头部删除元素 并维护堆的性质进行调整</li>
<li><p>我们让最后一个孩子作为头部元素 自上而下进行调整</p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/01/aNEQ9gS1Rwth8fp.png" style="zoom:25%;"></p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/01/LTNd3rGywOjWKAZ.png" style="zoom:25%;"></p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/01/7MV6siyqCFQLWl2.png" style="zoom:25%;"></p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/01/cd8uveO2L3FJbl6.png" style="zoom:25%;"></p>
</li>
</ul>
</li>
<li><p><strong>堆排序</strong></p>
<ul>
<li>我们将堆顶元素和堆尾元素置换  每次调整n-1个元素</li>
<li>时间复杂度O(nlogn)：因为每次是一层一层遍历 </li>
<li><p>大顶堆：从小到大排序     小顶堆：从大到小排序</p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/01/dqBPVt6S5MNvuxh.png" alt=""></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>普通队列与堆的比较</strong></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/01/Mdpj8Afi2TRsJa3.png" style="zoom: 50%;"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

typedef struct priority_queue {
    int *data;
    int cnt, size;//个数， 容量
} priority_queue;

priority_queue *init(int n) {
    priority_queue *q = (priority_queue *)malloc(sizeof(priority_queue));
    //由于优先队列是以数组的形式进行存储  且在逻辑上是一棵二叉树 所以在这里多开一位 
    //目的：可以方便计算
    q-&gt;data = (int *)malloc(sizeof(int) * (n + 1));
    q-&gt;cnt = 0;
    q-&gt;size = n;
    return q;
}

int empty(priority_queue *q) {
    return q-&gt;cnt == 0;
}

//堆顶弹出元素
int top(priority_queue *q) {
    return q-&gt;data[1];
}

int push(priority_queue *q, int val) {
    if (q == NULL) return 0;
    if (q-&gt;cnt == q-&gt;size) return 0;  //判断堆是否满
    q-&gt;data[++(q-&gt;cnt)] = val;        //++(q-&gt;cnt)是因为我们从1开始存储所以个数要先加1 
    int ind = q-&gt;cnt;     //ind记录的是最后插入元素的下标
    
    //由于我们插入一个元素 要进行向上调整 也就是当前节点需要跟父节点进行比较
    // ind &gt;&gt; 1 表示我们的父节点  维护大顶堆
    while (ind &gt;&gt; 1 &amp;&amp; q-&gt;data[ind] &gt; q-&gt;data[ind &gt;&gt; 1]) {
        swap(q-&gt;data[ind], q-&gt;data[ind &gt;&gt; 1]);
        ind &gt;&gt;= 1;  //交换后当前节点等于父节点
    }
    return 1;
}

int pop(priority_queue *q) {
    if (q == NULL) return 0;
    if (empty(q)) return 0;
    //我们将最后一个节点覆盖掉第一个节点  并让个数减1
    q-&gt;data[1] = q-&gt;data[q-&gt;cnt--];
    int ind = 1; //调整下标
    //左孩子的下标没有超过q-&gt;cnt的下标的话  说明ind这个节点有左孩子
    while ((ind &lt;&lt; 1) &lt;= q-&gt;cnt) {
        //😱(ind &lt;&lt; 1 | 1) 骚操作  表示的是ind * 2 + 1 
        int temp = ind, l = ind &lt;&lt; 1, r = ind &lt;&lt; 1 | 1;  
        if (q-&gt;data[l] &gt; q-&gt;data[temp]) temp = l;
        if (r &lt;= q-&gt;cnt &amp;&amp; q-&gt;data[r] &gt; q-&gt;data[temp]) temp = r;
        if (temp == ind) break;
        swap(q-&gt;data[ind], q-&gt;data[temp]);
        ind = temp;
    }
    return 1;
}

void clear(priority_queue *q) {
    if (q == NULL) return ;
    free(q-&gt;data);
    free(q);
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    priority_queue *q = init(max_op);
    for (int i = 0; i &lt; max_op; i++) {
        int val = rand() % 100;
        push(q, val);
        printf("insert %d to the priority_queue!\n", val);
    }
    for (int i = 0; i &lt; max_op; i++) {
        printf("%d ", top(q));
        pop(q);
    }
    printf("\n");
    #undef max_op
    clear(q);
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul>
<li>根据其性质，全部弹出，将得到一个排好序的序列</li>
<li>⭐思维转变：堆顶元素的弹出操作 ==&gt; 堆顶元素与堆尾元素交换<ul>
<li>【如此操作】</li>
<li><strong>大顶堆</strong>的元素全部弹出👉原数组存储了一个<strong>从小到大</strong>的排序序列</li>
<li>[至此，从大顶堆，得到一个特殊的小顶堆]</li>
</ul>
</li>
<li>时间复杂度：O(NlogN)<ul>
<li>消耗的时间在于调整操作，每次调整的时间复杂度是O(logN)，共N个元素，需调整N - 1次</li>
<li>弹出操作的时间复杂度是O(1)的</li>
<li>时间效率一定不会退化</li>
</ul>
</li>
</ul>
<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>【若要使用堆排序，首先需要维护一个堆，也就是用普通的序列<strong>建堆</strong>，下面有2种思路】</p>
<h4 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h4><p>又叫插入建堆法</p>
<ul>
<li>按照前述尾部插入的调整方法：自下向上<ul>
<li>从第0层 [默认根结点在第0层] 开始，计算每一层的最多调整次数：</li>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/li25Ec7btFYP68H.png" alt="图片" style="zoom:33%;"></li>
<li>第 i 层元素的调整次数为 i，第 i 层的结点数为2 ^ i→ 第 i 层的总调整次数为 i * (2 ^ i)</li>
</ul>
</li>
<li>最坏的建堆时间复杂度O(NlogN)，计算过程如下：<ul>
<li>总的调整次数 S = (n - 1) * 2 ^ (n + 1) + 1，过程如下：<ul>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/1Ierol5t3OMdZvT.png" alt="图片" style="zoom: 50%;"></li>
<li>利用裂项相消法</li>
</ul>
</li>
<li>上面的n对应层数 - 1 [从第0层开始的]，若令总的结点数为N，则n ≈ log[2]N</li>
<li>❗【层数n→结点数N的换算】将n ≈ log[2]N代入S，得到S ≈ Nlog[2]N</li>
<li>即最坏的时间复杂度为：O(NlogN)</li>
</ul>
</li>
</ul>
<h4 id="线性思路⭐"><a href="#线性思路⭐" class="headerlink" title="线性思路⭐"></a>线性思路⭐</h4><p>也就是【线性建堆法】</p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/xacplE79RSy5nZb.png" alt="图片" style="zoom: 33%;"></p>
<ul>
<li><p>如图所示</p>
<ul>
<li>常规思路：越到下面层，需要的调整次数越多，也就是权重越大</li>
<li>❗ 那是否可以思维反转，把大权重放到前面，让下面结点数多的层的权重减小</li>
<li>线性思路：可以！从倒数第二层开始排，【自上向下】调整</li>
</ul>
</li>
<li><p>🆒最坏的建堆时间复杂度O(N)</p>
<ul>
<li>同样利用裂项相消法得到总的调整次数 S = 2 ^ (n + 1) - 2 - n</li>
<li>把层数n换算到结点数N，得到S ≈ 2N - 2 - log[2]N</li>
<li>即最坏的时间复杂度为：O(N)</li>
</ul>
</li>
<li><p>⭐推荐视频</p>
<p>  Linear Time BuildHeap</p>
<p>  ——Youtube</p>
<ul>
<li>比较了常规建堆和线性建堆两种思路，并有直观的动画演示，加深印象</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

void downUpdate(int *arr, int n, int ind) {
    while ((ind &lt;&lt; 1) &lt;= n) {
        int temp = ind, l = ind &lt;&lt; 1, r = ind &lt;&lt; 1 | 1;
        if (arr[l] &gt; arr[temp]) temp = l;
        if (r &lt;= n &amp;&amp; arr[r] &gt; arr[temp]) temp = r;
        if (ind == temp) break;
        swap(arr[temp], arr[ind]);
        ind = temp;
    }
    return ;
}

void heap_sort(int *arr, int n) {
    arr -= 1;
    //从最后一个结点的父结点开始调整
    for (int i = n &gt;&gt; 1; i &gt;= 1; i--) {
        downUpdate(arr, n, i);
    }
    for (int i = n; i &gt; 1; i--) {
        swap(arr[i], arr[1]);
        downUpdate(arr, i - 1, 1);  //从上到下调整
    }
    return ;
}

void output(int *arr, int n) {
    printf("[");
    for (int i = 0; i &lt; n; i++) {
        printf("%d ", arr[i]);
    }
    printf("]\n");
    return ;
}

int main() {
    srand(time(0));
    #define max_n 20
    int *arr = (int *)malloc(sizeof(int) * max_n);
    for (int i = 0; i &lt; max_n; i++) {
        arr[i] = rand() % 100;
    }
    output(arr, max_n);
    heap_sort(arr, max_n);
    output(arr, max_n);
    free(arr);
    #undef max_n
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="森林与并查集"><a href="#森林与并查集" class="headerlink" title="森林与并查集"></a>森林与并查集</h2><p><strong>并查集能解决的问题：</strong>  具有连通性关系的问题</p>
<ul>
<li>确认连通关系：广义上来说 是将两个集合进行合并成具有连通关系的集合</li>
<li>可以判断我们两个点在一个集合中是否具有连通关系</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/01/P2gNkn1Kl6hrf5D.png" style="zoom: 50%;"></p>
<p><strong>==quick-find算法==</strong></p>
<ul>
<li>核心思想：染色<ul>
<li>一个颜色，对应一个类别</li>
<li>初始化：个体独立，都写成自己的索引，属于一个独立的集合里</li>
<li>⭐把和自己<strong>连通的所有</strong>点的颜色改成要染的颜色</li>
</ul>
</li>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/01/ME1OelXAKCh8oTy.png" style="zoom:50%;"></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/WqwkN7KaLhMrSsY.png" style="zoom: 33%;"></p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/TPQ82X5sUf6uaip.png" style="zoom: 33%;"></p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/INyQYtorC2s9HcS.png" style="zoom: 33%;"></p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/ntTUIECy5oNiBK3.png" style="zoom: 33%;"></p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/OV5Kg3sGFUJ1yzn.png" style="zoom:33%;"></p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/GSbncK8QoPh7Agd.png" style="zoom:33%;"></p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/ajEWyiRCK9whLuT.png" style="zoom:33%;"></p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/THxgoszNDCR4OPb.png" style="zoom:33%;"></p>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/UE1fvsd9CFnGwZa.png" style="zoom:50%;"></p>
<hr>
<ul>
<li><p><strong>==quick_union算法==</strong></p>
<ul>
<li>找代表元素👉（找大哥） 对于两个点 我们如果想判断连通性 那么我们就去查看他们的大哥是不是同一个</li>
<li>对于集合和集合之间建立的连通关系可以认为是集合和集合之间的合并操作 <ul>
<li>👉 （逻辑上）两颗子树的合并操作</li>
<li>👉    最终会在一个根结点下面 也就只有一个代表元素</li>
</ul>
</li>
</ul>
</li>
<li><p>首先链表是一棵极端的树</p>
</li>
<li>当我们用这种算法时两棵子树可能退化成链表 且有n个节点 则此时的树高也为n <ul>
<li>合并操作将退化为O(n) →O(树高)</li>
<li>联通操作将退化为O(n) →O(树高)</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/pqUVch8YfDGRPvB.png" alt=""></p>
<p><strong>==Weighted quick_union算法==</strong></p>
<ul>
<li><p>按秩优化</p>
</li>
<li><p>如何避免退化？→保证枝繁叶茂</p>
<ul>
<li>合并依据1：树高，矮树挂在高树下[两两结合]<ul>
<li>高度为 h 的树，至少需要的结点个数N为2 ^ (h - 1)</li>
<li>即树高h = log[2]N + 1 ≈ log[2]N</li>
<li>[PS] 只有两棵一样树高的树合并，才会使高度增加</li>
</ul>
</li>
<li>合并依据2：结点数量，结点少的树挂在结点多的树下</li>
<li>两种优化方式都能得到O(logN)，但是合并依据2【结点数量】更优秀一些</li>
</ul>
</li>
<li>⭐为什么合并依据2更优秀<ul>
<li>【示例】什么是平均查找次数<ul>
<li>如下图所示，计算了A、B树的平均查找次数</li>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/9Q7TrSfvowusW1i.png" alt="图片" style="zoom: 25%;"></li>
<li>结点深度即为结点的查找次数，平均查找次数 = 总查找次数 / 总结点数</li>
<li>此示例，B树的查找操作更快</li>
</ul>
</li>
<li>【推导】合并依据2直接决定平均查找次数<ul>
<li>对于有SA、SB个结点的A、B树，它们的总查找次数LA、LB分别为：<ul>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/kGLCJWbNK3AUIlo.png" alt="图片" style="zoom:33%;"></li>
<li>其中，li 代表第 i 个结点的深度</li>
</ul>
</li>
<li>此时进行合并操作，分别计算①A→B和②B→A的平均查找次数<ul>
<li>①当A树作为子树合并到B树时，为<ul>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/B3hH8jwXaIxoed5.png" alt="图片" style="zoom:33%;"></li>
<li>A树中的所有结点需要多查找一次</li>
</ul>
</li>
<li>②当B树作为子树合并到A树时，为<ul>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/CSLM1K4NwOuWsnm.png" alt="图片" style="zoom:33%;"></li>
<li>B树中的所有结点需要多查找一次</li>
</ul>
</li>
</ul>
</li>
<li>❗【比较两种方式的平均查找次数】<ul>
<li>和树高[LA、LB]没有直接关系，而分子的结点数量[SA、SB]【直接】决定查找次数，次数越小越好</li>
<li>👉谁的结点数少，就作为子树被合并</li>
<li>❓思考：上面的推导是否证明高度无法作为合并依据呢？<ul>
<li>❌否，高度间接影响着结点数量，一般情况高度越低，结点数量越少</li>
<li><strong>但是</strong>，对于特殊情况，A树比B树高，而A树结点数量却比B树少时，还是按照【结点数量】作为合并依据，将A树作为子树合并到B树里</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>所以以结点数作为合并依据更优秀！👇合并思路如下</li>
</ul>
</li>
<li>在合并两棵子树时<ul>
<li>如果结点数一样，就按照普通Quick-Union的思路换</li>
<li>如果不一样，结点数少的子树的根结点接在👉结点数多的子树的根结点下面</li>
</ul>
</li>
<li>[PS]换句话说<ul>
<li>在换大哥时</li>
<li>如果小弟数量一样，就按照普通Quick-Union的思路换</li>
<li>如果不一样，小弟少的大哥得跟👉小弟多的大哥混</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/03/Q9U6dhz8Bl1eLjf.png" style="zoom: 25%;"></p>
<ul>
<li><strong>==Quick-Find vs. Quick-Union==</strong></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/xyuUOQsW9oiJenL.png" alt="图片" style="zoom: 50%;"></p>
<ul>
<li><p>【关键】理解Quick-Union</p>
<ul>
<li>0-&gt;1-&gt;2-&gt;4-&gt;5、3-&gt;4-&gt;5；8-&gt;9-&gt;7-&gt;6</li>
<li>查找、合并边界：自己的代表元素就是本身时，停止</li>
</ul>
</li>
<li><p><strong>==Quick-Union vs. weighted Quick-Union==</strong></p>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/omhF9JsytLTz13i.png" alt="图片" style="zoom:33%;"></p>
<ul>
<li>【关键】理解weighted的含义<ul>
<li>当两个集合的元素个数不一样时</li>
<li>元素少的集合的代表元素的值👉元素多的集合的代表元素的值</li>
<li>小弟少的大哥得跟着小弟多的大哥混</li>
</ul>
</li>
<li>结果可视化<ul>
<li><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/02/3axleQf7TPc1JEb.png" alt="图片" style="zoom: 33%;"></li>
<li>很明显，weighted方法得到的树更矮，合并、查找效率更高</li>
</ul>
</li>
</ul>
<ul>
<li><strong>从练习题入手并查集</strong></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://i.loli.net/2020/12/04/MEo37UCIGHfJZvW.png" alt=""></p>
<p> 样例输入</p>
<pre class="line-numbers language-none"><code class="language-none">6 5
1 1 2
2 1 3
1 2 4
1 4 3
2 1 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 样例输出</p>
<pre class="line-numbers language-none"><code class="language-none">No
Yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>quick_find</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct UnionSet {
    int *color; //需要一片连续的空间存储每个元素的颜色 
    int n;		//color指向这片连续空间的首地址
} UnionSet;

UnionSet *init(int n) {
    UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet));
    u-&gt;color = (int *)malloc(sizeof(int) * (n + 1));
    u-&gt;n = n;
    for (int i = 1; i &lt;= n; i++) {
        u-&gt;color[i] = i; // 将每个元素初始化为自己
    }
    return u;
}

int find(UnionSet *u, int x) {
    return u-&gt;color[x];
}

//合并
int merge(UnionSet *u, int a, int b) {
    if (find(u, a) == find(u, b)) return 0; //判断a和b是否连通 
    int color_a = u-&gt;color[a]; //保存前一个变量的颜色
    //把所有a的颜色 改为 b的颜色
    for (int i = 1; i &lt;= u-&gt;n; i++) {
        if (u-&gt;color[i] - color_a) continue; //若当前i的颜色等与a的颜色 则执行下次循环 否则 
        u-&gt;color[i] = u-&gt;color[b];				//将i的颜色改为b的颜色
    }
    return 1;
}

void clear(UnionSet *u) {
    if (u == NULL) return ;
    free(u-&gt;color);
    free(u);
    return ;
}

int main() {
    int n, m;
    scanf("%d%d", &amp;n, &amp;m);
    UnionSet *u = init(n);
    for (int i = 0; i &lt; m; i++) {
        int a, b, c;
        scanf("%d%d%d", &amp;a, &amp;b, &amp;c);
        switch (a) {
            case 1: merge(u, b, c); break;
            case 2: printf("%s\n", find(u, b) == find(u, c) ? "Yes" : "No");
                    break;
        }
    }
    clear(u);
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Weighted quick_union + 路径压缩</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

typedef struct UnionSet {
    int *father;
    int *size; //记录相关的节点个数  weighted quick-union 优化
    int n;
} UnionSet;

UnionSet *init(int n) {
    UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet));
    u-&gt;father = (int *)malloc(sizeof(int) * (n + 1));
    u-&gt;size = (int *)malloc(sizeof(int) * (n + 1));
    u-&gt;n = n;
    for (int i = 1; i &lt;= n; i++) {
        u-&gt;father[i] = i;
        u-&gt;size[i] = 1; //最开始相关的节点数为自己 = 1
    }
    return u;
}

int find(UnionSet *u, int x) {
    //if (u-&gt;father[x] == x) return x;//返回的是当前元素的代表元素
    //return find(u, u-&gt;father[x]);   //否则我们就递归去找它父亲的父亲

    //优化 ：路径压缩  找到最直接的父亲  在路径压缩面前 可以去掉按节点合并的优化操作 其效率差不多
    return u-&gt;father[x] = (u-&gt;father[x] == x ? x : find(u, u-&gt;father[x]));
}

int merge(UnionSet *u, int a, int b) {
    int fa = find(u, a), fb = find(u, b);
    if (fa == fb) return 0;
    if (u-&gt;size[fa] &lt; u-&gt;size[fb]) swap(fa, fb); //当fa的节点个数小于fb的节点个数 交换它们 保证fa的节点数是最大的
    u-&gt;father[fb] = fa;   //把fa当做合并后的根节点
    u-&gt;size[fa] += u-&gt;size[fb];  //当fb作为子树时 fa整体的节点个数要加上fb的
    return 1;
}

void clear(UnionSet *u) {
    if (u == NULL) return ;
    free(u-&gt;father);
    free(u-&gt;size);
    free(u);
    return ;
}

int main() {
    int n, m;
    scanf("%d%d", &amp;n, &amp;m);
    UnionSet *u = init(n);
    for (int i = 0; i &lt; m; i++) {
        int a, b, c;
        scanf("%d%d%d", &amp;a, &amp;b, &amp;c);
        switch (a) {
            case 1: merge(u, b, c); break;
            case 2: printf("%s\n", find(u, b) == find(u, c) ? "Yes" : "No");
                    break;
        }
    }
    clear(u);
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <tags>
        <tag>Data structure, C</tag>
      </tags>
  </entry>
</search>
