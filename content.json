{"meta":{"title":"The Srymaker0","subtitle":"","description":"我只知道一件事，那就是我一无所知","author":"srymaker0","url":"http://srymaker0.com","root":"/"},"pages":[{"title":"charts","date":"2021-05-04T08:32:56.000Z","updated":"2021-05-04T08:38:51.984Z","comments":true,"path":"charts/index.html","permalink":"http://srymaker0.com/charts/","excerpt":"","text":""},{"title":"Me","date":"2021-05-05T08:34:13.000Z","updated":"2021-09-06T14:28:18.171Z","comments":true,"path":"about/index.html","permalink":"http://srymaker0.com/about/","excerpt":"","text":"我是一位正在秃头中的在校大学生🐶 这个博客是在2021年五一假期间完成的，去掉了butterfly中很多花里胡哨的东西，学习&amp;分享才是本博客的重点！ 本博客的文章全是个人学习的笔记，有一些自己的见解，如有错误，请指正！ 兄弟们要是想冲我，那就请我喝一杯咖啡吧! 希望我们在学习计算机的道路上不断进步，不断分享。"},{"title":"分类","date":"2021-05-02T11:47:00.000Z","updated":"2021-05-04T10:18:57.258Z","comments":true,"path":"categories/index.html","permalink":"http://srymaker0.com/categories/","excerpt":"","text":""},{"title":"友情链接","date":"2021-05-02T11:50:07.000Z","updated":"2021-05-02T11:50:35.947Z","comments":true,"path":"link/index.html","permalink":"http://srymaker0.com/link/","excerpt":"","text":""},{"title":"标签","date":"2021-05-02T11:44:44.000Z","updated":"2021-05-04T10:20:16.307Z","comments":true,"path":"tags/index.html","permalink":"http://srymaker0.com/tags/","excerpt":"","text":""},{"title":"留言板","date":"2021-05-02T12:17:54.000Z","updated":"2021-05-04T08:31:40.812Z","comments":true,"path":"messageboard/index.html","permalink":"http://srymaker0.com/messageboard/","excerpt":"","text":""},{"title":"","date":"2021-05-08T09:15:24.398Z","updated":"2021-05-08T09:15:24.370Z","comments":true,"path":"self/duotone.css","permalink":"http://srymaker0.com/self/duotone.css","excerpt":"","text":"/* 新添加的内容 ------------------------------------- --hl-color 代码框字体顔色 【必须】 (把下面 pre[class*=\"language-\"]的 color 复製到这里来) --hl-bg 代码框背景色 【必须】 (把下面 pre[class*=\"language-\"]的 background复製到这里来) --hltools-bg: #321a0f 代码框顶部工具栏背景色 【可选】(如果你关掉了 copy、lang 和 shrink,可不用配置这个） --hltools-color: #fff 代码框顶部工具栏字体顔色 【可选】(如果你关掉了 copy、lang 和 shrink,可不用配置这个） --hlnumber-bg: #221a0f 代码框行数背景色 【可选】(如果已经关掉 line_number,可以不用配置这个) --hlnumber-color: #fff 代码框行数字体顔色 【可选】 (如果已经关掉 line_number,可以不用配置这个) --hlscrollbar-bg: #d3af86 代码框滚动条顔色 【可选】（默认为主题主顔色） --hlexpand-bg: #d3af86 代码框底部展开背景色 【可选】(如果已经关掉 highlight_height_limit,可以不用配置这个) */ :root { --hl-color: #728fcb; --hl-bg: #000; --hltools-bg: xxxxxxx; --hltools-color: xxxxxxx; --hlnumber-bg: xxxxxxx; --hlnumber-color: xxxxxxxx; --hlscrollbar-bg: xxxxx; --hlexpand-bg: xxxxxxx } /* ------------------------------------- */ /* 这些可以删除（可留着，如果有冲突，请删除） */ /* ------------------------------------- */ code[class*=\"language-\"], pre[class*=\"language-\"] { font-family: Consolas, Menlo, Monaco, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", \"Courier New\", Courier, monospace; font-size: 14px; line-height: 1.375; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; -moz-tab-size: 4; -o-tab-size: 4; tab-size: 4; -webkit-hyphens: none; -moz-hyphens: none; -ms-hyphens: none; hyphens: none; background: #000; color: #728fcb; } pre &gt; code[class*=\"language-\"] { font-size: 1em; } pre[class*=\"language-\"]::-moz-selection, pre[class*=\"language-\"] ::-moz-selection, code[class*=\"language-\"]::-moz-selection, code[class*=\"language-\"] ::-moz-selection { text-shadow: none; background: #faf8f5; } pre[class*=\"language-\"]::selection, pre[class*=\"language-\"] ::selection, code[class*=\"language-\"]::selection, code[class*=\"language-\"] ::selection { text-shadow: none; background: #faf8f5; } /* Code blocks */ pre[class*=\"language-\"] { padding: 1em; margin: .5em 0; overflow: auto; } /* Inline code */ :not(pre) &gt; code[class*=\"language-\"] { padding: .1em; border-radius: .3em; } /* ------------------------------------- */ /* 到这里为止，可以删除 */ .token.comment, .token.prolog, .token.doctype, .token.cdata { color: #b6ad9a; } .token.punctuation { color: #b6ad9a; } .token.namespace { opacity: .7; } .token.tag, .token.operator, .token.number { color: #063289; } .token.property, .token.function { color: #b29762; } .token.tag-id, .token.selector, .token.atrule-id { color: #2d2006; } code.language-javascript, .token.attr-name { color: #896724; } code.language-css, code.language-scss, .token.boolean, .token.string, .token.entity, .token.url, .language-css .token.string, .language-scss .token.string, .style .token.string, .token.attr-value, .token.keyword, .token.control, .token.directive, .token.unit, .token.statement, .token.regex, .token.atrule { color: #728fcb; } .token.placeholder, .token.variable { color: #93abdc; } .token.deleted { text-decoration: line-through; } .token.inserted { border-bottom: 1px dotted #2d2006; text-decoration: none; } .token.italic { font-style: italic; } .token.important, .token.bold { font-weight: bold; } .token.important { color: #896724; } .token.entity { cursor: help; } pre &gt; code.highlight { outline: .4em solid #896724; outline-offset: .4em; } /* overrides color-values for the Line Numbers plugin * http://prismjs.com/plugins/line-numbers/ */ .line-numbers .line-numbers-rows { border-right-color: #ece8de; } .line-numbers-rows &gt; span:before { color: #cdc4b1; } /* overrides color-values for the Line Highlight plugin * http://prismjs.com/plugins/line-highlight/ */ .line-highlight { background: rgba(45, 32, 6, 0.2); background: -webkit-linear-gradient(left, rgba(45, 32, 6, 0.2) 70%, rgba(45, 32, 6, 0)); background: linear-gradient(to right, rgba(45, 32, 6, 0.2) 70%, rgba(45, 32, 6, 0)); }"}],"posts":[{"title":"手撕红黑树！！！","slug":"ad_02_RBTree","date":"2022-01-03T06:33:21.000Z","updated":"2022-01-05T07:07:39.657Z","comments":true,"path":"posts/9afc.html","link":"","permalink":"http://srymaker0.com/posts/9afc","excerpt":"","text":"红黑树（上）一、五个平衡条件 每个节点非黑既红 根节点是黑色 叶子节点（NIL）为黑色 —— 注意此处的叶子节点为NIL节点，即虚拟空节点 ⭐每个红色节点下只能是黑色节点 ⭐从根节点到叶子节点路径上 黑色节点数量相同 平衡条件的认识 第4条和第5条条件，注定了， 红黑树中最长路径是最短路径的长度的2倍 假设最短边有3个黑色节点，构造其最长边可以一黑一红一黑一红一黑一红。 本质上，红黑树也是通过树高来控制平衡的。 👉根据第4点和第5点条件 红黑树比AVL树树高控制条件更松散，红黑树在发生节点插入和删除后，发生调整的概率，比AVL树要更小。 二、学习诀窍 理解红黑树的插入调整，要站在==祖父节点==向下调整 理解红黑树的删除调整， 要站在==父节点==向下进行调整 插入调整，主要就是为了解决双红情况 新插入的节点一定是红色。 插入黑色节点一定会 产生冲突，违反条件5, 会改变路径上黑色节点的数量 插入红色节点，不一定产生冲突👉有可能插在黑色节点下 把每一种情况，想象成一颗大的红黑树中的局部子树 局部调整的时候， 为了不影响全局， 调整前后的路径上黑色节点数量相同 三、插入策略 发生冲突的时候， 叔叔节点为红色的时候，修改三元组，改成红黑黑 叔叔节点为黑色的时候，参考AVL树的失衡情况，分成LL,LR,RL,RR先参考AVL树的旋转调整策略，然后再修改三元组的颜色，有两种调整策略：红色上浮，红色下沉 两大类情况，包含8种小情况 情况① ⭐把这些个情况都想象成一颗局部的树 👆调整前的每条路径的节点数量等于调整后的每条路径上的节点数量 我们要推导通用的调整策略，而不是只针对这样一颗树 看15 1 20这个三元组 为每条路径提供了一个黑色节点，若把1 20改为黑色，则改变了调整之前的黑色节点数量（多了1个），若这还是一棵子树，则会影响整棵树的平衡👇 将其分别改成红-黑-黑一样也可以为每条路径提供一个黑色节点 情况② 颜色的确定 由于是LL型失衡所以15 10 的颜色一定为红色 因为情况②是叔叔节点为黑色节点且由于根节点也为黑色 则每条路径既有2个黑色节点 所以19一定为黑色节点 且10 号节点下的两个子节点一定为黑色 这是为了确保每条路径上的黑色节点数相同 ❗17号节点不一定存在 格局要大 ⭐调整策略 由于这是LL型失衡 参照AVL树的旋转调整策略 抓着20节点一个大右旋 ❗如果抓着15节点右旋后 不会改变每条路径上的黑色节点数量 经过大右旋后各节点分布如上图👆 可以看到右旋后的树可以分成两部分 调整前每条路径有两个黑色节点 那么调整后每条路径也必须有两个黑色节点 此时有两种调整策略 即 红色上浮 和 红色下沉 把15 10 20这个三元组改成红-黑-黑 既 红色上浮 把15 10 20这个三元组改成黑-红-红 既 红色下沉 红色上浮：容易和父节点发生冲突 红色下沉：容易和新插入的节点发生冲突 ❗引发的思考：研究问题可以先寻找哪些是确定性的，哪些是不确定的 五、代码演示 插入调整，发生再递归的回溯阶段 插入调整代码中，使用goto语句，8行代码，变成了4行 处理根节点一定是黑色，用过代码封装，insert-&gt; __insert AVL树与红黑树对比 查找效率 ： AVL树 &gt; 红黑树 因为AVL树更加平衡 插入，删除效率：红黑树 &gt; AVL树 在某些情况下红黑树只需要改变颜色即可完成一次调整 而AVL树调整必须发生旋转 插入调整，需要封装两层 红黑树（下）一、删除调整发生的前提 删除度为1的红色节点，不会对红黑树的平衡产生影响 度为1的黑色节点，唯一子孩子，一定是红色 子孩子如果为黑色 则肯定度为2 删除度为1的黑色节点，不会产生删除调整 删除度为0的黑色节点，会产生一个双重黑的 NIL 节点 删除度为2的节点可以转化为删除度为1的节点 删除调整，就是为了干掉双重黑 理解产生双重黑 删除之后如下图 因为删除后我们把NIL节点接在右孩子处 👉所以相应的左孩子的两个NIL节点也要画出来 由于NIL节点是黑色的， 这时每条路径的黑色节点数量不一样，发生了失衡 解决办法是把删除后接上的NIL节点染成双重黑 二、删除调整 双重黑节点的兄弟节点是黑色，兄弟节点下面的两个子节点也是黑色，父节点增加一重黑色，双重黑与兄弟节点，分别减少一重黑 兄弟节点是黑色，并且，兄弟节点中有红色子节点 R（兄弟）R（右子节点），左旋，新根改成原根的颜色，将新根的两个子节点，改成黑色 调整思路 👉 此时节点28被标记为双重黑 要消灭之 前提：28的双重黑是由于删除了节点所引起的 这里不是要删除28 而是要消灭28身上的双重黑 首先确定哪些节点的颜色是不变的 28 51 72 64 85 → 一方面是RR类型失衡条件决定 28提供了两个黑色节点 51由于性质必定为黑色 72必定为红色 那么每个路径有两个黑色节点 所以 64和85节点一定为黑色 其余的节点颜色都不确定 48节点有可能是红色 只要将42节点改为黑色 再在48节点的右节点中添加一个黑色节点（因为要保证每条路径的黑色节点数相同） 调整操作 RR类型需要先进行左旋 👉如上图 是绕着38进行左旋后的树 ⭐此时28的双重黑在旋转后已经变为一重黑了👉在旋转后已经把双重黑干掉了 ⭐由于48节点有可能是红色→那么42节点需要改为黑色→ 且必将把38节点改为黑色→然后将51节点改为红色→由于要确保每条路径黑色节点数相同最后需要将72节点改为黑色 因为38节点也有可能是黑色，那么根据平衡条件，51要染成黑色 总结一下就是51 38 72这三元组中 新根节点→染成原根节点的颜色 新根节点的左右孩子节点→都染成黑色节点 3. R（兄弟）L（左子节点），先小右旋，对调新根与原根的颜色，转成上一种情况 - &lt;img src=\"https://i.loli.net/2020/12/25/fRANHcFExztqXLl.png\" style=\"zoom:45%;\" /&gt; - 其实跟RR类型思路一样 - 确定颜色不变的节点`51` `48` `72` `64` `85` → 因为是RL类型 所以`85`节点必为黑色 `51`节点必为红色才能是RL类型 - 经过旋转后可得下图→小右旋 - &lt;img src=\"https://i.loli.net/2020/12/25/6a9flzyhY3Q4sCF.png\" style=\"zoom:50%;\" /&gt; - 为了不改变路径上的黑色节点数量，将`51`改为黑色 `72`改为红色 - 原根的颜色变为红色，新根（旋转后的）的颜色变为黑色 - 此时就变成RR类型的情况了 - 请看RR类型调整策略 4. LL 同理 RR 5. LR 同理 RL 6. 兄弟节点是红色，通过旋转，转变成兄弟节点是黑色的情况 - 左边为旋转前 右边为旋转后 - &lt;img src=\"https://i.loli.net/2020/12/25/QJq8zaVRDhTskLn.png\" style=\"zoom: 50%;\" /&gt; - 没旋转前每条路径上有三个黑色节点，旋转后右子树中每条路径只有两个黑色节点，故把旋转后的根节点改黑 - 又由于新根节点改为黑色后 左子树中每条路径的黑色节点有4个 ， 故把新根节点左孩子改为红色 - 双重黑节点下降了一层且调整时要站在父节点向下调整 - 那么这种情况就变成了双重黑节点的兄弟节点是黑色的情况 - 问题转化ok 三、代码演示 进行 LR/RL 类型判断的时候，不能判断 LL 子树是否为黑色，LL 子树有可能是 NIL 节点，在某些特殊情况下，读到的颜色可能是双重黑，取而代之的判断方法就是【LL 子树不是红色】。 输出调试","categories":[],"tags":[]},{"title":"BSTree&AVL_Tree","slug":"ad_01_BST&AVL_Tree","date":"2022-01-03T06:12:13.000Z","updated":"2022-01-03T09:08:33.772Z","comments":true,"path":"posts/a49b.html","link":"","permalink":"http://srymaker0.com/posts/a49b","excerpt":"","text":"二叉查找树一、性质 左子树 &lt; 根节点 右子树 &gt; 根节点 中序遍历的结果，是一个有序序列 数据结构，就是定义一种性质，并且维护这种性质。 二、插入操作 插入的新节点，一定会做为叶子结点 三、删除操作 删除度为0的节点，直接删除 删除度为1的节点，把『孤儿子树』挂到其父节点上面去 删除度为2的节点，可以转化成删除度为1的节点 首先找到度为2的节点的前驱节点 该前驱是左子树中最大的值 将此值把度为2的节点覆盖掉 然后再在原来的左子树中把此值（前驱节点）删除 ⭐代码中有bug 但是对整体来说并没有bug因为度为0或者1的节点都被处理了 ❗注意： 度为1的前驱不一定在子树中 对于度为2的节点： 前驱节点：左子树最大值 后继节点：右子树最小值 四、随堂练习 插入顺序会影响最终的树形结构 我们可以看到第2种插入顺序 这不就是一个链表吗 而且此时的查找效率会退化为O(n) 不同的树形结构，查找效率不同 平均查找效率：节点查找次数的期望值，$\\frac{总次数}{节点数量}$ 前提条件：假设每个节点等概率的被查找 总次数=每个节点的查找次数之和 leetcode 110 669 五、扩展内容 二叉排序树的删除代码优化 删除掉处理度为0的代码逻辑，不影响代码整体功能 如何解决==排名==相关的检索需求 修改二叉排序树的结构定义，增加 size 字段，记录每棵树的节点数量 $k = LS - 1$根节点就是排名第 k 位的元素 $k \\le LS$，排名第 k 位的元素在左子树中 $k \\gt LS，search_k(root-&gt;rchild, k - LS - 1)$ 解决 Top-K 问题（找到小于第 k 位的所有元素）(也可以用堆来解决) 根节点就是第 k 位元素的话，就把左子树中的值全部输出出来 第 k 位在左子树中，前 k 位元素全都在左子树中 第 k 位在右子树中，说明根节点和左子树中的元素，都是前 k 位元素里面的值 二叉排序树和快速排序的关系 二叉排序树是快速排序在思维逻辑结构层面用的数据结构 思考1：快速排序的时间复杂度和二叉排序树建树时间复杂度之间的关系 思考2：快速选择算法和二叉排序树之间的关系 程序=算法+数据结构 所谓算法设计及分析能力：分类讨论及归纳总结的能力 平衡二叉查找树之AVL树一、学习重点 平衡二叉树排序树，本质上也是二叉排序树，所以拥有二叉排序树的所有性质 平衡二叉树排序树的学习重点， 在于平衡条件以及平衡调整的相关学习 二、性质1.平衡条件：左右子树高度差不超过1三、思考 AVL树改进的是节点数量的下限 大约是$1.5^h$ 提高了下限 再差也差不到哪里去 查找效率为O(logn) 节点数n 和 树高h之间的关系 $h=log^n$ 当表示最少节点数时 log的底数是1.5 当表示最少节点数时 log的底数是2 树高 = 生命长度， 节点数量 = 生命财富 教育提升的是底线，而不是上限 四、平衡调整策略 左旋 左旋的操作意义 （有点类似与天平） 降低右子树的树高 加深左子树的树高 右旋其实就是左旋的翻版 发生在回溯阶段的，第一个失衡节点处 理解平衡调整策略的关键在于： 分析清楚四种情况下， ABCD四棵子树树高的关系 LL 假设A，B，C，D子树的树高分别为h1，h2，h3， h4 首先 h3, h4 不一定相等 但是他们满足平衡条件👉h3和h4之间的高度差不会大于1 为什么会发生失衡？👉 这是由于插入了一个节点所产生的 且由于是LL型的失衡所以插入到A子树产生了失衡 根据失衡条件 K2的高度要比K3的高度大2👉这是大前提 也就是站在K1的视角看下面的子树是失衡的 平衡时K2的高度为h1+1 ， K3的高度为max（h3，h4）+ 1 那么失衡时$h1+1=max（h3，h4）+ 1 + 2$👉$h1 = max(h3,h4) + 2$ 大前提情况下A B不能失衡 否则就是站在K2的视角就已经失衡了 所以$h1 = h2 + 1$ 综上所述$h1 = max(h3,h4) + 2 = h2 + 1$ 这种失衡用右旋操作解决 平衡的可怕❗ $h2 = max(h3,h4) + 1 = K3$ $K1 = h2 + 1 = h1$ 放眼看去 Woc 全部平衡了 🤭 LR 处理方法 先抓着K2小左旋 再抓着K1大右旋 RL RR 练习 五、代码演示 插入和删除以后， 注意重新计算树高字段 引入了NIL阶段， 代替NULL，NULL不可访问，NIL是一个实际节点，可访问 (帮助我们实现) vim微操 ctrl+v进入可视块模式 : 可以选中一块内容 选中后按shift + i选中一列👉这种插入模式可以按列插入 只要在第一行插入 接着按ESC就可以一列插入 删除也是ctrl+v进入可视块模式 选中要删除的按x","categories":[],"tags":[]},{"title":"AVL","slug":"let_16_AVL","date":"2021-12-28T09:11:09.000Z","updated":"2022-01-03T09:08:30.600Z","comments":true,"path":"posts/416e.html","link":"","permalink":"http://srymaker0.com/posts/416e","excerpt":"","text":"LeetCode环节面试题 04.06. 后继者 使用中序遍历 node用来防止遍历是遇到空节点直接返回 结构化思维——pre会依次访问到树中的每一个节点 450. 删除二叉搜索树中的节点 1382. 将二叉搜索树变平衡 可把原来的树看成一个有序的序列（中序遍历），使最中间的那个数作为根节点，递归解题 108. 将有序数组转换为二叉搜索树 和上题几乎一样 98. 验证二叉搜索树 使用中序遍历，看成在遍历一个有序数组 501. 二叉搜索树中的众数 思路：二叉搜索树的中序遍历是一个升序序列，逐个比对当前结点(root)值与前驱结点（pre)值。 更新当前节点值出现次数(cnt)及最大出现次数(max_cnt) 更新规则：若cnt=max_cnt,将root-&gt;val添加到结果向量(ret)中；若cnt&gt;max_cnt,清空ret,将root-&gt;val添加到ret,并更新max_cnt为cnt。 面试题 17.12. BiNode 剑指 Offer 33. 二叉搜索树的后序遍历序列 思路：利用结构化思维，把此序列想成一棵二叉搜索树，用中序遍历的性质，找到第一个大于根节点的值的下标ind，和左子树根节点ind-1，递归比较根节点的大小。 1008. 前序遍历构造二叉搜索树 面试题 04.09. 二叉搜索树序列","categories":[],"tags":[]},{"title":"15题——回顾篇","slug":"let_15_专项训练","date":"2021-12-06T13:46:10.000Z","updated":"2021-12-16T14:46:54.988Z","comments":true,"path":"posts/cdd7.html","link":"","permalink":"http://srymaker0.com/posts/cdd7","excerpt":"","text":"力扣15题1367. 二叉树中的列表 958. 二叉树的完全性检验 剑指 Offer 36. 二叉搜索树与双向链表 464. 我能赢吗 记忆化——mask为自变量，total是随着mask的值改变而改变，使用自变量当做去重哈希表的下标值 172. 阶乘后的零 384. 打乱数组 437. 路径总和 III 395. 至少有 K 个重复字符的最长子串 190. 颠倒二进制位 8. 字符串转换整数 (atoi) 380. O(1) 时间插入、删除和获取随机元素 要求删除、插入时间复杂度为$O(1)$——哈希表，但$O(1)$获取随机元素——哈希表无法完成，可以用动态数组——push_back()，pop_back()，二者联用可完成此题 哈希表记录val在动态数组的位置 402. 移掉 K 位数字 删除k个数，形成最小的数字-&gt;尽量把较小的数字往前拱，联想到单调递增栈，把违反单调性的数字删除 substr第二个参数超过字符串长度时，表示从当前位置截取到最后一个位置 1081. 不同字符的最小子序列 1499. 满足不等式的最大值","categories":[],"tags":[]},{"title":"单调栈","slug":"let_14_单调栈","date":"2021-11-28T11:04:45.000Z","updated":"2021-12-23T15:31:01.137Z","comments":true,"path":"posts/831c.html","link":"","permalink":"http://srymaker0.com/posts/831c","excerpt":"","text":"单调栈 砍掉一端的单调队列 例如：单调递减栈——蓝色是黄色右边第一个比它们大的元素，是绿色右边第一个比它们小的元素 黄色——被蓝色踢出的元素——比蓝色小 绿色——比蓝色大 单调递减栈：维护最近大于关系 单调递增栈：维护最近小于关系 代码演示 效果： Leetcode环节155. 最小栈 503. 下一个更大元素 II 单调递减栈 901. 股票价格跨度 分析：此题求解往回数有多少天是小于等于当前股票的天数-&gt;等价于求左边第一个大于当前数的元素 解法：单调递减栈 739. 每日温度 84. 柱状图中最大的矩形 分析：以每个矩形的高为基准，向前找第一个小于当前矩形的位置，向后找第一个小于当前矩形的位置，宽为这两个位置的差值-1 小于关系-&gt;单调递增栈 考虑重复元素，例如：2，3，3，3，3，2的情况 1856. 子数组最小乘积的最大值 其实和前一题一样：把每个位置当成最小元素，向左向右找第一个小于当前元素的位置 907. 子数组的最小值之和 分析：$\\sum{RMQ(x,y)}$问题——所有固定末尾的RMQ的和值相加 思路：单调递增栈 ind为前面第一个比当前元素小的元素的下标 13行——以当前位置为结尾的RMQ问题的和值，是前n-1个和值+当前元素✖️区间跨度 （假设当前元素为区间最小值，往前找第一个比他小的元素，此区间跨度为当前元素作为最小值的跨度） 496. 下一个更大元素 I 456. 132 模式 1⃣️先记录每个i位置之前的最小值，记录在L数组中，至此我们可以获得足够大的区间m～i。 2⃣️我们需要找i位置后面是否存在数k满足m&lt;k&lt;i 3⃣️利用单调递减栈，寻找第一个大于i的数j，在i和j区间寻找是否存在小于i的最大值。 注意是从后往前遍历数组，val是最后一个被弹出的栈顶元素（如上图的k） 42. 接雨水","categories":[],"tags":[]},{"title":"单调队列","slug":"let_13_单调队列","date":"2021-11-10T13:55:48.000Z","updated":"2021-12-22T08:10:03.544Z","comments":true,"path":"posts/2132.html","link":"","permalink":"http://srymaker0.com/posts/2132","excerpt":"","text":"问题引入 RMQ(x, y)函数：查询数组$[x, y]$区间内部的最小值，参考RMQ——OI Wiki 如果固定询问区间的尾部，例如：RMQ(x,7) 最少记录如上4个蓝色元素，即可满足RMQ(x,7)的所有需求 并且这4个元素构成了一个单调递增的序列，也是单调队列 单调队列解决的就是这类维护区间最值的问题 [固定结尾的RMQ问题] 单调队列 要解决的问题性质：维护滑动窗口内部的区间最值 结构定义：单调的队列 结构操作 入队：先将队尾违反单调性的元素淘汰出局，再将当前元素入队 出队：如果队首元素超出了滑动窗口的范围，队首出队 维护的核心：队首元素——滑动窗口内的最值⭐ 最小值→递增队列 最大值→递减队列 均摊时间复杂度：O(1)，求解一次 [PS] 再举个例加深印象：学校选出学生代表去参赛 类比：年级-&gt;数组索引，能力值-&gt;数据值，时间段-&gt;滑动窗口 在维护区间[14-17]最大值的单调队列中，当你入队时，赵六就会被踢出 延伸：如果一个人年龄比你小，能力还比你强，那你就永远被踢掉了 单调栈 想想栈和队列的区别，而单调栈和单调队列的唯一区别也就在这，其它操作一致 [入队、出队] 单调栈是一头堵死的单调队列 单调栈保留了单调队列的入队操作，依然维护单调性⭐ 问题性质：最近（大于/小于）关系 入栈之前，符合单调性的栈顶元素，就是当前入栈元素的最近（大于/小于）关系 维护的核心： 栈顶元素 ——最近（大于/小于）关系⭐ 左侧最近关系→左侧先入栈 右侧最近关系→右侧先入栈 [PS] 其栈底是全局最小值，但用栈维护并没有意义 均摊时间复杂度：O(1)，求解一次 两者对比其实两者主要是形式上不同，但本质差不多 开放端口 维护核心 擅长问题 基本操作 单调队列 首、尾 队首 区间最值 维单+入队、出队、取值 单调栈 顶 栈顶 最近大小关系 出栈[维单]、取值、入栈 经典例题HZOJ-271：滑动窗口 样例输入 8 3 1 3 -1 -3 5 3 6 7 复制代码 样例输出 -1 -3 -3 -3 3 3 3 3 5 5 6 7 复制代码 思路 纯单调队列，关注代码实现 代码 思考：单调队列中是记录值还是记录【下标】 记录下标🆒，因为有了下标可以索引到值 [顺藤摸瓜] 记录值，却反向不可查 这是一个常用的单调队列模板：维护单调性→入队→出队→根据题意输出 关注最大/小值、窗口的大小 [PS] 队尾既可以入队，也可以出 [踢，维护单调性]，所以认为不是单向队列 HZOJ-372：双生序列 样例输入 5 3 1 5 2 4 5 2 4 3 1 复制代码 样例输出 4 复制代码 思路 思考：什么是两个序列的趋势相同？ 相同区间内部的RMQ值相同，❗ 这里RMQ值→最小值的最大下标 【关键】两个序列的每个区间的RMQ值相等👉两个序列的单调队列长得一样 换句话说，每时每刻，两个序列对应相同的单调队列 注意：长得一样，指的不是最小值，而是对应下标 [单调队列里存的是下标] 将两个序列的元素，依次插入到单调队列中，每次插入后比较单调队列的大小即可 ① 如果一致，继续入队 ② 如果不一致，输出答案 代码 用类定义单调队列，便于复用 单调队列里存的是下标：p 单调队列操作：维护→入队，都不需要出队 【巧妙】根据队列的大小变化把握趋势变化 239. 滑动窗口最大值 剑指 Offer 59 - II. 队列的最大值 思路 可维护两个队列，一个用于存储原数据，一个用于存储最大值（单调队列） 注意入队时的比较 &gt;，表示可记录重复元素，并且元素相对位置不会变，对于pop_front()操作，若q.front() 等于mq.front()则可以认为当前在q中删除的值也要在mq中删除 &gt;=, 表示不记录重复元素，但是在pop操作时要额外记录下标 单调队列是原队列的另一种信息表示方式 此题的窗口大小为整个数组 862. 和至少为 K 的最短子数组 思路 把原数组转化为前缀和数组——可以方便求区间和，求这个前缀和数组中的RMQ问题，单调队列维护数组中的最小值 每次遍历前缀和数组的时候，都减去当前位置之前的最小值 正确的分析思路——先分析我们需要得到什么样特点的数据，再对应我们所学的数据结构和算法 每次更新pos，都需要弹出q的首部元素，因为求的是最短队列，如果q队列中下一个元素不满足条件，则pos就是前一个位置 1438. 绝对差不超过限制的最长连续子数组 思路 假设在上图长度为L的区间中，找到一个min和一个max符合题意max-min &lt;= limit，也就是说在这段区间内无论怎么动只要包含这个min和max，长度可以为L-1， L-2，L-3… 但是L+1，L+2却不行（因为可能存在新的min和max也符合题意）——由此得出这是一个二分问题，也是111111000000的二分问题，需要找到最长的L。 二分的是长度，check函数表示在mid长度范围内是否存在有最大值-最小值小于limit，找最长的L 温故知新513. 找树左下角的值 135. 分发糖果 365. 水壶问题 这是一个模拟题 1760. 袋子里最少数目的球45. 跳跃游戏 II 93. 复原 IP 地址 46. 全排列 43. 字符串相乘 倒着存储","categories":[],"tags":[]},{"title":"深搜与广搜","slug":"let_12_深搜与广搜","date":"2021-11-03T13:36:39.000Z","updated":"2021-12-18T11:59:37.378Z","comments":true,"path":"posts/8160.html","link":"","permalink":"http://srymaker0.com/posts/8160","excerpt":"","text":"深搜与广搜核心概念 在思维逻辑层面——节点代表问题状态的树形结构 例如走迷宫问题 这里的状态就是小牛可以走到的位置——右边生成的就是问题求解树 解题的关键是定义状态 深搜与广搜 就是对问题求解树的不同遍历方式 搜索剪枝和优化 排除某些问题求解树中的子树遍历过程 设计搜索算法的核心关键点 设计问题求解树中的状态 刷题 go！993. 二叉树的堂兄弟节点 深搜版本 广搜版本 定义状态 把状态放入队列中 542. 01 矩阵 计算从0位置到每个1点的最少步数 1091. 二进制矩阵中的最短路径 752. 打开转盘锁 注意扩展状态，4个转盘，两个方向，难点在于这里 使用哈希存储deadends中的值，加快查找效率，也可以使用其进行去重 剑指 Offer 13. 机器人的运动范围 130. 被围绕的区域 采用逆思维，扫描边界O，搜索与其相邻的O，最后剩下的大O即为被X包围的 494. 目标和 记忆化——函数是展开的数组，数组是压缩的函数 473. 火柴拼正方形 39. 组合总和","categories":[],"tags":[]},{"title":"MySQL的使用","slug":"piH_02_MySQL","date":"2021-10-13T05:44:29.000Z","updated":"2021-11-03T02:00:31.592Z","comments":true,"path":"posts/0.html","link":"","permalink":"http://srymaker0.com/posts/0","excerpt":"","text":"MySQL的使用在云服务器上查看是否有MySQL 使用ps -ef | grep mysql👇 grep 其实本身就是一个命令。在执行 ps -ef | grep mysql 时，其实是起了一个 grep 的进程，所以你在这里看到了这个进程，它并不是 mysql 的进程。 更新系统一些资源【这些资源不更新有可能导致mysql或其他软件运行不了】 需要在root用户下 安装MySQL apt install mysql-server 安装完后可查看是否有mysql进程 初始化MySQL mysql_secure_installation 设置密码等级 移除匿名用户 禁止root用户远程登录 创建用户 @前面表示用户名，@后面表示指定ip地址，%表示任意ip。 设置用户权限 修改配置文件，注释掉绑定地址vim /etc/mysql/mysql.conf.d/mysqld.cnf 使用apt-cache serch mysql | grep dev找到对应的开发库，里面有一些MySQL的接口（C语言） 下载完后如下图可见mysql.h","categories":[],"tags":[]},{"title":"C/S文件传输软件的设计与实现","slug":"apage_08_packetsProblem","date":"2021-10-02T15:59:55.000Z","updated":"2022-01-03T06:46:57.269Z","comments":true,"path":"posts/b12c.html","link":"","permalink":"http://srymaker0.com/posts/b12c","excerpt":"","text":"C/S文件传输软件的设计与实现理解三个包需要明白这是出现在哪一层的设计 1、这应该是应用层的逻辑，tcp不会管这些数据是否是按协议规定的，tcp只需要达到发送条件(=size)发送即可 “TCP粘包”这个说法——在TCP传输协议下，应用层数据拼装发送和接收解析问题 2、Nagle算法解决的Small Packet Problem Nagle算法存在的原因 Small Packet Problem 在使用一些协议通讯的时候，比如Telnet，会有一个字节字节的发送的情景，每次发送一个字节的有用数据，就会产生41个字节长的分组，20个字节的IP Header 和 20个字节的TCP Header，这就导致了1个字节的有用信息要浪费掉40个字节的头部信息，这是一笔巨大的字节开销，而且这种Small packet在广域网上会增加拥塞的出现。 如果解决这种问题？ Nagle就提出了一种通过减少需要通过网络发送包的数量来提高TCP/IP传输的效率，这就是Nagle算法 参考： Nagle算法——CSDN 怎么解决TCP网络传输「粘包」问题？——知乎 我们这里其实设计的第一种“粘“👇——应用层数据拼装发送和接收解析问题 三个都可以看成是结构体，可以理解为某种约定好的协议 packet_pre——存放临时的数据包，其实可以和packet合二为一 packet_t——存放临时的数据包 packet——真正的数据包的大小 offset——偏移量 recv_size——接收大小——其实就是设计好的缓存大小 整包：$offset + recv_size = packet_size$ 收到的等于发送的 若收到一个整包，则直接交付给packet 拆包：$offset + recv_size &lt; packet_size$ 若收到这样的数据，则先将这部分数据交给packet，移动offset位置，然后接收到如下图的数据 此时由于数据过大，超出了packet的大小，需要将packet_t的数据做拆分处理（这就是所谓的“拆包”），大小为$packet_size - offset$ 将$packet_size - offset$大小的数据交给packet后，packet又满了，那么可以交给调用send()了，可剩下的数据咋办❓ 👇 将$recv_size - packet_size + offset$大小的数据先暂存在packet_pre中，之后再移交给packet 其实可以将packet_pre和packet合二为一，即等packet的数据全部交付完后，再把packet_t中剩下的数据移到packet中，但使用packet_pre方便理解 代码实现server端 client端 运行开两个终端，服务端运行./server port接收文件，客户端运行./client ip file传输文件 我这里把一个较大的图片由本地传到服务器上，可以发现ZYJ目录下的图片大小和本地的图片大小一样 一些文件IO的知识fread 其实这里的这个size困扰了我一会，为什么这个size要写成1，难道一次读很多个不好吗？ 👇即以下两者有啥区别 fread(a, 1, 1000, stdin); fread(a, 1000, 1, stdin); fread()返回的是能被读到的data elements的数量，而不是读到的字节，手册里也讲到👇 只有当size等于1时，返回的number才是字节数量 当以 fread(a, 1, 1000, stdin); 这种方式读取，若文件只有900字节，indicator会指向文件末尾，并返回900字节 若以fread(a, 1000, 1, stdin);读取，则返回值是未定义的，因为读不到一个大小为1000字节的元素 参考： How does fread really work?——stackoverflow fseek&amp;ftell 关于fclose 这里我想指出一点，其中fopen()返回的是一个文件指针，只不过底层还是会调用open()，打开一个文件描述符 参考： 文件描述符与文件指针——CSDN 为什么要调用fclose——CSDN tips关于视频流tcp与udp的问题——TCP vs UDP on video stream stream oriented VS message oriented—— TCP stream vs UDP message udp——发一个收一个 tcp——可以制定规则，可以发很多次，只接收一次。 多线程在单cpu中还是顺序执行的，所以在单核CPU上，不推荐使用多线程 参考对于多线程程序，单核cpu与多核cpu是怎么工作的——cnblogs","categories":[],"tags":[]},{"title":"Effective C++","slug":"apage_07_EffectiveC","date":"2021-09-19T13:13:48.000Z","updated":"2021-11-03T09:50:15.175Z","comments":true,"path":"posts/ec29.html","link":"","permalink":"http://srymaker0.com/posts/ec29","excerpt":"","text":"Effective C++刚开始看第一遍， 记录一些关键、有趣、不是很懂的地方 static&amp;const&amp;inlineconst多才多艺： 可修饰global或namespace作用域内的常量 被声明为static的对象 可修饰class内的static和non-static成员变量 修饰指针 修饰迭代器有讲究 修饰成员函数 可以使class接口容易被理解 哪个函数可以改动对象内容哪个不可以 可以操作const对象 两种概念——bitwise constness 和 logical constness bitwise：指成员函数只有在不更改对象之人和成员变量时才可以说是const logical：一个const成员函数可以修改它所处理的对象内的某些bits，但只有在哭护短侦测不出的情况下才可以——❗使用mutable关键字修饰你可以修改的变量 Static: static对象，寿命从被构造出来知道程序结束为止 在函数内的static对象称为local static， 其他的static对象称为non-local static对象 程序结束时static对象会被自动销毁 构造/析构/赋值运算析构函数：任何class只要带有virtual函数都几乎确定应该也有一个virtual析构函数。 若有继承关系，确没有vitual析构函数会造成局部销毁的bug，派生类只会销毁基类的对象 只有当class内含至少一个virtual函数，才为它声明virtual析构函数 STL容器都不被设计作为base classes使用 虚函数：virtual关键字修饰 在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class 隐式类型转换看到条款15懵b了 class Font { public: ... operator FontHandle() const { return f;} ... }; 看到这个我开始怀疑自己有没有学过C++了😢，我在想运算符重载还能这样写？后面查了资料才知道这并不是运算符重载 关于隐式类型转换的规则👇 接受单个实参的构造函数，定义了从形参类型到该类类型的一个隐式转换。 explicit关键字 类的构造函数被声明为explicit方式，可以用来阻止隐式类型转换，但被声明为explicit的构造函数依然可被用来执行显示类型转换。即，explicit构造函数必须显示调用。 资源管理以对象管理资源 将资源放进对象内，依赖c++析构函数自动调用机制确保资源被释放 RAII：资源取得时机便是初始化时机 智能指针 auto_ptr&amp;shared_ptrauto_ptr: 被销毁时自动删除所指之物，不能让多个auto_ptr指向同一个对象，否则该对象会被删除一次以上——未定义行为 若通过copy构造函数或copy assignment操作符复制auto_ptr，它们会变成null，而复制所得的指针将取得资源的唯一拥有权👇 shared_ptr: 被称为引用计数型智慧指针（RCSP），解决了auto_ptr的问题，可以用多个shared_ptr对象指向同一个对象 RAII class copying行为：有时候我们并不想删除对象，例如mutex这样的资源（当出现copy行为时并不合理），也许只是解除锁定 抑制copying shared_ptr有第二个参数——删除器（deleter） 通过get可以访问shared_ptr对象的原始指针 看如下的几个调用 int priority(); void processWidget(std::tr1::shared_ptr&lt;Widget&gt; pw, int priority); // 1、错误，shared_ptr构造函数需要一个原始指针 processWidget(new Widget, priority()); // 2、正确，但还是会造成资源泄露 processWidget(std::tr1::shared_ptr&lt;Widget&gt;(new Widget), priority()); // 3、完美 std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget); processWidget(pw, priority()); 对于第二种调用的第一个参数有两个步骤 执行“new Widget” 调用tr1:shared_ptr构造函数 而priority()的调用可能发生在这两步之间，若priority()的调用产生异常，则“new Widget”返回的指针将会遗失 解决办法是第三种调用，分两步执行。","categories":[],"tags":[]},{"title":"InnoDB索引","slug":"sql_04_索引","date":"2021-09-16T14:28:21.000Z","updated":"2021-09-23T13:29:38.532Z","comments":true,"path":"posts/a128.html","link":"","permalink":"http://srymaker0.com/posts/a128","excerpt":"","text":"索引 内存结构Change buff——针对次要索引 LRU——数据预热（yong， old） 优化","categories":[],"tags":[]},{"title":"脚本获取系统信息","slug":"piH_01_Script","date":"2021-09-13T05:44:29.000Z","updated":"2021-10-04T09:08:13.351Z","comments":true,"path":"posts/e826.html","link":"","permalink":"http://srymaker0.com/posts/e826","excerpt":"","text":"脚本获取系统信息MemLog最终效果： 显示：时间 总量 剩余量 当前占用 占用百分比动态平均值 使用free命令查看当前内存使用情况 -m表示单位为兆M 红框为我们需要的数据 代码演示 MemValue是一个数组，使用awk命令去获取total，used这两个值 MemPrec为当前占用率，NowDyAver为占用百分比动态平均值 利用bc命令去计算，scale=2表示保留2位小数 $ 动态平均值 = 0.8*加权平均值（上一次)+0.2当前占用比$​ Disk 最终效果： 使用df命令查看磁盘使用情况，-T表示类型 红框内是我们需要的，devtmpfs和tmpfs是虚拟内存文件系统 tmpfs是一种基于内存的文件系统，不像其他的文件系统需要格式化后才可以挂载，而是直接使用，由于是在内存中存储数据，那么在断电后会导致数据丢失。在使用到tmpfs文件系统存储数据效率会得到一定的提升。 devtmpfs 的功用是在 Linux 核心 启动早期建立一个初步的 /dev，令一般启动程序不用等待 udev，缩短 GNU/Linux 的开机时间 取得数据 tail -n +2——显示的第二条以后的数据 -x——表示过滤 代码演示 awk -v 表示定义一个变量 NR是awk内置变量——已经读出的记录数: 注意是从0开始 eval——eval的使用 先输出总的磁盘情况，再输出分区的磁盘情况 parnum里面存的是读到的记录数","categories":[],"tags":[]},{"title":"reactor反应堆","slug":"hc_02_reactor模型","date":"2021-09-12T10:39:02.000Z","updated":"2021-09-16T12:40:42.287Z","comments":true,"path":"posts/1fd0.html","link":"","permalink":"http://srymaker0.com/posts/1fd0","excerpt":"","text":"reactor Reactor thread : 反应堆线程——epoll实例，感知业务发生，直接给Thread Pool的线程做对应的工作 这里会引发几个问题： 1⃣️线程池中的线程量设计多少才合理？是越多越好吗？ 结论：不超过cpu核心数，要想性能最高，就让线程数等于cpu核心数 原因：若是超过了cpu核心数，那么线程池中的线程之间也会发生调度，尽管线程间调度消耗的时间很少，但还是付出了损失性能的代价 2⃣️既然不能超过cpu核心数，那主线程或者辅助的心跳线程放哪里呢？假设有8个cpu，是不是应该在线程池中设计6个呢？ 在我们设计这个反应堆模式时，线程池中处理的应该是繁忙的业务(由reactor分发过来的，ready状态的，无需等待)，应该要一直运行在cpu上的（cpu密集型） 主线程和心跳线程——IO约束型的，更多时候在sleep，可以插空执行， 3⃣️那既然这样，是不是意味着cpu越多，我处理并发的性能就越高呢？ 并不是，cpu越多，则任务在cpu中协调更困难（可靠性） 主从反应堆 类比：理发店问题 假设reactor dispatch为理发店老板，sub-reactor dispatch为合伙人，client为客户，Thread Pool为理发师。 现在老板拉来了3个客人，老板只负责分配任务交给两个合伙人（从反应堆），两个合伙人一个给男孩剪头，一个给女孩剪头（也就是说现在客户跟合伙人有关联），并且合伙人只负责维护这些客户，这些客户之后和老板没有直接关系，如果客户要剪头发了（任务，可放在任务队列中），那么通知合伙人，由合伙人再去通知理发师线程去抢生意（抢占任务） 假设客人要离开了，只需要通知合伙人就行，在合伙人这里进行删除，注销操作。 为什么需要从反应堆？ 因为主反应堆不够用，处理的能力不行，需要从反应堆分担压力 Tips什么是IO多路复用 什么是线程池，原理是什么，线程池设计多少的并发量比较适合，最大化使用应该设置为多少——线程池中的线程不能超过cpu核心数","categories":[],"tags":[]},{"title":"关于MySQL那点事儿","slug":"apage_04_关于MySQL那点事儿","date":"2021-09-11T11:28:44.000Z","updated":"2022-01-03T06:46:33.316Z","comments":true,"path":"posts/d4d4.html","link":"","permalink":"http://srymaker0.com/posts/d4d4","excerpt":"","text":"传送门1.关于MySQL架构 2.InnoDB的RC和RR隔离级别的实现 3.InnoDB与事务持久性","categories":[],"tags":[{"name":"Innodb","slug":"Innodb","permalink":"http://srymaker0.com/tags/Innodb/"}]},{"title":"IO多路复用","slug":"hc_01_select_poll_epoll","date":"2021-07-25T11:24:00.000Z","updated":"2022-01-03T06:45:56.186Z","comments":true,"path":"posts/0.html","link":"","permalink":"http://srymaker0.com/posts/0","excerpt":"","text":"IO多路复用❓为什么会出现IO多路复用 系统调用会带来额外的开销： 操作系统层面(准确)：作为用户程序如何调用系统资源 更宏观的层面：调用系统函数(system call) 内核态：执行特权指令 ｜ 用户态：执行非特权指令 从用户态到内核态：通过系统调用（主要）、中断、异常 高并发需要考虑系统调用的开销 因为从用户态下沉到内核态往往伴随着数据的拷贝，加上本身切换的时间成本，会影响性能，因此减少数据的拷贝次数是提高高并发性能的关键。 NIO（非阻塞IO）实现并发：在循环中采用轮询机制——同时和100个女朋友聊天，其中一个不理我，那就找下一个聊，过会再来看看(EAGAIN) 弊端，需要自己反复的查看，而没有一种通知机制 解决：使用IO多路复用 select 船长奇特类比：假设我拥有很多女朋友（文件描述符），每天只关心三件事，女友想跟我说话（可读），女友想听我说话（可写），女友想跟我分手（异常），select会在女朋友的思想里（内核中）监控，告诉你有多少女朋友想跟你说话、你可以跟她说话、或者要跟你分手（这三个都是就绪态），但是不会具体指出哪一个。此时我想知道是哪个女朋友能跟我进行对话（就绪），我只能去问select，并且是一个一个问三种状态（可选择）。 通过这个类比可以得出一些结论： select时间复杂度高：假设有1000个女朋友，只有第999个是就绪态的，那么我需要从第一个轮询到第999个 用户态和内核态都需要轮询 三种状态可以选择，若是只需要监听有哪些文件是可读的，只需要问一种状态即可，在较小的客户量下使用select完全可以处理过来 拷贝次数多：select执行先从用户态拿到需要监听的集合，然后下沉到内核态进行监听，接着返回给用户态有哪些文件描述符是就绪的，这里发生了两次数据拷贝行为 通过FD_ISSET去轮询 并发量有上限 原型 nfds: 文件描述符集合——底层使用数组维护，数量有一个上限，一般为1024 fd_set: 定义文件描述符的集合状态——可读，可写，异常 timeout: 时间间隔——一直等（NULL），等多久（&gt;0），立即返回（0） 四个宏操作集合 FD_CLR——从集合中删除一个文件描述符 FD_ISSET——查看一个文件描述符是否在集合中 FD_SET——添加一个文件描述符到集合中 FD_ZERO——清空集合 描述 select和 pselect 允许程序监视多个文件描述符，等待一个或多个文件描述符变成“ready”进行某类 I/O 操作 ready：就绪态，无阻塞的读或足够小的写 select和pselect的区别： 精度不一样：前者的timeval结构体使用秒和微秒，后者的timespec使用秒和纳秒 select 可能会更新超时参数以指示还剩多少时间。 pselect不会改变这个参数。 select没有 sigmask 参数，其行为与使用NULL sigmask调用的pselect 一样。 pselect可以忽略sigmask设置的信号 select监视三组独立的文件描述集合 可读的——文件描述符是否有内容 可写的——监视文件描述符中是否有可用空间写入 异常的——文件描述符是否存在异常 退出的时候，每个文件描述符集合会被修改，只留下状态发生变化的文件描述符，起指示作用 所以，如果循环使用select，每次调用select前需要重新初始化每个集合 nfds的值应该是最大文件描述符+1，因为文件描述符从0开始 使用select可以制作更加精确的计时器，并且可移植 nfds设置为0，三个集合设置为NULL，timeout非NUL 返回值 成功时，select() 和 pselect() 返回三个返回的描述符集中包含的文件描述符的数量（readfds、writefds、exceptfds） 如果超时，可能返回0 出错，返回-1 poll 本质上和select是一样的，只是底层数据结构不一样 继承了基本上select的所有缺点，除了最大文件描述符的限制 fds：一个结构体数组 nfds：数组大小 timeout：时间间隔 struct pollfd结构体成员 fd：打开文件的文件描述符 若为负数，events字段被忽略，revents返回0 events：输入参数，下沉到内核 16位的位掩码，每一位可表示一个状态 指定感兴趣的事件文件描述符fd revents：输出参数，返回给用户态 由内核填充实际发生的事件 返回包括事件中指定的任何值 还可以返回POLLERR,POLLHUP,POLLNVAL，这三个值在events中没有意义 标志位 POLLIN：可读标志位 POLLOUT：可写标志位 返回值 &gt;0: 返回一个revents字段不是0的结构体个数 可能包含events或者出错 =0: 超时或者没有文件描述符就绪 -1：出错，设置errno值 ⭐epoll描述 epoll——IO事件驱动设备 三个系统调用 epoll_create：创建一个实例，返回一个指向该实例的文件描述符 epoll_ctl：注册感兴趣的文件描述符 epoll_wait：等待IO事件，若当前没有可用事件，则一直阻塞 两种触发模式——水平触发（LT）、边缘触发（ET） man手册中举了一种情况解释边缘触发： 代表管道rfd读取端的文件描述符注册在epoll 实例上。 管道写入器在管道的写入端写入 2 kB 的数据。 调用epoll_wait将返回 rfd 作为ready的文件描述符。 管道读取器从 rfd 读取 1 kB 的数据。 完成对 epoll_wait 的调用。 如果此时使用边缘触发，则epoll_wait将一直阻塞在第5步中，原因是边缘触发仅在受监视的文件描述符发生更改时才传递事件。 在此例中，管道读取了数据，文件描述符发生了改变，并完成第5步。但是其实并没有把全部数据读取出来，并且在完成调用后文件描述符并没有发生改变，因此epoll_wait会一直阻塞 要避免这种情况发生，必须设置相应的文件描述符为非阻塞 epoll_creat描述 创建一个epoll实例 返回一个文件描述符指向该实例 当不需要使用文件描述符时，调用close关闭 当所有的文件描述符都关闭时，才销毁实例 返回值 返回一个非负的文件描述符 注意点 size的值 此参数会提示内核分配多少空间给events 但是在现在的内核中会忽略此参数，因为内核可以动态调用events需要的空间，填上此值只是为了兼容旧内核的程序 epoll_ctl epfd：是创建实例返回的文件描述符 op：对应三种操作——增，删，改 EPOLL_CTL_ADD：在文件描述符 epfd 引用的 epoll 实例上注册目标文件描述符fd并关联event EPOLL_CTL_MOD：更改与目标文件描述符fd关联的事件event EPOLL_CTL_DEL：从epfd引用的epoll实例中移除（注销）目标文件描述符 fd。 event events和poll中的events一样，都是位掩码 ❗但是返回的状态信息也在此events中修改，原来的状态可以在data中找回 data可以指向一个文件描述符指针，也可以等于一个文件描述符，很灵活 data中存储的是原fd的数据，可以通过data找回 返回值 成功，返回0. 失败，返回-1 epoll_wait 返回epfd指向的实例中的所有就绪文件描述符个数 events中存放的是ready的文件描述符 echo服务器的实现（C10k） thread.h thread.c tips思考点 epoll使用了mmap吗？ 对于mmap，在早起的Linux内核版本中，需要用户自己使用mmap将自己的文件描述符给内核空间，内核升级之后，这个过程不需要用户自己去做了。 早起需要用户去做，现在是epoll自己已经实现的，但是需要注意的是，这个只是对fd的映射，也就是在进行ready状态的fd传递的时候做，并不会映射其他的 网上有很多文章会把这个点误解为：epoll使用了mmap，所以当用户在read和write的时候，可以直接从内核中拷贝。但是实际是，在文件描述符的传递上，做了这个操作，不需要像select，poll一样来回传递，但是对于fd真实的IO操作，不可能做到这一点 select/poll每次调用时都要传递你所要监控的所有socket给select/poll系统调用，这意味着需要将用户态的socket列表copy到内核态，但是epoll就不用，因为在epoll-ctl时已经在内核态存储了需要监控的sock列表。 关于最大文件描述符，epoll真的可以无限存储吗？ select 的上限是默认是1024，这个值之所以默认是1024，是因为在早起的Linux中，默认打开最大文件数就是1024，所以FD_SETSIZE设置为1024,那么打开的文件数就不会超过1024。修改 FD_SETSIZE 重新编译内核可增大并发数，但因为 O(n) 轮询时间复杂度高治标不治本所以不采纳","categories":[],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://srymaker0.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"shell","slug":"apage_06_shell","date":"2021-07-13T04:35:58.000Z","updated":"2021-11-09T14:12:35.848Z","comments":true,"path":"posts/9924.html","link":"","permalink":"http://srymaker0.com/posts/9924","excerpt":"","text":"shell我们用的是bash解释器 写的脚本 创建👉 以.sh为文件结尾 执行👉 第一种 刚创建的1.first.sh没有可执行权限 chmod a+x 1.first.sh 输入上面的命令让所有人获得可执行的权限 接着可以输入./1.first.sh执行文件 第二种 bash 1.first.sh 直接用bash命令可以直接运行.sh文件 变量与局部变量 变量的定义 a=12 a=helloworld a=`pwd` #pwd是一个命令 ``这两个点是命令替换符 把命令的输出替换到``中去 再赋值gei a=$a:a 注意⚡： =号两边的空格不能省略 否则会被终端理解为是一个命令而不是变量 ''硬转义→将''内的直接解释成字符 \"\"软转义→在\"\"内的变量会被解释成原来的值 ==这是一种弱类型语言 a=123 可以理解为整型 也可以理解为字符 但是在系统中就认为a是一个普通变量== 在一个变量后面加上一个字符串 实际上做的是简单的字符串拼接 #!/bin/bash #这是注释 用#开始 #！这是固定格式 表示用什么解释器解释这个程序这里是用bin目录下的bash解释器 echo \"Hello shit of Ynnubs!\" WorkDir=`pwd` echo -e \"In\\033[31;32m ${WorkDir} \\033[0m\" ​ 局部变量 local a=12 特殊变量 位置变量：讲的是参数是怎么用的 我们用脚本语言应该也能传参 那么如何传参呢 如下图 我已经将arg1和arg2传进去了 只是我的程序并没有对参数进行处理 所以我要改写程序 #!/bin/bash #这是注释 用#开始 #！这是固定格式 表示用什么解释器解释这个程序这里是用bin目录下的bash解释器 echo \"Hello shit of Ynnubs!\" WorkDir=`pwd` echo -e \"In\\033[31;32m ${WorkDir} \\033[0m\" #-e是打开转义的意思 echo \"Program Name : $0\" echo \"Arg1 : $1\" echo \"Arg2 : $2\" echo \"Arg3 : $3\" echo \"Arg4 : $4\" echo \"Arg5 : $5\" echo \"Arg6 : $6\" echo \"\\$@ : $@\" # \\ 为转义字符 你懂的 和c语言一样的 echo \"\\$* : $*\" echo \"\\$# : $#\" 运行效果 ​ ​ ​ 输入输出 -p和-s用的最多 -t用的也挺多 若超过响应时间 会自动判定执行失败 输出：echo -e：开启转义 输出：printf 和C语言的printf非常像！ [PS] !和\\n放一起有特殊含义，需要分开 bash下需要分开 zsh下可以分开，或用\\转义 一般对于特殊符号——菜鸟教程，需要警觉！ 函数 #!/bin/bash #最好保留function 和() 增加可读性 function __printf__() { #两个下划线 echo \"$1\" return } __printf__ \"Hello shit of Ynnubs\" #这是函数的调用 没有形参 定义：写法很多，function、()、{}组合搭配，第3种更类似C语言写法 调用：函数名 参数… 加function方便阅读 ❗【注意】shell中函数return的返回值有限制，范围是0-255，溢出会循环换算 流程控制 if语句 建议写成这种形式 因为兼容性更强 #!/bin/bash read a #表示输入一个参数 个人感觉类似与scanf if [[ ${a} -gt 10 ]];then echo \"$a &gt; 10\" elif [[ ${a} -eq 10 ]];then echo \"$a = 10\" else echo \"${a} &lt; 10\" fi ​ [[ ]] 这个里面写的是test表达式 可以通过man手册查阅 可判断类型：字符串、整型、文件 ❗ 【注意】条件为真时，返回0，否则返回非0 Linux中命令的返回值也是如此，0才代表成功 [PS] STRING1 = STRING2 也可以用== 【推荐后者，两个中括号[[ ]]支持】 -G FILE：文件存在并且被有效组ID拥有 如果组被解散了，则组控制的文件的组ID就是无效的 我们再来举个例子 #!/bin/bash TargetFile=\"a.c\" if [[ -r ${TargetFile} ]];then # -r 文件存在并且可读 gcc a.c -o a # 编译a.c ./a # 执行 else echo \"${TargetFile} not Found!\" # 否则输出找不到 fi //a.c文件 #include &lt;stdio.h&gt; int main() { printf(\"Czpei is my son!\\n\"); return 0; } case语句 #!/bin/bash read a case $a in 1) echo 1 ;; 2) echo 2 ;; *) #默认情况 echo \"Not Found\" ;; esac 用的比较少 做菜单的时候可以使用case语句 循环 for两种形式 双小括号(())中的内容只要符合C语言运算规则即可，变量可以不使用变量前缀$，可以写i++，平常不可以用++ #!/bin/bash for i in $@;do #$@表示对所有参数 echo $i done for ((i=1; i&lt;=100; i++));do echo $i done while语句 #!/bin/bash num=0 while [[ $num -lt 100 ]];do echo ${num} num=$[ ${num} + 1 ] done until语句 直到 满足某个条件才会结束循环 #!/bin/bash num=0 until [[ $num -eq 100 ]];do echo $num num=$[ ${num} + 1 ] done for循环求偶数和 #!/bin/bash #for i in `seq 1 100` #seq表示生成1-100的序列 但是效率低下 因为seq是个进程 系统会每次调用 sum=0 for (( i=1; i&lt;=100; i++ ));do if [[ $[ ${i} % 2 ] -eq 0 ]];then sum=$[ ${sum} + ${i}] fi done echo \"sum = ${sum}\" 求素数和#!/bin/bash function Usage(){ echo \"Usage : $0 start_num end_num\" #$0获取当前执行shell脚本的文件名，包括路径 exit } function is_prime(){ num=$1 local i for (( i=2; i&lt;${num}; i++ ));do if [[ $[ ${num} % $i ] -eq 0 ]];then return 1 fi done return 0 } if [[ $# -ne 2 ]];then # $#得到执行当前脚本的参数个数 Usage fi Start=$1 End=$2 for ((i=${Start}; i&lt;=${End}; i++));do is_prime $i #函数的调用 if [[ $? -eq 0 ]];then sum=$[ ${sum} + $i ] fi done echo $sum ⚡注意这种方法求解素数效率低下 求10-20000 内的素数和 cpu就快爆了 但是利用算法是可以提高效率的 $+变量名 == 取值 调试 全局调试bash -x 局部调试 set -x #...代码段..# set +x 让我们先来了解下数组 声明 bash中对数组的一些操作 素数筛求解#!/bin/bash if [[ $# -ne 2 ]];then echo \"Error\" exit fi Start=$1 End=$2 declare -a Prime function init_prime() { local end=$1 # 此时的$1表示传进去的第一个参数 local i Prime[1]=1 for ((i=2; i&lt;=${end}; i++));do for ((j=$[ ${i} * ${i} ]; j&lt;=${end}; j+=i));do Prime[${j}]=1 done done } init_prime ${End} for ((i=${Start}; i&lt;=${End}; i++));do if [[ ${Prime[$i]}x == x ]];then #x表示字符串拼接 这句话判断Prime[i]是否为空 若为空 则为素数 sum=$[ ${sum} + ${i} ] fi done echo ${sum} 附加知识点 .sh脚本可以直接bash或source执行，如果要使用./需要有可执行权限 source、sh、bash、./有什么区别——cnblogs set -x可以开启shell调试 Shell命令替换：将命令的输出结果赋值给变量 ——C语言中文网 $() 支持嵌套，反引号``不行 $() 仅在 Bash 中有效 [似乎zsh、sh都支持]，而反引号``可在多种 Shell 中使用 双小括号(())中的内容 只要符合C语言运算规则即可 变量可以不使用变量前缀$ 可以写i++，平常不可以用++ ⭐在Shell中，变量还未定义时，其值为空，echo输出表现为空行 ⭐空格问题【严格】 赋值语句：=左右不能有空格 TEST表达式：[[ ]]两端必须有空格 对于变量名i，如果想将$i与_i拼接，用$i_i，会去找变量i_i，所以要用${i}_i Tips 写Shell脚本 不要太考虑性能，单纯做数学计算效率低 为的是快速解决一个问题，用来规划所有任务的流程 做操作前记得加【备份】操作 一般是让系统做事情，难于操作特定的程序做事情 程序一般有自己的参数设置，但不具有普适性 API一般指服务 ⭐Shell 风格指南——Google 开源项目风格指南——Shell编程规范 Shell脚本多行注释和单行注释的方法——博客 :&lt;&lt;! [要注释的代码] ! 复制代码 可以了解let——菜鸟教程，方便的语法","categories":[],"tags":[{"name":"shell","slug":"shell","permalink":"http://srymaker0.com/tags/shell/"}]},{"title":"哈希表与布隆过滤器","slug":"let_11_哈希表与布隆过滤器","date":"2021-07-10T11:44:23.000Z","updated":"2021-11-03T11:21:02.453Z","comments":true,"path":"posts/69d8.html","link":"","permalink":"http://srymaker0.com/posts/69d8","excerpt":"","text":"哈希表 哈希表是利用数组的快速存取的特性👉关键是利用哈希函数——设计感极强 哈希函数：将任意数据类型映射成数组下标，数据类型不同，映射过程也不相同 ⭐哈希的过程本质是 高维-&gt;低维的转换，哈希冲突一定会发生，但是可以通过很多方式预防这种冲突，但是这种冲突是无法避免的 冲突处理方法：开放定址法，再哈希法，建立公共溢出区，链式地址法（拉链法） 可查看中数据结构基础——C语言实验哈希过程 开放定址法 注意扩容操作——装填因子：$\\frac{存储元素个数}{哈希总容量}=0.75$ ，假设有100个容量存储数据，当容量为75个时就应该进行扩容操作 扩容的时间复杂度——算的是均摊时间复杂度$O(1)$, $\\frac{n}{2}+\\frac{n}{4}+\\frac{n}{8}+…\\approx n$ 估算：假设有n个元素，并且第一次发生扩容操作在$\\frac{n}{2}$处，那么第一次的时间复杂度为$\\frac{n}{2}$，依次类推所有元素进行的扩容操作为$O(n)$,但是算均摊，每一个元素进行的扩容操作为$O(1)$ 建立公共溢出缓冲区 当发生冲突，直接将元素放入set容器中（公共溢出缓冲区） set底层是红黑树，单次查找，插入时间复杂度都是$O(logn)$ 注意扩容的时候 缓冲区的值也要拷贝给新的哈希表 拉链法 布隆过滤器传统哈希表——存储空间与元素数量有关 布隆过滤器——存储空间与元素数量无关 关于爬虫：爬网站可以将这些存储在哈希表中，一样的url会被去重，但是动态网络的url可能非常庞大，使用传统哈希表存储可能占用几TB的存储空间 布隆过滤器的应用：大数据量；有信息安全要求(传统哈希表会存储数据，而布隆过滤器存的是二进制标志) 设计巧妙之处：一个数据经过3个哈希函数，得到3个数组下标，查找数组若这3个下标对应的值都为1，则说明这个数据❗大概率存在，若有一个是0，则一定不存在 缺点：存在误判，只能准确判断一个数据不存在 Leetcode环节705. 设计哈希集合 使用拉链法的思想 class Node { public: Node(int key = 0, Node *next = NULL) : key(key), next(next) {} int key; Node *next; void insert_after(Node *p) { p-&gt;next = this-&gt;next; this-&gt;next = p; return ; } void remove_after() { if (this-&gt;next == NULL) return ; Node *p = this-&gt;next; this-&gt;next = p-&gt;next; delete p; return ; } }; class MyHashSet { public: vector&lt;Node&gt; data; MyHashSet() : data(100) { } int hash_func(int key) { return key &amp; 0x7fffffff; } void add(int key) { if (contains(key)) return ; int ind = hash_func(key) % data.size(); data[ind].insert_after(new Node(key)); return ; } void remove(int key) { int ind = hash_func(key) % data.size(); Node *p = &amp;data[ind]; while (p-&gt;next &amp;&amp; p-&gt;next-&gt;key != key) p = p-&gt;next; p-&gt;remove_after(); return ; } bool contains(int key) { int ind = hash_func(key) % data.size(); Node *p = data[ind].next; while (p &amp;&amp; p-&gt;key != key) p = p-&gt;next; return p != nullptr; } }; 706. 设计哈希映射 此题只是多了一个key值 class Node { public: Node(int key = 0, int value = 0, Node *next = NULL) : key(key), value(value), next(next) {} int key, value; Node *next; void insert_after(Node *p) { p-&gt;next = this-&gt;next; this-&gt;next = p; return ; } void remove_after() { if (this-&gt;next == NULL) return ; Node *p = this-&gt;next; this-&gt;next = p-&gt;next; delete p; return ; } }; class MyHashMap { public: vector&lt;Node&gt; data; MyHashMap() : data(100) {} int hash_func(int key) { return key &amp; 0x7fffffff; }; void put(int key, int value) { int ind = hash_func(key) % data.size(); Node *p = &amp;data[ind]; while (p-&gt;next &amp;&amp; p-&gt;next-&gt;key != key) p = p-&gt;next; if (p-&gt;next) { p-&gt;next-&gt;value = value; } else { p-&gt;insert_after(new Node(key, value)); } return ; } int get(int key) { int ind = hash_func(key) % data.size(); Node *p = data[ind].next; while (p &amp;&amp; p-&gt;key != key) p = p-&gt;next; if (p == nullptr) return -1; return p-&gt;value; } void remove(int key) { int ind = hash_func(key) % data.size(); Node *p = &amp;data[ind]; while (p-&gt;next &amp;&amp; p-&gt;next-&gt;key != key) p = p-&gt;next; p-&gt;remove_after(); return ; } }; 面试题 16.25. LRU 缓存 封装哈希链表 需要频繁的插入删除——链表$O(1)$，由于需要找到对应到值（get）使用传统链表需要遍历，因此采用哈希表的方法存储一对值，查找效率接近$O(1)$ 链表设计为双向链表，因为需要找到待删除节点的前一个节点 535. TinyURL 的加密与解密 主要设计加密过程——映射过程如下👇 [0-25] - [‘a’-‘z’] [26-51] - [‘A’-‘Z’] [52-61] - [‘0’-‘9’] 通过随机生成的x值去生产字符 187. 重复的DNA序列 318. 最大单词长度乘积 巧妙的使用了位掩码 240. 搜索二维矩阵 II 右上角和左下角是两个特殊点 右上角是第一排最大的数，通过与target值比较，可以判断下一步的走向 在$n \\times m$的矩阵中最多走n+m步 979. 在二叉树中分配硬币 ❓解题思路：金币的流向是单向流通，没有必要双向，计算子树中的节点数量n和金币数量m的差值即为每条边流向子树的金币数等价为流向的次数 示例1中：根结点的左子树中有0个金币，1个节点，差值为1，即根节点需要流向左子树1个金币即可 430. 扁平化多级双向链表 863. 二叉树中所有距离为 K 的结点","categories":[],"tags":[]},{"title":"面向面试选择题之查漏补缺","slug":"面试选择题","date":"2021-06-20T12:25:54.000Z","updated":"2021-09-17T14:19:31.673Z","comments":true,"path":"posts/2dfc.html","link":"","permalink":"http://srymaker0.com/posts/2dfc","excerpt":"","text":"选择题包含Linux， 计算机网络，C++语法，操作系统，数据结构等方面的知识点，非常适合查漏补缺 这些错题个人感觉比较基础，对于操作系统知识需要加强，有一些个人不常见的Linux命令也会考到 ⭐需要了解对于图这样的数据结构，对于二叉树来说（结点=边数+1）经常考到 计算机网络考查最多的——TCP、UDP等一系列知识，需重点注意 选择题","categories":[],"tags":[]},{"title":"计算机网络概述","slug":"计算机网络概述","date":"2021-06-19T07:12:06.000Z","updated":"2021-06-20T06:20:46.770Z","comments":true,"path":"posts/2a8a.html","link":"","permalink":"http://srymaker0.com/posts/2a8a","excerpt":"","text":"计算机网络推荐书籍 《计算机网络——自顶向下方法》 视频理解 Youtube——How it works? Internet TCP/IP model explained, data transfer 以动画形式通俗易懂的解释访问网站数据包转移的过程 如何学习计算机网络 抱着认识计算机网络世界的心态学习 修炼的是内功，别想着学了计算机网络就能成仙！ 概述网络中心 可以理解为路由器 网络边缘 提供服务和享受服务的——家庭网络，移动网络（蜂窝），公司网络 边缘网络会通过某种形式进入互联网 DSL（数字用户线接入） 电话线和网线做频分复用 0-4k：电话线数据传输 4-50k：上传数据 50k-1M：下行数据 DSL调制解调器 FTTH 光纤到户 最常见的接入模式 以太网 公司，学校最常见——由机构ISP提供服务 拉的是专线（中国移动，联通，电信） OSI七层参考模型 参考模型 各层解释 对应设备 典型协议 协议数据单元 应用层 为应用程序提供服务 计算机 DHCP、DNS 报文message 表示层 数据格式转换、数据加密 计算机 Telnet、SNMP 报文message 会话层 建立、管理、维护会话 计算机 SMTP、SSH 报文message 传输层 建立、管理、维护端到端的连接 进程和端口 TCP、UDP 报文段segment、用户数据报 网络层 IP选址与路由选择 路由器、防火墙、多层交换机 IP、ICMP、ARP IP数据报 数据链路层 提供介质访问和链路管理 网卡、网桥、交换机 PPP、Internet 帧frame 物理层 物理层 中继器、集线器、网线 IEEE 802 比特bit 物理层 对信号和数据的传输——只有传输这一个作用，其它什么也不做 中继器：对信号的加强 数据链路层（注意与物理层的区分） 链路是人类抽象出来的，但是设备还是真实存在的 网卡（网络适配器）—— 可以对数据进行处理 网桥——用于网络与网络的连接 网络层 IP选址 对某个明确的地址编址，必须有某种明确的协议，并让所有人知道 告诉你一个真实的地址，我们可以从任何地方到达这个地址 路由选择 比如从新疆到杭州，有很多路可以走，但我们肯定会选择最优路径 防火墙 通过我这个地方的数据是符合我的要求的 交换机 二层交换机：在数据链路层 可以联想成一个村里的万事通，想找一个人，交换机会在记忆里寻找，若找到则会告诉你你要找的人的所在地 若找不到：会进行广播，在局域网里寻找这个人 多层交换机：在网络层 同样是找人，但是万事通在一个村里找不到这个人，就去找隔壁村的万事通 在两个村里可以进行交流 路由器（router） 家用的就是常见路由器 企业、学校：插满网卡，网线的设备，很多入口、出口 ⭐传输层——什么叫作端到端的连接 端到端-&gt;端口到端口的通讯 端口——房间号：可以理解为小区里的1单元1002号，但这个地址是局部的，全中国有很多个这个地址 比如两个人的通信，我在杭州某小区1单元1002号房间， 但是女朋友在北京某小区1单元1003号房间，看似隔得很近，但是却不在一个局域里，这时要想通信，就要先建立地址（具体到某条路什么小区）的连接（主机和主机）-&gt;经过网络层 进程：可以理解为房间内-&gt;进程空间 TCP：传输控制协议。UDP：用户数据报协议 应用层 给用户提供服务 为什么是参考模型 历史原因：创造网络的专家觉得应该设立一个标准，利于日后网络的维护，管理。 但是却缺乏实际的经验，并且缺乏商业驱动力 缺点：设计过于复杂，运行效率低，制定的周期长，划分不合理（有些重复） TCP/IP五层模型的出现（国际标准） 将应用层、表示层、会话层合并成应用层 简化了原来的模型 只有五层——物理、链路、网络、传输、应用 数据包的封装 从源到目的地的数据包到底经历了什么❓ 每一层都会给数据包打上一个标签（$H_t \\space H_n$等） 可以把这比作给女朋友写信，由应用层发起（M），信写好之后传给传输层，建立端到端的连接（写上女朋友的房间号$H_t$），接着经过网络层再进一步补充地址（某个城市某条路上的小区） 此时会判断女朋友是否在异地（外网还是内网） 方法：用子网掩码与IP地址做位与运算，比如我们要访问8.8.8.8，与子网掩码相与为8.8.8.0 不等于 192.168.1.0，此时就可以判断要访问的IP是外网 ok，现在就可以把信交给万事通了（此时为路由器），由路由器去选择路径，最后通过物理层传输到对方网关，然后进行数据包的解析，传到女朋友那！ 封装分层的好处 各层之间是独立的 灵活性好 结构上可分割开 易于实现和维护 能促进标准化工作 各层的功能 差错控制 流量控制 分段和复用 复用和分用 连接建立和释放 网络协议的组成要素 语法：数据与控制信息的结构 语义：发出何种控制信息做出何种动作 同步：事件发生的顺序，事件发生是由一定的顺序的 分组交换分组交换 把一个Message分成很多个小的Packet，让这些Packet自己决定选哪条路走，最后在一个目的地汇合 我们用TCP协议发送了一个数据，这个数据会分成很多个小的数据包，这些数据包不一定走一条路线 网络瞬息万变，可能一条路走不通就换条路 存储转发机制 目的：防止数据被篡改，确保接收到的数据是有效的 排队时延和分组丢失 排队时延：最不可控👉ping值 如果排队队列满：路由器会决定丢弃什么数据 ❓排队时延是如何产生的 假设家里是千兆网，而此时路由器带宽只有1.5Mbps，那么我们发的数据就会拥塞在路由器中（输出队列的排队），不能及时的发数据，就会产生分组丢失（丢包） 对于产生分组丢失：路由器会要求发送方重新发一个数据包 转发表、路由选择协议 当一个数据包传到路由器时，路由器会对数据包的地址和自身的转发表进行最长前缀匹配，若匹配到，则会重新进行封装，从这个链路传输出去 两者关系：路由选择协议会不断更新路由器的转发表 电路交换电路交换：端到端的连接 早期人类拨打电话 当线路被占满，其他人都不可用 真实的端到端的连接：有真实的线路 分组交换与电路交换的对比 分组交换提供了更好的带宽共享、灵活简单、实现成本低 再探时延 时延类型 时延量级 影响因素 结点处理时延 微秒或更低 处理器能力 排队时延 微秒到毫秒 流量的强度 传输时延 微秒到毫秒 带宽 传播时延 毫秒 距离远近 结点处理时延：解开标签的过程，很快 排队时延：对于网络的波动的参照 最不稳定、波动性大","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://srymaker0.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"mysql之基础篇","slug":"apage_05_mysql之基础篇","date":"2021-05-14T07:46:24.000Z","updated":"2021-11-09T14:12:31.525Z","comments":true,"path":"posts/3361.html","link":"","permalink":"http://srymaker0.com/posts/3361","excerpt":"","text":"mysql基础 mysql语言，多练才是王道！ 什么是mysql——from Wiki 使用可视化工具——Datagrip，提高开发效率 表的操作 SHOW DATABASES; use mysql; /* 选择数据库 */ SELECT database(); # 查看当前使用的数据库 SHOW TABLES; CREATE DATABASE mydb CHARACTER SET utf8mb4; # 创建数据库 CREATE DATABASE mydb2; CREATE DATABASE IF NOT EXISTS mydb2 CHARACTER SET utf8mb4; DROP DATABASE mydb; DROP DATABASE IF EXISTS mydb; # 删除数据库，先判断是否存在，这样不会报错 SHOW CREATE DATABASE mydb2; ALTER DATABASE mydb2 CHARACTER SET utf8mb4; # 修改数据库字符编码 -- 创建表student，字段包括 编号id、 姓名name、年龄age CREATE TABLE student ( id INT, name VARCHAR(100), age INT ); -- 创建表users，字段包括 编号id、 姓名username、密码password CREATE TABLE users ( id INT, username VARCHAR(100), PASSWORD varchar(100) ); SHOW CREATE TABLE users; /* CREATE TABLE `users` ( `id` int(11) DEFAULT NULL, `username` varchar(100) DEFAULT NULL, `PASSWORD` varchar(100) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; */ SHOW TABLES; DROP TABLE users; SHOW TABLES; -- 添加新的列 ALTER TABLE student ADD `desc` VARCHAR(100); SHOW CREATE TABLE student; -- 修改列的数据类型 ALTER TABLE student MODIFY `desc` VARCHAR(50); -- 修改列的名称 ALTER TABLE student CHANGE `desc` description VARCHAR(100); -- 删除指定列 ALTER TABLE student DROP description; -- 修改表的名称 RENAME TABLE student To stu; -- 修改表的字符编码 ALTER TABLE stu CHARACTER SET gbk; SHOW CREATE TABLE stu; -- 插入表记录 INSERT INTO stu(id, name, age) VALUES(1, 'tom', 24); INSERT INTO stu(name, age) VALUES('lili', 22); INSERT INTO stu(id, name, age) VALUES(3, 'jim', NULL); -- 插入多条记录 INSERT INTO stu VALUES(4, 'jack', 26); INSERT INTO stu VALUES(5, 'zhangsan', 26),(6, 'lisi', 27); INSERT INTO stu(id, name, age) VALUES (1, '李四', 20),(2, 'zhangsan', 30); -- 更新表记录 UPDATE stu SET name='lili', age=21 WHERE id=1; UPDATE stu SET age=25 WHERE age=27; -- 删除记录 DELETE FROM stu WHERE id=1; DELETE FROM stu WHERE age IS NULL; 查询必知必会系列 查询操作是工作中使用最多的操作 这部分需要大量练习 原始数据——products基于这张表做一些查询练习👇 简单查询 * ——通配符，查找效率慢👉一般项目开发中都写出所有的列​ DISTINCT——应用与所有列 条件限制 ❗注意Mysql中行号从0开始 分页查询语句——SELECT * FROM 表名 LIMIT startRow,pageSize; 后台根据当前页，自动计算开始的行号 排序SELECT 列名,... FROM 表名 ORDER BY 排序字段 ASC|DESC; 条件查询 SELECT prod_name,vend_id,prod_price FROM products WHERE vend_id =1001 OR vend_id=1002 AND prod_price&gt;10; 不加括号 SELECT prod_name,vend_id,prod_price FROM products WHERE (vend_id =1001 OR vend_id=1002) AND prod_price&gt;10; 加括号 模糊查询SELECT 列名,... FROM 表名 WHERE 列名 LIKE 条件; like语句中， %代表零个或多个任意字符，_代表一个字符 ❗通配符虽然好用， 但不要滥用， 尽量不要把%放在最前面， 比如：where like 因为这也搜索效率会很慢 正则表达式SELECT 列名 FROM 表名 WHERE 列名 REGEXP '条件'; 函数 这部分涉及到3张表——先前的products表以及下面两张 orderitems表 orders表 文本函数 日期函数DATE_ADD() 函数向日期添加指定的时间间隔。 格式：DATE_ADD(date,INTERVAL expr type) 解析：date 参数是合法的日期表达式。expr 参数是希望添加的时间间隔。 格式化时间 DATE_FORMAT() 函数用于以不同的格式显示日期/时间数据。 格式： DATE_FORMAT(date,format) date 参数是合法的日期。format 规定日期/时间的输出格式。 数学函数查询商品表， 并对商品价格进行四舍五入 SELECT round(prod_price) FROM products; 聚合函数我们经常需要汇总数据而不用把它们实际检索出来，为此MySQL提供了专门的函数。 聚集函数（aggregate function） 运行在行组上，计算和返回单个值的函数。 常见的聚合函数：👇 MAX() MAX() 函数返回指定列的最大值。 格式： SELECT MAX(column_name) FROM table_name; MIN() MIN() 函数返回指定列的最小值。 格式： SELECT MIN(column_name) FROM table_name; COUNT() COUNT() 函数返回匹配指定条件的行数。 COUNT(column_name) 函数返回指定列的值的数目（NULL 不计入）格式： SELECT COUNT(column_name) FROM table_name; COUNT(*) 函数返回表中的记录数（null也计入） 格式： SELECT COUNT(*) FROM table_name; SUM() SUM() 函数返回数值列的总数。 格式： SELECT SUM(column_name) FROM table_name; AVG() AVG() 函数返回数值列的平均值。AVG()函数忽略列值为NULL的行。 格式： SELECT AVG(column_name) FROM table_name; 分组查询 分组查询是指使用group by字句对查询信息进行分组。 格式：SELECT 字段1,字段2… FROM 表名 GROUP BY分组字段 HAVING 分组条件; 分组操作中的having子语句，是用于在分组后对数据进行过滤的，作用类似于where条 件。 having与where的区别: having是在分组操作执行后，对分组后的数据进行过滤；where是在分组操作执行前，对分组前的数据只能使用表原始列进行条件过滤 having后面可以使用聚合函数，where后面不可以使用聚合函数 当一条SQL语句中, 既有where又有group by \\ having时, 先执行where,再执行group by，最后执行having where要写在group by前面, 不然会报错 子查询 到为止我们所看到的所有SELECT语句都是简单查询，即从单个数据库表中检索数据的单条语句。 SQL还允许创建子查询（subquery），即嵌套在其他查询中的查询。 这里给出customers表 解析：首先，它将执行小括号内的子查询 SELECT order_num FROM orderitems WHERE prod_id=60005； 并返回三个订单编号 ：20005,20007,20009 然后，这三个值以IN操作符要 求的逗号分隔的格式传递给外部查询的WHERE子句。 外部查询变成：SELECT cust_id FROM orders WHERE order_num IN (20005,20007,20009); 在WHERE子句中使用子查询能够编写出功能很强并且很灵活的SQL语句。 对于能嵌套的子查询的数目没有限制，不过在实际使用时由于性能的限制，不能嵌套太多 的子查询。 提示：子查询一般与IN操作符结合使用，但也可以用于测试 等于、不等于。 组合查询UNION 操作符UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。默认：多个 SELECT 语句会删除重复的数据。（去重） 格式 SELECT 列名, 列名,... FROM tables [WHERE 条件] UNION [ALL | DISTINCT] SELECT 列名, 列名,... FROM tables [WHERE 条件]; 解析： DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没什么影响。 ALL: 可选，返回所有结果集，包含重复数据。（不进行去重） 案例假设现在我有两张表：customers、customers2，具有相同的表结构，里面各自存放着不同的数据，customers表里存放的是一月份的顾客数据，customers2表里存放的是二月份的顾客数据，现在我想查询一二月份所有顾客的数据。 知识小扩展： # 1.复制表结构及数据到新表 CREATE TABLE 新表 SELECT * FROM 旧表; # 2.仅复制表结构 CREATE TABLE 新表 SELECT * FROM 旧表 WHERE 1=2; # where后面是永远都不成立的条件 # 3.仅复制数据 INSERT INTO 新表(字段1,字段2,.......) SELECT 字段1,字段2,...... FROM 旧表; 分析过程 ❗第一条复制表语句并不会复制表的约束，使用LIKE可以 注意事项 UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）。 UNION中的每个查询必须包含相同的列、表达式或聚集函数（各个列不需要以相同的次序列出，但出于业务需求，通常会以相同的顺序列出）。 列数据类型必须兼容：类型不必完全相同，但必须是数据库可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。 UNION和OR比较：在SELECT语句相对复杂的情况下，使用UNION逻辑不容易混乱，比较清楚 多表操作外键现在我们有两张表“顾客表”和“订单表”，为了表明订单属于哪个顾客，通常情况下，我们将在订单表上添加一列，用于存放cust_id的信息，此列称为：外键。 外键（foreign key）：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。 主表（父表）：对于两个具有关联关系的表而言，相关联字段中的主键所在的那个表即是主表。 从表（子表）：对于两个具有关联关系的表而言，相关联字段中的外键所在的那个表即是从表。 外键特点： 从表外键的值是对主表主键的引用。 从表外键类型，必须与主表主键类型一致。 外键的作用⭐: 保证数据引用的完整性、一致性。 要考虑向从表添加数据时，外键字段必须是主表主键的引用，否则添加失败。 要考虑从主表中删除数据时，主键并未被从表引用，否则删除失败。 语法 -- 添加外键 alter table 从表 add [constraint][外键名称] foreign key (从表外键字段名) references 主表 (主表的主键); --[外键名称]用于删除外键约束的，一般建议“_fk”结尾 -- 也可以在建表时添加外键约束， --CONSTRAINT orders_customers_fk FOREIGN KEY (cust_id) REFERENCES customers (cust_id) -- 删除外键 alter table 从表 drop foreign key 外键名称 案例 # 添加外键 ALTER TABLE orders ADD CONSTRAINT orders_customers_fk FOREIGN KEY (cust_id) REFERENCES customers (cust_id); # 删除外键 ALTER TABLE orders DROP FOREIGN KEY orders_customers_fk; # 向主表添加数据 INSERT INTO customers (cust_id,cust_name) VALUES (666,'王老五');-- 成功 # 向从表添加数据 INSERT INTO orders(order_date, cust_id) VALUES (now(),666);-- 成功 # 向从表添加数据 INSERT INTO orders (order_date,cust_id) VALUES (now(),111);-- 失败 # 主表删除数据 DELETE FROM customers WHERE cust_id=666;-- 失败 表关系 实际开发中，一个项目通常需要很多张表才能完成。 例如：一个商城项目就需要顾客表(customers)、商品表(products)、订单表(orders)等多张表。 且这些表的数据之间存在一定的关系，接下来我们将在单表的基础上，一起学习多表方面的知识。 一对一关系 在实际的开发中不多.因为一对一可以创建成一张表. 常见实例：商品表和商品描述表 两种建表原则： 外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一unique。 外键是主键：主表的主键和从表的外键，形成主外键关系。 一对多关系 常见实例：客户和订单，分类和商品，部门和员工, 省份和城市 一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键. 多对多关系 常见实例：商品和订单，学生和课程，用户和角色 多对多关系建表原则：需要创建第三张表,中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键 # 1.添加外键 ALTER TABLE orderitems ADD CONSTRAINT orderiterms_orders_fk FOREIGN KEY (order_num) REFERENCES orders (order_num); ALTER TABLE orderitems ADD CONSTRAINT orderiterms_products_fk FOREIGN KEY (prod_id) REFERENCES products(prod_id); # 2.向订单表插入数据 INSERT INTO orders (order_num, order_date, cust_id) VALUES (101,now(),666); # 3.向商品表插入数据 INSERT INTO products (prod_id,prod_name,vend_id,prod_price) VALUES (101,'大刀',1002,100); # 4.向中间表插入一条数据（数据存在） INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price) VALUES (101,1,101,1,100); # 5.向中间表插入一条数据（数据不存在） 执行失败 INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price) VALUES (101,1,102,1,100);-- 产品表不存在102 INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price) VALUES (102,1,101,1,100);-- 订单表不存在102 # 6.删除商品表 执行失败 DELETE FROM products WHERE prod_id=101; 实战1：省和市 方案1：多张表，一对多 -- 创建省份表 create table province( pid int PRIMARY KEY, pname varchar(32), -- 省份名称 description varchar(100) -- 描述 ); -- 创建城市表 create table city ( cid int PRIMARY KEY, cname varchar(32), -- 城市名称 description varchar(100), -- 描述 province_id int, CONSTRAINT city_province_fk foreign key(province_id) references province(pid) ); 方案2：一张表，自关联一对多 create table area ( id int PRIMARY key AUTO_INCREMENT, `name` varchar(32), description varchar(100), parent_id int, CONSTRAINT area_area_fk FOREIGN KEY(parent_id) REFERENCES area(id) ); INSERT into area values(null, '辽宁省', '这是一个省份', null); INSERT into area values(null, '大连市', '这是一个城市', 1); INSERT into area values(null, '沈阳市', '这是一个城市', 1); INSERT into area values(null, '河北省', '这是一个省份', null); INSERT into area values(null, '石家庄市', '这是一个城市', 4); INSERT into area values(null, '保定市', '这是一个城市', 4); parent_id int多用于描述父子菜单 实战2：用户和角色 多对多关系 -- 用户表 create table `user` ( uid varchar(32) PRIMARY KEY, username varchar(32), `password` varchar(32) ); -- 角色表 create table role ( rid varchar(32) PRIMARY KEY, rname varchar(32) ); -- 中间表 create table user_role( user_id varchar(32), role_id varchar(32), CONSTRAINT user_role_pk PRIMARY KEY(user_id,role_id), CONSTRAINT user_id_fk FOREIGN KEY(user_id) REFERENCES `user`(uid), CONSTRAINT role_id_fk FOREIGN KEY(role_id) REFERENCES role(rid) ); 中间表用于维护这些角色 18行的user_role_pk是一个联合主键，同时关联了user_id,role_id 联合主键可以保证中间表可以有重复 ❗特别提醒现在这种创建外键的方式已经不提倡，甚至被禁止了，因为在维护数据时，限制条件太多，效率较低。关联关系通过SQL语句来实现。 事务 事务: 指的是逻辑上的⼀组操作,组成这组操作的各个单元要么全都成功,要么全都失败. 事务作⽤：保证在⼀个事务中多次SQL操作要么全都成功,要么全都失败. 比如：银行转账，小明有50元，小红有10元，小明向小红转账10元，在数据库操作中相当于执行了两条SQL语句 UPDATE account SET money=money-10 WHERE id=1;-- 小明账户减10元 UPDATE account SET money=money+10 WHERE id=2;-- 小红账户加10元 我们想让这两个操作要么全成功，要么全失败。如何保证呢？就需要把他们放到同一个事务里面进行操作。 # 创建账号表 create table account( id int primary key auto_increment COMMENT '主键', name varchar(20) COMMENT '姓名', money double COMMENT '余额' ); # 初始化数据 insert into account values (1,'小明',50); insert into account values (2,'小红',10); # MySQL有一个系统变量autocommit，用来自动提交事务。 SHOW VARIABLES LIKE 'autocommit'; # 默认是开启的，也就意味着在默认情况下，如果不显示地执行 START TRANSACTION 或者 BEGIN 开启一个事务，那么每条SQL语句都算是一个独立的事务，这种特性被称作事务的自动提交； # 如果想关闭这种自动提交的功能，可以使用两种办法 # 1. 显式使用START TRANSACTION 或者 BEGIN 开启一个事务 # 这样在本次事务中提交或者回滚前会暂时关闭自动提交的u # 2. 把系统变量 autocommit 设置为 OFF SET AUTOCOMMIT = off; 一旦开启一个事务，中间的sql语句都不会自动提交，需要自己手动提交【使用commit】 事务有四大特性（ACID）原子性（Atomicity）原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚， 一致性（Consistency）一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 隔离性（Isolation）隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 一个事务的执行不能被其他事务干扰。一个事务内部的操作及使用的数据，对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 关于事务的隔离性数据库提供了多种隔离级别。 持久性（Durability）持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 案例事务回滚 mysql&gt; begin; Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from account; +----+--------+-------+ | id | name | money | +----+--------+-------+ | 1 | 小明 | 50 | | 2 | 小红 | 10 | +----+--------+-------+ 2 rows in set (0.00 sec) mysql&gt; update account set money=money-10 where id =1; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; update account set money=money+10 where id =2; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; select * from account; +----+--------+-------+ | id | name | money | +----+--------+-------+ | 1 | 小明 | 40 | | 2 | 小红 | 20 | +----+--------+-------+ 2 rows in set (0.00 sec) mysql&gt; rollback; Query OK, 0 rows affected (0.01 sec) mysql&gt; select * from account; +----+--------+-------+ | id | name | money | +----+--------+-------+ | 1 | 小明 | 50 | | 2 | 小红 | 10 | +----+--------+-------+ 2 rows in set (0.00 sec) 事务提交 mysql&gt; begin; Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from account; +----+--------+-------+ | id | name | money | +----+--------+-------+ | 1 | 小明 | 50 | | 2 | 小红 | 10 | +----+--------+-------+ 2 rows in set (0.00 sec) mysql&gt; update account set money=money-10 where id=1; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; update account set money=money+10 where id=2; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; select * from account; +----+--------+-------+ | id | name | money | +----+--------+-------+ | 1 | 小明 | 40 | | 2 | 小红 | 20 | +----+--------+-------+ 2 rows in set (0.00 sec) mysql&gt; commit; Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from account; +----+--------+-------+ | id | name | money | +----+--------+-------+ | 1 | 小明 | 40 | | 2 | 小红 | 20 | +----+--------+-------+ 2 rows in set (0.00 sec) 隐式提交当我们使用start transaction或者begin语句时开启了一个事务。或者把系统变量的值设置为off时，事物就不会进行自动提交。 如果我们输入了某些语句，且这些语句会导致之前的事物，悄悄的提交（就像输入了commit命令一样），那么因为某种特殊的语句而导致，事务提交的情况称为隐式提交。 会导致隐式提交的语句有： 数据库定义语言DDL，像create、alter、drop 事务控制或关于锁定的语句，比如，前一个事务未提交，又开启了一个新的事务（写了两个begin） 加载数据的语句，比如load data（千万级的数据量会较快） 关于MySQL复制的一些语句 ：slave 保存点如果你已经开启了一个事物，并且输入了很多语句，这是忽然发现前面已经执行完的某个语句。参数写错了，只好使用rollback语句，让数据库状态恢复到事务执行之前的样子，然后一切从头再来。 这种感觉很不爽，因此就有了保存点的概念。 语法： -- 定义保存点 savepoint 保存点名称; -- 回滚到某个保存点，如果rollback后面不跟随保存点名称，则直接回滚到事务之前的状态 rollback [work] to [savepoint] 保存点名称 ; -- 删除保存点 release savepoint 保存点名称; 案例演示 mysql&gt; begin; Query OK, 0 rows affected (0.00 sec) mysql&gt; update account set money=money-10 where id =1; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; savepoint s1; Query OK, 0 rows affected (0.01 sec) mysql&gt; select * from account; +----+--------+-------+ | id | name | money | +----+--------+-------+ | 1 | 小明 | 40 | | 2 | 小红 | 10 | +----+--------+-------+ 2 rows in set (0.00 sec) mysql&gt; update account set money=money+1 where id =2; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 -- 回退到保存点 mysql&gt; rollback to s1; Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from account; +----+--------+-------+ | id | name | money | +----+--------+-------+ | 1 | 小明 | 40 | | 2 | 小红 | 10 | +----+--------+-------+ 2 rows in set (0.00 sec) 表关联查询表别名当表的名字很长或者执行一些特殊查询时，为了方便操作或者需要多次使用相同的表时，可以为表指定别名，以替代表原来的名称。 在为表取别名时，要保证不能与数据库中的其他表的名称冲突。 对单表做简单的别名查询通常是无意义的。一般是对一个表要当作多个表来操作，或者是对多个表进行操作时，才设置表别名。 当为表取别名后，列名前面最好都加上表的别名，做以区分。 SELECT p.*,v.vend_name FROM products p ,vendors v WHERE p.vend_id=v.vend_id; 使用表别名查询，可以使 SQL 变得简洁而更易书写和阅读，尤其在 SQL 比较复杂的情况下。除了使用别名来简化 SQL 外，有些时候例如一个表做自身关联时，必须要使用别名来当作两个表进行关联操作。 内连接 两表内联案例假设现在我想查询给我们供货的供应商的名称，以及商品名称和商品价格。此时我们发现，要查询的字段不在同一张表里。供应商名称在vendors表里，而商品名称和商品价格在products表里，这时可以使用内联查询，将两张表进行关联之后进行查询。 # 这里没有使用表别名 SELECT vend_name, prod_name, prod_price FROM products, vendors WHERE vendors.vend_id = products.vend_id; # 这种方式叫等值连接。当然也可以用表别名，来达到同样效果 SELECT v.vend_name, p.prod_name, p.prod_price FROM products p, vendors v WHERE p.vend_id = v.vend_id; # 这种连接方式也被称为内部连接，可以用以下语法来明确指定连接类型 -- inner可以省略 SELECT vend_name, prod_name, prod_price FROM products INNER JOIN vendors ON vendors.vend_id = products.vend_id; # 这两种方式都叫内连接，一种是隐式内联，一种是显示内联 这条语句的FROM子句列出了两个表，分别是vendors和products。它们就是这条SELECT语句联结的两个表的名字。这两个表用WHERE子句正确联结，WHERE子句指示MySQL匹配vendors表中的vend_id和products表中的vend_id。 课堂练习 编写SQL语句，返回customers表中的顾客名称cust_name 和orders表中的相关订单号order_num，并按顾客名称再按订单号对结果进行排序。 等值连接查询： SELECT cust_name,order_num FROM customers ,orders WHERE customers.cust_id=orders.cust_id; inner join 语法查询： SELECT cust_name,order_num FROM customers INNER JOIN orders ON customers.cust_id=orders.cust_id; 笛卡尔积在数据库表的定义中不存在能指示MySQL如何对表进行联结的东西。我们必须自己通过SQL做这件事情。 在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。WHERE子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行。没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。 笛卡儿积（cartesian product） 由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。 SELECT v.vend_name, p.prod_name, p.prod_price FROM products p, vendors v ORDER BY vend_name,prod_name; 从上面的输出中可以看到，相应的笛卡儿积不是我们所想要的。这里返回的数据用每个供应商匹配了每个产品，它包括了供应商不正确的产品。实际上有的供应商根本就没有产品。所以两表联查时，一定要注意where条件。 多表内联SQL对一条SELECT语句中可以联结的表的数目没有限制。创建联结的基本规则也相同。 案例假设现在要查询订单编号为20005的产品名称，产品价格、产品数量、供应商名称。该如何查询呢？ # 首先，先确认要查询的字段来自哪几张表？经分析可以得出，可以从orderitems、products、venders中获取数据 # 其次，再确定三张表的关联关系 # 然后，确定过滤条件 -- 隐式连接 SELECT prod_name, vend_name, prod_price, quantity FROM vendors, products, orderitems WHERE vendors.vend_id = products.vend_id AND products.prod_id = orderitems.prod_id AND order_num = 20005; -- 显示连接 SELECT prod_name, vend_name, prod_price, quantity FROM orderitems o JOIN products p ON o.prod_id = p.prod_id JOIN vendors v ON p.vend_id = v.vend_id WHERE o.order_num = 20005; 外连接左外连接 # 查询所有客户，的订单情况，包括没有订单的客户 SELECT customers.cust_id, orders.order_num FROM customers LEFT OUTER JOIN orders ON customers.cust_id = orders.cust_id; # OUTER 可以省略 右外连接在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）。 上面的例子使用LEFT OUTER JOIN从FROM子句的左边表（customers表）中选择所有行。为了从右边的表中选择所有行，应该使用RIGHT OUTER JOIN，如下例所示： SELECT customers.cust_id, orders.order_num FROM customers RIGHT OUTER JOIN orders ON customers.cust_id = orders.cust_id; 自连接案例假设你发现商品id为60001的商品存在质量缺陷，现在需要查找，60001供应商所提供的所有商品的名称和商品id。请问如何编写SQL语句？ 分析过程 # 1.使用现有的知识储备，子查询 SELECT vend_id FROM products WHERE prod_id=60001; SELECT prod_id,prod_name FROM products WHERE vend_id=1001; SELECT prod_id,prod_name FROM products WHERE vend_id=(SELECT vend_id FROM products WHERE prod_id=60001); # 2.采用自连接 SELECT p1.prod_id, p1.prod_name, p1.vend_id FROM products p1, products p2 WHERE p1.vend_id = p2.vend_id AND p2.prod_id = 60001; 课堂练习 使用innor join 编写SQL，查询每个顾客的名称，和所有订单号； SELECT cust_name,order_num FROM customers INNER JOIN orders ON customers.cust_id=orders.cust_id; 修改上一题的SQL语句，列出所有顾客，即使他们没有下过订单 SELECT cust_name,order_num FROM customers LEFT JOIN orders ON customers.cust_id=orders.cust_id; 使用outer join 连接products表和orderitems表，返回产品名称prod_name 和与之相关的订单号order_num的列表，并按商品名称排序。 SELECT prod_name,order_num FROM products LEFT JOIN orderitems ON products.prod_id = orderitems.prod_id ORDER BY prod_name; 修改上一题中创建的SQL语句，使其返回每一项产品的总订单数（不是订单号）。 SELECT prod_name, COUNT(order_num) AS orders FROM products LEFT OUTER JOIN orderitems ON products.prod_id = orderitems.prod_id GROUP BY prod_name ORDER BY prod_name; 编写SQL语句，列出供应商id（vend_id）及其可供产品的数量，包括没有产品的供应商。 提示：使用外连接和分组。 SELECT vendors.vend_id, COUNT(prod_id) FROM vendors LEFT OUTER JOIN products ON vendors.vend_id = products.vend_id GROUP BY vendors.vend_id; 视图视图作用视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。 就拿上节课查询订购了某个特定订单信息来说，任何需要这个数据的人都必须理解相关表的结构，并且知道如何创建查询和对表进行联结。 SELECT prod_name, vend_name, prod_price, quantity FROM orderitems o JOIN products p ON o.prod_id = p.prod_id JOIN vendors v ON p.vend_id = v.vend_id WHERE o.order_num = 20005; 为了检索其他产品（或多个产品）的相同数据，必须修改最后的WHERE子句。 现在，假如可以把整个查询包装成一个名为order_detail的虚拟表，则可以直接地检索出相应的数据： SELECT prod_name, vend_name, prod_price, quantity FROM order_detail WHERE order_num=20005; 在视图创建之后，可以用与表基本相同的方式利用它们。可以对视图执行SELECT操作，过滤和排序数据，将视图联结到其他视图或表，甚至能添加和更新数据。 重要的是知道视图仅仅是用来查看存储在别处的数据的一种设施。视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。 因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。所以不要滥用视图。 注意事项 与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。 对于可以创建的视图数目没有限制。 为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。 ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。 视图不能索引，也不能有关联的触发器或默认值。 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。 创建视图在理解什么是视图（以及管理它们的规则及约束）后，我们来看一下视图的创建。 视图用CREATE VIEW语句来创建。 使用SHOW CREATE VIEW viewname；来查看创建视图的语句。 用DROP删除视图，其语法为DROP VIEW viewname;。 更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。 #查询订单编号为20005的：产品名称，供应商名称，产品价格，购买数量 SELECT order_num,prod_name, vend_name, prod_price, quantity FROM orderitems o JOIN products p ON o.prod_id = p.prod_id JOIN vendors v ON p.vend_id = v.vend_id WHERE o.order_num = 20005; # 创建视图，包含所有订单的产品名称，供应商名称，产品价格，购买数量 CREATE VIEW order_detail AS SELECT order_num,prod_name, vend_name, prod_price, quantity FROM orderitems o JOIN products p ON o.prod_id = p.prod_id JOIN vendors v ON p.vend_id = v.vend_id; # 查看视图的所有数据 SELECT * FROM order_detail; # 从视图中过滤数据 SELECT * FROM order_detail WHERE order_num=20005; # 删除视图 DROP VIEW order_detail; 索引索引用于快速找出在某个列中有一特定值的行。不使用索引，MySQL必须从第1条记录开始读完整个表，直到找出相关的行。 表越大，查询数据所花费的时间越多，如果表中查询的列有一个索引，MySQL能快速到达。某个位置去搜寻数据文件，而不必查看所有的数据，这节课我们来介绍与索引相关的内容。 索引是对数据库中一列或多列的值进行排序的一种结构，使用索引可提高数据库中特定数据的查询速度。 索引是一个单独的存储在磁盘上的数据库结构，包含着对数据表里所有记录的引用指针。使用索引可以快速找出在某个或多个列中的某个值。所有MySQL列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径。 索引是在存储引擎中实现的，因此每一种存储引擎的索引，都不一定完全相同。 索引分类普通索引和唯一索引普通索引是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值。 唯一索引要求索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合，必须唯一。主键索引是一种特殊的索引唯一，不允许有空值。 单列索引和组合索引单列索引及一个索引只包含单个列，一个表可以有多个单列索引。 组合索引是指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。使用组合索引时遵循最左前缀原则。 创建索引创建表时创建 --普通索引 CREATE TABLE book( id int AUTO_INCREMENT PRIMARY KEY , bookname varchar(255) NOT NULL , INDEX (bookname) ); --唯一索引 CREATE TABLE book2( id int AUTO_INCREMENT PRIMARY KEY , bookname varchar(255) NOT NULL , UNIQUE INDEX (bookname) ); -- 给索引起名字 CREATE TABLE book3( id int AUTO_INCREMENT PRIMARY KEY , bookname varchar(255) NOT NULL , UNIQUE INDEX name_idx (bookname) ); 注意：index 和key是等价的 单独创建索引1.普通索引 CREATE INDEX index_name ON table_name (column_name); 2.唯一索引 CREATE UNIQUE INDEX index_name ON table_name (column_name); 3.组合索引 CREATE INDEX index_name ON table_name (column_name1,column_name2); 修改表结构创建 ALTER TABLE table_name ADD INDEX name_idx(column_name); 删除索引 ALTER TABLE table_name DROP INDEX index_name; DROP INDEX index_name ON table_name; 触发器MySQL的触发器和存储过程一样，都是嵌入到MySQL的一段程序。触发器是由事件来触发某个操作，这些事件包括INSERT,UPDATE和DELETE语句。如果定义了触发程序，当数据库执行这些语句的时候就会激发触发器执相应的操作，触发程序是与表有关的命名数据库对象，当表上出现特定事件时，将激活该对象。 触发器是个特殊的存储过程，不同的是，执行存储过程要使用CALL语句来调用，而触发器的执行不需要使用CALL语句来调用，也不需要手工启动，只要当一个预定义的事件发生的时候，就会被MySQL自动调用。 创建只有一个执行语句的触发器语法 CREATE TRIGGER trigger_name trigger_time trigger_event ON tab_name FOR EACH ROW trigger_stmt trigger_name：触发器名称，用户自行指定；trigger_time ：触发时机，可以指定为before或after；trigger_event：触发事件，包括INSERT,UPDATE和DELETE；tab_name：要建立触发器的表名；trigger_stmt：触发器执行语句。 CREATE TABLE book2( id int AUTO_INCREMENT PRIMARY KEY , bookname varchar(255) NOT NULL ); ALTER TABLE book ADD INDEX name_idx(bookname); # 创建触发器，在book表中插入一条数据时自动在book2中插入一条 CREATE TRIGGER book_insert_select AFTER INSERT ON book FOR EACH ROW INSERT INTO book2(bookname) SELECT bookname FROM book; INSERT INTO book(bookname)VALUES ('《平凡的世界2》'); # 查看触发器 SHOW TRIGGERS ; # 也可以在triggers表中查看触发器 SELECT * FROM information_schema.triggers; # 删除触发器 DROP TRIGGER book_insert_select; 创建有多个执行语句的触发器语法 CREATE TRIGGER trigger_name trigger_time trigger_event ON tab_name FOR EACH ROW BEGIN 语句执行列表 END trigger_name：触发器名称，用户自行指定；trigger_time ：触发时机，可以指定为before或after；trigger_event：触发事件，包括INSERT,UPDATE和DELETE；tab_name：要建立触发器的表名；这个可以在BEGIN，END之间包含多条语句。 示例 CREATE TRIGGER book_insert_select AFTER INSERT ON book FOR EACH ROW BEGIN INSERT INTO book2(bookname) SELECT bookname FROM book; INSERT INTO book3(bookname) SELECT bookname FROM book; END 存储过程简单的说存储过程就是一条或者多条语句的集合，可视为批文件，但是其作用不仅限于批处理。 1、创建存储过程 MySQL中，创建存储过程的基本形式如下： CREATE PROCEDURE 存储过程名 (参数列表) BEGIN SQL语句代码块 END 其中参数列表的形式如下： [IN|OUT|INOUT] param_name type 其中in表示输入参数，out表示输出参数，inout表示既可以输入也可以输出；param_name表示参数名称；type表示参数的类型，该类型可以是MYSQL数据库中的任意类型。 # 创建存储过程 CREATE PROCEDURE my_test() BEGIN SELECT * FROM book; END; # 调用存储过程 CALL my_test(); # 删除存储过程 DROP PROCEDURE my_test; # 创建存储过程 CREATE PROCEDURE my_test() BEGIN # declare 定义变量i DECLARE i int DEFAULT 0; WHILE i&lt;10 do INSERT INTO book (bookname) VALUES (concat('悲惨的世界',i)); SET i=i+1; end WHILE ; END; tipsdatagrip快捷键 代码格式化：ctrl+alt+L（Windows）/ cmd+opt+L（Mac） 快速执行：comman + enter（Mac） 查看表关系：右键一张表——点击最下面diagrams——点击show Visulization即可 推荐书籍 高性能MySQL MySQL技术内幕INNODB引擎","categories":[],"tags":[]},{"title":"面向面试简答题之查漏补缺","slug":"面试简答题","date":"2021-05-10T13:01:13.000Z","updated":"2021-07-13T04:46:17.861Z","comments":true,"path":"posts/79b0.html","link":"","permalink":"http://srymaker0.com/posts/79b0","excerpt":"","text":"面试是一个相互引导的过程，面试官会通过相应的问题来考察你的知识广度和深度，而你需要引导面试官你擅长的领域。 ——计算机网络——简述tcp3次握手三次握手 [SYN、ACK] 第一次握手：客户端发送SYN包到服务器[客户端进入SYN_SEND状态，等待服务器确认] 第二次握手：服务器收到，必须确认客户端，设置一个ACK，同时自己也设置一个SYN，即SYN+ACK包[服务端从LISTEN进入SYN_RECV状态] 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送ACK确认包，发送完毕后，客户端进入ESTABLISHED状态，服务器收到ACK后也进入ESTABLISHED状态 注意：每次的ACK序号，在需要确认的包的序号上加一，表示确认 简述tcp为什么要3次握手，为什么2次不行，4次可以么？首先网络是极其复杂且恶劣的环境，以至于设计出了tcp这样的可靠传输协议，全双工的协议，一条连接的建立，有去必有回才算建立 先来看一次握手为什么不行，这当然是行不通的，假设客户端A传一个包给服务端B，此时建立一条连接，而B没有应答，在这个过程中可能出现了丢包的情况，A就无法确认数据包是否送达，有去无回，此时A自然认为自己无法正确连接B。 为什么2次不行：同样，客户端A想从服务端B请求数据，发了一个数据包，此时A与B建立一条连接（第一次握手），B收到了A的请求并给A一个应答，此时又建立了一条连接（第二次握手），若就这样结束，因为中途数据包可能丢失，或者因为A结束了与B的连接，那么B也无法判断我建立的这条连接是否能正确的发送数据包，也就无法断定是否建立了与A的连接。——B发了但是没收到应答，不算建立成功 4次可以么？：是可以的，但是没有必要，对A来讲，若B给了一个响应，那么A认为自己是可以连接到B的，同样的，若B给了A应答后收到了A的应答，那么B认为连接建立成功，这样A与B就可以正常通信了。对于4次握手来说，可能对于B应答的应答（第三次握手）这样的数据包在网络中可能丢失，B会再次传送一个应答，来尝试是否能与A进行连接，但这是网络原因，只要B收到了A的应答，那么就是可以进行正确的连接，4次握手可以，但是没有必要，还是无法保证网络的稳定性 ⭐扩展：TCP建立连接的过程中还要确认数据包的序号，防止接受不需要或者不想传的包——A与B建立了连接（发送数据包后），此时A直接断开，但是数据包在网络上流离，此时A又与B重新建立连接，由于网络的时延性，B很有可能收到在网络上流离的数据包，那么这样就不是我们想要的数据。 所以要确认数据包的序号，这个序号是随着时间的变化而变化的，若是要收到相同序号的包，则需要4个小时，由于存在TTL，那些数据包早就灰飞烟灭了 简述从输入网址到浏览器显示的过程 这个问题非常经典，但还是会经常问，因为考察你对计算机网络知识的广度，然后面试官再进一步问你更深入的问题 总的来说整个过程如下： DNS解析：将域名解析成IP地址 本地hosts，本地DNS解析器缓存 本地DNS 迭代/递归：根DNS服务器，顶级DNS，权威DNS 直到找到域名对应的IP TCP连接：TCP三次握手（可以阐述为什么需要3次握手？） 发送HTTP请求——请求方法、URL、HTTP版本 服务器处理请求并返回HTTP报文 解析用户请求，知道了需要调度哪些资源文件，并调用数据库信息，返回给浏览器客户端 返回响应结果——一般会有一个HTTP状态码，比如200、301、404等，通过这个状态码我们可以直到服务器端的处理是否正常，并能了解具体的错误 浏览器解析渲染页面 断开连接：TCP四次挥手 ⭐上述过程如有不熟悉的，应当加以了解，这是计算机基础 TCP与UDP有哪些区别？ TCP是面向连接的，实现数据可靠传输，拥有拥塞控制等流量控制算法，会根据网络环境调节传输速度，比较复杂。 TCP四次挥手的过程是什么样的？ 四次挥手 [FIN、ACK] 第一次挥手：假设客户端想要关闭连接，客户端发送一个FIN包，表示自己已经没有数据可以发送了 [此时仍然可以接收数据][客户端进入FIN_WAIT_1状态] 第二次挥手：服务端回复一个ACK包，表明自己接收到了客户端关闭连接的请求，但自己还需要做些准备来关闭连接[服务端进入CLOSE_WAIT状态] 客户端接收到这个ACK后，进入FIN_WAIT_2状态，等待服务端关闭连接 第三次挥手：服务端准备好关闭连接时，向客户端再发送FIN[服务端进入LAST_ACK状态，等待客户端的确认] 第四次挥手：客户端接收到来自服务器端的关闭请求，发送一个ACK包[客户端进入 TIME_WAIT状态，为可能出现的超时重传的FIN包，等待2个MSL时间] 服务端接收到这个ACK之后，关闭连接，进入CLOSED状态 客户端等待了2个MSL后，如果没有收到服务端的FIN，则认为服务端已经正常关闭连接，于是自己也关闭连接，进入CLOSED状态；否则，再次发送ACK 参考三次握手与四次挥手——博客 [注：第四次挥手客户端等待的是超时重传的FIN而不是ACK] 附加：2个MSL的含义TIME_WAIT是如何引起的，有什么作用，在编程时有什么弊端，怎么解决？ 引起原因：TCP的四次挥手时，已经完成前三次挥手，在第四次挥手时，客户端收到来自服务端的FIN，它在发送一个ACK后，就会进入TIME_WAIT状态 此时客户端需要等待两个最大数据段生命周期（Maximum segment lifetime，MSL）的时间之后，才会进入CLOSED状态 存在原因 ①阻止延迟数据段 每一个TCP数据段都包含唯一的序列号，这个序列号能够保证TCP协议的可靠 为了保证新TCP连接的数据段不会与还在网络中传输的历史连接的数据段重复，TCP连接在分配新的序列号之前需要至少静默数据段在网络中能够存活的最长时间，即MSL 从而防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的TCP连接收到 ②保证连接关闭 如果客户端等待的时间不够长，当服务端还没有收到ACK消息，而客户端重新与服务端建立TCP连接时，会发生： 服务端因为没有收到ACK消息，所以仍然认为当前连接是合法的 客户端重新发送SYN消息请求握手时，会收到服务端的RST消息，连接建立的过程被终止 所以要保证TCP连接的远程被正确关闭，即等待被动关闭连接的一方收到FIN对应的ACK消息 编程影响 对于高并发的场景容易出现过多的TIME_WAIT 而MSL的时长一般是60s，这是难以接受的，可能一个TCP连接只为了通信几秒钟，但TIME_WAIT就需要等待2分钟 解决方式 基于一个时间戳变量，记录发送数据包、最近一次接收数据包的时间 然后配合两个参数 reuse：允许主动关闭连接的一方，再次向对方发起连接的时候，复用处于TIME_WAIT状态的连接 recycle：内核会快速回收处于TIME_WAIT的连接，只需等待RTO时间 [数据包重传的超时时间] 参考 为什么 TCP 协议有 TIME_WAIT 状态——博客 系统调优你所不知道的TIME_WAIT和CLOSE_WAIT——知乎 理解TIME_WAIT，彻底弄清解决TCP: time wait bucket table overflow——亿速云 什么是HTTPS的SSL认证？ 参考——HTTPS 与 SSL 证书概要 ——C/C++相关——C++为什么不像JAVA一样有垃圾回收机制垃圾回收机制——在JAVA中，我们对资源的申请不需要人为的手动释放，JVM会自动释放这些资源 C++中有RAII（Resource Acquisition is Initialization——资源获取即初始化）技术管理资源 在构造函数中申请分配资源，在析构函数中释放资源——这是C++语言机制保证的，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数，所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。 C++中智能指针就利用这样的思想，实现自动的内存管理 可参考C++RAII介绍 map和unordered_map的区别两者底层实现不同：map——红黑树，unordered_map——哈希表 map：为什么要使用红黑树实现，用其它的呢？ 因为对于单次增删改查操作的时间复杂度都为$O(logn)$ 红黑树是二叉查找树，中序遍历可以有序输出 对比BST（binary_search_tree）和AVL——BST会退化为链表，排除；而AVL由于其有严格的平衡条件，每次操作可能花费的时间都在平衡上了，影响效率，不适合 Unordered_map 哈希表使用拉链法解决哈希冲突，拉链的数据量超过8会使用拉链法，否则自动退化使用红黑树 Unordered_map查询时间复杂度可能做不到$O(1)$，因为其存在退化 做不到数据有序 C++ STL sort的实现可参考 数据结构力扣刷题集——7.快速排序+优化 const关键字的作用修饰变量——该变量不能被改变 修饰指针——指针常量和常量指针 修饰引用 形参引用使用const修饰：foo(const int &amp;a)，这样修饰表示传递过程中不会对值进行修改？ 修饰成员函数 成员函数不会对成员变量进行修改 static关键字的作用修饰普通变量 修改变量的存储区域（变为静态区）和生命周期 修饰普通函数 仅在该函数的文件内可使用——多人开发中常见，两个人在A文件与B文件写了同名函数的情况，比如用static修饰A文件的同名函数可以别人使用你在A文件内的这个函数 修饰成员变量 对很多实例来说，被static修饰的成员变量只有一个，这么多的实例其实共享一个static成员变量（跟着类走的） 修饰成员函数 不需要生成对象就可以访问该函数（跟着类走的） 函数内部不能访问非static的成员属性 ——操作系统相关——什么是虚拟内存？说一下零拷贝技术","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://srymaker0.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"数据结构基础——C语言实现","slug":"apage_02_数据结构基础——C语言实现","date":"2021-05-08T02:45:53.000Z","updated":"2021-11-09T14:12:24.428Z","comments":true,"path":"posts/73f4.html","link":"","permalink":"http://srymaker0.com/posts/73f4","excerpt":"","text":"程序 = 算法 + 数据结构 程序设计 = 算法 + 数据结构 + 编程范式 算法解决的是计算机的计算资源 而数据结构解决的是计算机的存储资源 解决这两个问题才是一个好的程序 这也就是为什么要学习数据结构的原因 ⚡数据结构 = 结构定义 + 结构操作 (对于什么是数据 后面会有更深的理解) 顺序表一种功能更为高级的一种数组 它需要开辟一段连续的空间并且空间的每个位置可以存储任意类型 size表示顺序表的大小 length表示当前元素的个数 data_type表示元素的类型 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define COLOR(a, b) \"\\033[\" #b \"m\" a \"\\033[0m\" #define GREEN(a) COLOR(a, 32) typedef struct Vector { int *data;//指向的是一段自己开辟的类型的空间的首地址 int size, length; } Vec; Vec *init(int n) { Vec *v = (Vec *)malloc(sizeof(Vec)); v-&gt;data = (int *)malloc(sizeof(int) * n); v-&gt;size = n; v-&gt;length = 0; return v; } int expand(Vec *v) { int extr_size = v-&gt;size; //return v-&gt;data = (int *)realloc(v-&gt;data, sizeof(int) * (v-&gt;size + extr_size)); int *p; while (extr_size) { //realloc会自动将原来的空间回收掉 p = (int *)realloc(v-&gt;data, sizeof(int) * (v-&gt;size + extr_size)); //如果p不为空地址 则我们开辟成功 直接break退出循坏 否则一直开辟原来的1/2倍 if (p) break; extr_size &gt;&gt;= 1; } //如果extr_size == 0 则说明真的开不下了 直接返回0值 if (extr_size == 0) return 0; v-&gt;data = p; v-&gt;size += extr_size; return 1; } int insert(Vec *v, int val, int ind) { if (v == NULL) return 0; if (ind &lt; 0 || ind &gt; v-&gt;length) return 0; if (v-&gt;length == v-&gt;size) { if (!expand(v)) return 0; printf(GREEN(\"success to expand! the Vector size is %d\\n\"), v-&gt;size); } for (int i = v-&gt;length; i &gt; ind; i--) { v-&gt;data[i] = v-&gt;data[i - 1]; } v-&gt;data[ind] = val; v-&gt;length += 1; return 1; } int erase(Vec *v, int ind) { if (v == NULL) return 0; if (ind &lt; 0 || ind &gt;= v-&gt;length) return 0; for (int i = ind + 1; i &lt; v-&gt;length; i++) { v-&gt;data[i - 1] = v-&gt;data[i]; } v-&gt;length -= 1; return 1; } //动态开辟空间需要自己手动释放 避免内存泄漏 void clear(Vec *v) { if (v == NULL) return; free(v-&gt;data); free(v); return ; } void output(Vec *v) { if (v == NULL) return; printf(\"Vector : [\"); for (int i = 0; i &lt; v-&gt;length; i++) { i &amp;&amp; printf(\", \"); printf(\"%d\", v-&gt;data[i]); } printf(\"]\\n\"); return ; } int main() { srand(time(0)); #define max_op 20 Vec *v = init(2); for (int i = 0; i &lt; max_op; i++) { int val = rand() % 100; int ind = rand() % (v-&gt;length + 3) - 1; int op = rand() % 4; switch (op) { case 1: case 2: case 0: { printf(\"insert %d at %d to Vector = %d\\n\", val, ind, insert(v, val, ind)); } break; case 3: { printf(\"erase a iterm at %d from Vector = %d\\n\", ind, erase(v, ind)); } break; } output(v); printf(\"\\n\"); } clear(v); return 0; } malloc动态内存申请 malloc只是划分一个空间告诉你这个空间是可以用的 成功时，返回指向新分配内存开头的指针。 为了避免内存泄漏，必须使用free（） 或 realloc（）释放返回的指针。 失败时，返回一个空指针。 而calloc在开辟空间的时候会将这段空间清0或者是空地址 realloc(地址,大小)指的是重新给你分配一段空间 第一个参数传进去一个地址 是我们要对哪片空间进行重新划分 而这片空间的首地址就是我们的第一个参数 第二个参数是 将现在的这片空间扩大多大的字节数 返回值是新开辟出来的空间的首地址 可以在原来的基础上开辟额外的空间 如果还是存不下则会返回NULL值 此时必须格外注意， 不能让原数据域指向它 如果开辟了额外空间还是存不下 则会重新分配一段和原空间一样大的空间并且扩大两倍 不过我们在这里让它扩大原来的1/2倍 链表 链表可以分为两部分 程序内部 这里指的就是头指针 我们在程序内部能看到的只有头指针所连接的链表 我们可以通过头指针去操作链表 内存内部 这部分是链表的本质 在逻辑上如上图一样 最后一个节点的指针域为NULL 单向链表的指针域又名“后继”；双向链表有“前驱”和“后继” 对于普通的链表中的指针域 我们称之为后继（当前指针域指向后面节点的地址） 插入 ①走到待插入位置的前一个位置的节点p ②先将新的节点x的指针域指向待插入位置的节点p.next ③将p的指针域指向新的节点x 顺序不能变！否则可能引发内存泄漏（你想用已经用不了，但系统却以为你在用） 删除 走到待删除节点位置的前一个位置 翻转 方法一 用一个新链表存，使用头插法 不断在index = 0 的位置插入节点 不足：浪费空间，麻烦 方法二 原地翻转，用两个变量倒，也是头插法 前提：每次操作不要造成内存泄漏 NULL地址还是在最后面，不会翻转 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define COLOR(a, b) \"\\033[\" #b \"m\" a \"\\033[0m\" #define GREEN(a) COLOR(a, 32) //链表的结构定义 typedef struct ListNode { int data; struct ListNode *next;//struct 结构体类型关键字 虽然我们重命名了ListNode 但是12行还没有生效 } ListNode; //链表整体的结构定义 typedef struct List { //ListNode *head;//头指针 因为插入的原则是 在待插入元素前进行插入 当链表为空时 很不好操作 ListNode head;//虚拟头节点 为了方便插入和删除第一个元素 int length; } List; //链表的结构操作 //初始化 ListNode *getNewNode(int); List *getLinkList(); void clear_node(ListNode *); void clear(List*); int insert(List *, int, int); int erase(List *, int); void output(List *); void reverse(List *); int main() { srand(time(0)); #define max_op 20 List *l = getLinkList(); for (int i = 0; i &lt; max_op; i++) { int val = rand() % 100; int ind = rand() % (l-&gt;length + 3) - 1; int op = rand() % 4; switch (op) { case 0: case 1: { printf(\"insert %d at %d to List = %d\\n\", val, ind, insert(l, ind, val)); } break; case 2: { printf(\"erase a iterm at %d from List = %d\\n\", ind, erase(l, ind)); } break; case 3: { printf(GREEN(\"reverse the list!\\n\")); reverse(l); } break; } output(l), printf(\"\\n\"); } #undef max_op clear(l); return 0; } ListNode *getNewNode(int val) { ListNode *p = (ListNode *)malloc(sizeof(ListNode)); p-&gt;data = val; p-&gt;next = NULL; return p; } List *getLinkList() { List *l = (List *)malloc(sizeof(List)); l-&gt;head.next = NULL;//因为虚拟头节点是一个没有实际意义的节点 所以虚拟头节点指向的后面的那个节点才是真的头节点 l-&gt;length = 0; return l; } int insert(List *l, int ind, int val) { if (l == NULL) return 0; if (ind &lt; 0 || ind &gt; l-&gt;length) return 0;//下标是0 ~ length-1 ListNode *p = &amp;(l-&gt;head), *node = getNewNode(val); while (ind--) p = p-&gt;next; node-&gt;next = p-&gt;next; p-&gt;next = node; l-&gt;length += 1; return 1; } int erase(List *l, int ind) { if (l == NULL) return 0; if (ind &lt; 0 || ind &gt;= l-&gt;length) return 0; ListNode *p = &amp;(l-&gt;head), *q; while (ind--) p = p-&gt;next; q = p-&gt;next; p-&gt;next = q-&gt;next; free(q); l-&gt;length -= 1; return 1; } //链表原地翻转 先将头节点指向空 用p 和 q去维护整个链表 void reverse(List *l) { if (l == NULL) return; ListNode *p = l-&gt;head.next, *q; l-&gt;head.next = NULL; while (p) { q = p-&gt;next; p-&gt;next = l-&gt;head.next; l-&gt;head.next = p; p = q; } return ; } void output(List *l) { if (l == NULL) return ; printf(\"List(%d) = [\", l-&gt;length); for (ListNode *p = l-&gt;head.next; p; p = p-&gt;next) { printf(\"%d-&gt;\", p-&gt;data); } printf(\"NULL]\\n\"); return ; } void clear_node(ListNode *node) { if (node == NULL) return; free(node); return; } void clear(List *l) { if (l == NULL) return; ListNode *p = l-&gt;head.next, *q;//q中间变量 while (p) { q = p-&gt;next; clear_node(p); p = q; } free(l); return ; } ⭐初始化数据结构[比如链表、链表结点]时，为什么要动态开辟内存[用malloc等]，而不是定义普通变量？ 首先，排除盲区：用指针才能接受malloc返回的地址，但指针也能指向普通变量 关键：【malloc申请的内存在堆空间，普通变量定义在栈空间(在函数里面定义的)】 栈空间：大小只有8MB；出了函数[作用域]变量就被自动释放了 堆空间：可分配大内存；变量生命周期长，一般需手动释放 ❓虚拟头结点定义为普通变量和指针变量的区别 个人理解，用指针变量，是为了接收malloc返回的地址 而虚拟头结点，在这只是一个指示作用，不需要大空间，所以用普通变量即可而 栈与队列队列 先进先出的数据结构（First in First out） 从队尾加入（push）一个元素 从队首弹出（pop）一个元素 head记录队首元素的位置 tail记录队尾元素的位置 出队： 让head指向下一个元素 长度和容量都不变 入队：让tail指向后一个地址 在此地址中进行加入元素 假溢出问题：当队列如下图时 弹出了3个元素且加入了4个元素使得队列满了 我们可以发现tail已经走到了末尾 如果此时我们还想插入一个元素10 该怎么办呢？ 其实之前我们弹出了3个元素 这3个空间是可以使用的 那么我们是否可以将tail指向被弹出的元素的地址（队列的头部）呢？ ​ 答案是可以的 当我们这么做时 此时的队列就变成了==循环队列== ​ 循环队列就是用于解决这种假溢出问题的 那么我们如何去判断一个队列是否是满的呢？ 在循环队列中我们还需要加入一个字段count用于记录有效元素个数 ==普通队列== #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; typedef struct Queue { int *data; int head, tail, length;//length 容量 } Queue; Queue *init(int n) { Queue *q = (Queue *)malloc(sizeof(Queue)); q-&gt;data = (int *)malloc(sizeof(int) * n); q-&gt;length = n; q-&gt;head = q-&gt;tail = 0;//tail有两种实现方式 1.指向最后一个元素的地址 2.指向最后一个元素的下一个地址 这里我们选择第二种 return q; } int front(Queue *q) { //if (q == NULL) return 0; return q-&gt;data[q-&gt;head]; } int empty(Queue *q) { return q-&gt;head == q-&gt;tail; //tail 指向的是最后一个元素的下一个 } int push(Queue *q, int val) { if (q == NULL) return 0; if (q-&gt;tail == q-&gt;length) return 0; q-&gt;data[q-&gt;tail++] = val;//将val放入tail指向的位置 然后将tail++操作 return 1; } int pop(Queue *q) { if (q == NULL) return 0; if (empty(q)) return 0;//判断当前队列是否为空 q-&gt;head++; return 1; } void output(Queue *q) { if (q == NULL) return; printf(\"Queue : [\"); for (int i = q-&gt;head, j = 0; i &lt; q-&gt;tail; i++, j++) { j &amp;&amp; printf(\", \"); //打印逗号和空格 printf(\"%d\", q-&gt;data[i]); } printf(\"]\\n\"); return ; } void clear(Queue *q) { if (q == NULL) return ; free(q-&gt;data); free(q); return; } int main() { srand(time(0)); #define max_op 20 Queue *q = init(max_op); for (int i = 0; i &lt; max_op; i++) { int val = rand() % 100; int op = rand() % 4; switch (op) { case 0: case 1: case 2: { printf(\"push %d to the Queue! \", val); printf(\"result = %d\\n\", push(q, val)); } break; case 3: { printf(\"pop %d from the Queue! \", front(q)); printf(\"result = %d\\n\", pop(q)); } break; } output(q), printf(\"\\n\"); } #undef max_op clear(q); return 0; } 循环队列 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define COLOR(a, b) \"\\033[\" #b \"m\" a \"\\033[0m\" #define GREEN(a) COLOR(a, 32) typedef struct Queue { int *data;//队列数据域 int head, tail, length;//length 容量 int cnt;//循环队列的字段 } Queue; Queue *init(int n) { Queue *q = (Queue *)malloc(sizeof(Queue)); q-&gt;data = (int *)malloc(sizeof(int) * n); q-&gt;length = n; q-&gt;head = q-&gt;tail = 0;//tail有两种实现方式 1.指向最后一个元素的地址 2.指向最后一个元素的下一个地址，方便循环队列判空 q-&gt;cnt = 0; return q; } int front(Queue *q) { //if (q == NULL) return 0; return q-&gt;data[q-&gt;head]; } int empty(Queue *q) { // return q-&gt;head == q-&gt;tail; //tail 指向的是最后一个元素的下一个 return q-&gt;cnt == 0;//循环队列判空 } //遇到真溢出 //realloc不适用 尽管它能重新给我们分配一段大的空间 但是进行数据拷贝时是从0地址到尾地址进行拷贝 tail可能在head的前面 int expand(Queue *q) { int extr_size = q-&gt;length; int *p; while (extr_size) { p = (int *)malloc(sizeof(int) * (q-&gt;length + extr_size)); if (p) break; extr_size &gt;&gt;= 1; } if (p == NULL) return 0; for (int i = q-&gt;head, j = 0; j &lt; q-&gt;cnt; j++) { p[j] = q-&gt;data[(i + j) % q-&gt;length]; } free(q-&gt;data); q-&gt;data = p; q-&gt;length += extr_size; q-&gt;head = 0; q-&gt;tail = q-&gt;cnt; return 1; } int push(Queue *q, int val) { if (q == NULL) return 0; //if (q-&gt;tail == q-&gt;length) return 0; if (q-&gt;cnt == q-&gt;length) { if (!expand(q)) return 0; //扩容操作 printf(GREEN(\"expand successfully! Queue-&gt;size(%d)\\n\"), q-&gt;length); } q-&gt;data[q-&gt;tail++] = val;//将val放入tail指向的位置 然后将tail++操作 if (q-&gt;tail == q-&gt;length) q-&gt;tail = 0; q-&gt;cnt += 1; return 1; } int pop(Queue *q) { if (q == NULL) return 0; if (empty(q)) return 0;//判断当前队列是否为空 q-&gt;head++; if (q-&gt;head == q-&gt;length) q-&gt;head = 0;//head也可能越界 q-&gt;cnt -= 1; return 1; } void output(Queue *q) { if (q == NULL) return; printf(\"Queue : [\"); for (int i = q-&gt;head, j = 0; j &lt; q-&gt;cnt; i++, j++) { j &amp;&amp; printf(\", \"); //打印逗号和空格 printf(\"%d\", q-&gt;data[i % q-&gt;length]); //取模得到真实的位置 } printf(\"]\\n\"); return ; } void clear(Queue *q) { if (q == NULL) return ; free(q-&gt;data); free(q); return; } int main() { srand(time(0)); #define max_op 20 Queue *q = init(2); for (int i = 0; i &lt; max_op; i++) { int val = rand() % 100; int op = rand() % 4; switch (op) { case 0: case 1: case 2: { printf(\"push %d to the Queue! \", val); printf(\"result = %d\\n\", push(q, val)); } break; case 3: { printf(\"pop %d from the Queue! \", front(q)); printf(\"result = %d\\n\", pop(q)); } break; } output(q), printf(\"\\n\"); } #undef max_op clear(q); return 0; } ==栈== 一种先进后出的数据结构 （FILO） 如果是一个空栈 top = -1 因为顺序结构下标从0~n-1进行访问 出栈 将栈顶指针向下移动一位 出栈要进行判空操作 入栈 将栈顶指针向上移动 要进行判断边界操作 括号匹配问题 struct Stack { char *val; int p, maxSize; }; void initStack(struct Stack *s, int maxSize) { s-&gt;val = malloc(maxSize); s-&gt;p = 0; } bool emptyStack(struct Stack *s) { return !(s-&gt;p); } void pushStack(struct Stack *s, char c) { s-&gt;val[s-&gt;p++] = c; } void popStack(struct Stack *s) { --(s-&gt;p); } char seekStack(struct Stack *s) { return s-&gt;val[s-&gt;p - 1]; } bool isValid(char * s){ struct Stack stack; int len = strlen(s); initStack(&amp;stack, len); for (int i = 0; i &lt; len; i++) { switch (s[i]) { case '(': case '[': case '{': pushStack(&amp;stack, s[i]); break; case ')': if (emptyStack(&amp;stack)) return false; if (seekStack(&amp;stack) != '(') return false; popStack(&amp;stack); break; case ']': if (emptyStack(&amp;stack)) return false; if (seekStack(&amp;stack) != ']') return false; popStack(&amp;stack); break; case '}': if (emptyStack(&amp;stack)) return false; if (seekStack(&amp;stack) != '}') return false; popStack(&amp;stack); break; } } return emptyStack(&amp;stack); } 栈的代码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define COLOR(a, b) \"\\033[\" #b \"m\" a \"\\033[0m\" #define GREEN(a) COLOR(a, 32) typedef struct Stack { int *data; int size, top;//size容量 top栈顶指针 } Stack; Stack *init(int n) { Stack *s = (Stack *)malloc(sizeof(Stack)); s-&gt;data = (int *)malloc(sizeof(int) * n); s-&gt;size = n; s-&gt;top = -1; return s; } int top(Stack *s) { return s-&gt;data[s-&gt;top]; } int empty(Stack *s) { return s-&gt;top == -1; } int expand(Stack *s) { int extr_size = s-&gt;size; int *p; while (extr_size) { p = (int *)realloc(s-&gt;data, sizeof(int) * (s-&gt;size + extr_size)); if (p) break; extr_size &gt;&gt;= 1; } if (p == NULL) return 0; s-&gt;data = p; s-&gt;size += extr_size; return 1; } int push(Stack *s, int val) { if (s == NULL) return 0; if (s-&gt;top == s-&gt;size - 1) { if (!expand(s)) return 0; printf(GREEN(\"expand successfully! stack-&gt;size = (%d)\\n\"), s-&gt;size); } s-&gt;data[++(s-&gt;top)] = val; return 1; } int pop(Stack *s) { if (s == NULL) return 0; if (empty(s)) return 0; s-&gt;top -= 1; return 1; } void output(Stack *s) { if (s == NULL) return ; printf(\"[\"); for (int i = 0; i &lt;= s-&gt;top; i++) { i &amp;&amp; printf(\", \"); printf(\"%d\", s-&gt;data[i]); } printf(\"]\\n\"); return ; } void clear(Stack *s) { if (s == NULL ) return; free(s-&gt;data); free(s); return ; } int main() { srand(time(0)); #define max_op 20 Stack *s = init(4); int flag; for (int i = 0; i &lt; max_op; i++) { int val = rand() % 100; int op = rand() % 4; switch (op) { case 0: case 1: case 2: { printf(\"push %d to the Stack = %d\\n\", val, push(s, val)); } break; case 3: { flag = !empty(s); flag &amp;&amp; printf(\"pop %d frome the Stack\", top(s)); printf(\"result = %d\\n\", pop(s)); } break; } output(s), printf(\"\\n\"); } #undef max_op clear(s); return 0; } 树与二叉树树的组成：结点 + 边 结点 👉 集合，边 👉 关系 根结点：全集；子结点：子集 根结点的所有子结点的集合并集 = 全集 【思想】大问题抽象为树，小问题抽象为子结点 深度、高度 树的深度和高度是一个值：最大层数 结点的深度和高度不一样 深度：从根结点往下数，该结点是第几层 高度：从最深的层数往上数，该结点是第几层 度：有几个子孩子 节点的度：一个节点含有的子树的个数称为该节点的度； 叶节点或终端节点：度为0的节点称为叶节点； 非终端节点或分支节点：度不为0的节点 ； 双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 兄弟节点：具有相同父节点的节点互称为兄弟节点； 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推； 树的高度或深度：树中节点的最大层次； 堂兄弟节点：双亲在同一层的节点互为堂兄弟； 节点的祖先：从根到该节点所经分支上的所有节点； 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。 森林：由m（m&gt;=0）棵互不相交的树的集合称为森林。 ⭐【重要公式】结点数 = 边数 + 1 二叉树 任何树都可以变成一颗二叉树 这是一颗三叉树 可以把它变成二叉树二进制可以转换成任何进制，二叉树同理 首先简单 且可以表示所有的树形结构 方法：左孩子、右兄弟法，又称十字链表法 从上往下，从左往右，结点的孩子放在左边，结点的相邻兄弟放在右边 ⭐【重要公式】二叉树中，度为0的结点比度为2的结点多1个 利用另一重要公式：结点数 = 边数 + 1 令ni表示度为i的结点个数 则：[结点数] n0 + n1 + n2 = n1 + 2 * n2 + 1 [边数 + 1] 得：n0 = n2 + 1 完全二叉树：只差最后一个右孩子 满二叉树： 只有度为0 和度为2 的节点 完美二叉树： 不多不少很完美 对于一颗二叉树 若根节点表示i 左孩子为 2*i 右孩子为 2*i + 1 ==binary_tree== 实现的是二叉查找树（二叉排序树） 维护的性质: 对于一个三元组来说👇 左孩子小于根节点 右孩子大于根节点 对于中序遍历而言 ： 可以实现从小到大排序 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; //节点 typedef struct Node { int data; struct Node *lchild, *rchild;//二叉 指针域 左孩子 右孩子 } Node; typedef struct tree { Node *root;//指向根节点的指针变量 int n;//节点个数 } Tree; Node *getNewNode(int val) { Node *p = (Node *)malloc(sizeof(Node)); p-&gt;data = val; p-&gt;lchild = p-&gt;rchild = NULL; return p; } Tree *getNewTree() { Tree *tree = (Tree *)malloc(sizeof(Tree)); tree-&gt;root = NULL; tree-&gt;n = 0; return tree; } void clearNode(Node *node) { if (node == NULL) return ; clearNode(node-&gt;lchild);//沿着当前节点的左子树进行递归回收 clearNode(node-&gt;rchild); free(node);//回收当前节点 return ; } void clear(Tree *tree) { if (tree == NULL) return ; clearNode(tree-&gt;root); free(tree); return ; } Node *insert_node(Node *root, int val, int *flag) { if (root == NULL){ *flag = 1;//root为空表示插入成功 return getNewNode(val);//若root节点为空 则将val封装成根节点 } if (root-&gt;data == val) return root;//如果根节点的值等于val 则返回root //如果当前的val值小于当前根节点所指向的值 //那么我们需要将val值递归插入到根节点的左子树中 if (val &lt; root-&gt;data) root-&gt;lchild = insert_node(root-&gt;lchild, val, flag); else root-&gt;rchild = insert_node(root-&gt;rchild, val, flag); return root; } //二叉查找树 左孩子小于根节点 右孩子大于根节点 void insert(Tree *tree, int val) { int flag = 0;//传出参数 tree-&gt;root = insert_node(tree-&gt;root, val, &amp;flag); //若插入成功 则此时flag = 1 且将节点个数加1 tree-&gt;n += flag; return ; } void pre_order_node(Node *node) { if (node == NULL) return ; printf(\"%d \", node-&gt;data); pre_order_node(node-&gt;lchild); pre_order_node(node-&gt;rchild); return ; } //前序遍历 void pre_order(Tree *tree) { if (tree == NULL) return ; printf(\"pre_order :\"); pre_order_node(tree-&gt;root); printf(\"\\n\"); return; } void in_order_node(Node *node) { if (node == NULL) return ; in_order_node(node-&gt;lchild); printf(\"%d \", node-&gt;data); in_order_node(node-&gt;rchild); return ; } //中序遍历 void in_order(Tree *tree) { if (tree == NULL) return ; printf(\"in_order :\"); in_order_node(tree-&gt;root); printf(\"\\n\"); return; } void post_order_node(Node *node) { if (node == NULL) return ; post_order_node(node-&gt;lchild); post_order_node(node-&gt;rchild); printf(\"%d \", node-&gt;data); return ; } //后序遍历 void post_order(Tree *tree) { if (tree == NULL) return ; printf(\"post_order :\"); post_order_node(tree-&gt;root); printf(\"\\n\"); return; } //打印广义表 void output_node(Node *root) { if (root == NULL) return ; printf(\"%d\", root-&gt;data); if (root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) return; //打印左子树时先输出`(` printf(\"(\"); output_node(root-&gt;lchild); printf(\", \"); //打印右子树后输出`)` output_node(root-&gt;rchild); printf(\")\"); return ; } void output(Tree *tree) { if (tree == NULL) return ; printf(\"tree(%d) : \", tree-&gt;n); output_node(tree-&gt;root); printf(\"\\n\"); return ; } int main() { srand(time(0)); Tree *tree =getNewTree(); #define max_op 10 for (int i = 0; i &lt; max_op; i++) { int val = rand() % 100; insert(tree, val); output(tree); } pre_order(tree); in_order(tree); post_order(tree); #undef max_op clear(tree); return 0; } 😎三种遍历方式中 任选两种（其中必须包含中序遍历）可以还原一颗二叉树 广义表转二叉树 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef struct Node { char data; struct Node *lchild, *rchild; } Node; typedef struct Tree { Node *root; int n; } Tree; typedef struct Stack { Node **data; int top, size; } Stack; Node *getNewNode(char val) { Node *p = (Node *)malloc(sizeof(Node)); p-&gt;data = val; p-&gt;lchild = p-&gt;rchild = NULL; return p; } Tree *getNewTree() { Tree *tree = (Tree *)malloc(sizeof(Tree)); tree-&gt;root = NULL; tree-&gt;n = 0; return tree; } Stack *init_stack(int n) { Stack *s = (Stack *)malloc(sizeof(Stack)); s-&gt;data = (Node **)malloc(sizeof(Node *) * n); s-&gt;top = -1; s-&gt;size = n; return s; } Node *top(Stack *s) { return s-&gt;data[s-&gt;top]; } int empty(Stack *s) { return s-&gt;top == -1; } int push(Stack *s, Node *val) { if (s == NULL) return 0; if (s-&gt;top == s-&gt;size - 1) return 0; s-&gt;data[++(s-&gt;top)] = val; return 1; } int pop(Stack *s) { if (s == NULL) return 0; if (empty(s)) return 0; s-&gt;top -= 1; return 1; } void clear_stack(Stack *s) { if (s == NULL) return; free(s-&gt;data); free(s); return ; } void clear_node(Node *node) { if (node == NULL) return ; clear_node(node-&gt;lchild); clear_node(node-&gt;rchild); free(node); return ; } void clear_tree(Tree *tree) { if (tree == NULL) return ; clear_node(tree-&gt;root); free(tree); return ; } Node *build(const char *str, int *node_num) { Stack *s = init_stack(strlen(str)); int flag = 0; Node *temp = NULL, *p = NULL; while (str[0]) { switch (str[0]) { case '(': { push(s, temp); flag = 0; } break; case ')': { p = top(s); pop(s); } break; case ',': { flag = 1; } break; case ' ': break; default: temp = getNewNode(str[0]); if (!empty(s) &amp;&amp; flag == 0) { top(s)-&gt;lchild = temp; } else if (!empty(s) &amp;&amp; flag == 1) { top(s)-&gt;rchild = temp; } ++(*node_num); break; } ++str; } clear_stack(s); if (temp &amp;&amp; !p) p = temp; return p; } void pre_order_node(Node *root) { if (root == NULL) return ; printf(\"%c \", root-&gt;data); pre_order_node(root-&gt;lchild); pre_order_node(root-&gt;rchild); return ; } void pre_order(Tree *tree) { if (tree == NULL) return ; printf(\"pre_order : \"); pre_order_node(tree-&gt;root); printf(\"\\n\"); return ; } void in_order_node(Node *root) { if (root == NULL) return ; in_order_node(root-&gt;lchild); printf(\"%c \", root-&gt;data); in_order_node(root-&gt;rchild); return ; } void in_order(Tree *tree) { if (tree == NULL) return ; printf(\"in_order : \"); in_order_node(tree-&gt;root); printf(\"\\n\"); return ; } void post_order_node(Node *root) { if (root == NULL) return ; post_order_node(root-&gt;lchild); post_order_node(root-&gt;rchild); printf(\"%c \", root-&gt;data); return ; } void post_order(Tree *tree) { if (tree == NULL) return ; printf(\"post_order : \"); post_order_node(tree-&gt;root); printf(\"\\n\"); return ; } int main() { char str[1000] = {0}; int node_num = 0; scanf(\"%[^\\n]s\", str); Tree *tree = getNewTree(); tree-&gt;root = build(str, &amp;node_num); tree-&gt;n = node_num; pre_order(tree); in_order(tree); post_order(tree); clear_tree(tree); return 0; } 排序与查找稳定排序==稳定排序== 对于相同的元素 经过排序操作后 他们的相对位置保持不变 这样的排序我们称为稳定排序 插入排序 时间复杂度O(n^2) 至少要n-1轮操作 冒泡排序 归并排序 时间复杂度O(nlog·N) 分治思想 不是基于比较跟交换的排序方式 ==★==这是一个外部排序（很重要） 外部排序: 我们可以将数据分为多段加载到内存中 内部排序：需要将数据整个加载到内存中进行排序 比如我们有40G的数据要进行排序 怎么办？ 我们可以使用归并排序 把40G的数据分成20G 再不行就分成10G #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;time.h&gt; #define swap(a, b) {\\ a ^= b; b ^= a; a ^= b;\\ } #define TEST(arr, n, func, args...) {\\ int *num = (int *)malloc(sizeof(int) * n);\\ memcpy(num, arr, sizeof(int) * n);\\ output(num, n);\\ printf(\"%s= \", #func);\\ func(args);\\ output(num, n);\\ free(num);\\ } //插入排序 void insert_sort(int *num, int n) { for (int i = 1; i &lt; n; i++) { for (int j = i ; j &gt; 0 &amp;&amp; num[j] &lt; num[j - 1]; j--) { swap(num[j], num[j - 1]); } } return ; } //冒泡 我们在这里设置一个记录交换次数的值 若是一个从小到大的有序数组 times交换次数必定为0 且时间复杂度为O(n) void bubble_sort(int *num, int n) { int times = 1; // 进行交换的次数 for (int i = 1; i &lt; n &amp;&amp; times; i++) {//times == 0 结束循环 times = 0; for (int j = 0; j &lt; n - i; j++) { if (num[j] &lt;= num[j + 1]) continue; //减少缩进 swap(num[j], num[j + 1]); times++; } } return ; } //归并排序 分治思想 用递归 void merge_sort(int *num, int l, int r) { //边界条件 只剩两个元素 if (r - l &lt;= 1) { if (r - l == 1 &amp;&amp; num[r] &lt; num[l]) { swap(num[r], num[l]); } return; } int mid = (l + r) &gt;&gt; 1; merge_sort(num, l, mid);//从l 到 mid 进行排序 merge_sort(num, mid + 1, r);//从 mid + 1 到 r 进行排序 //合并 int *temp = (int *)malloc(sizeof(int) * (r - l + 1)); //p1 指向的是 int p1 = l, p2 = mid + 1, k = 0; while (p1 &lt;= mid || p2 &lt;= r) { if (p2 &gt; r || (p1 &lt;= mid &amp;&amp; num[p1] &lt;= num[p2])) { temp[k++] = num[p1++]; } else { temp[k++] = num[p2++]; } } //将temp拷贝回num里 memcpy(num + l, temp, sizeof(int) * (r -l + 1)); free(temp); return ; } void randint(int *num, int n) { while (n--) num[n] = rand() % 100; return ; } void output(int *num, int n) { printf(\"[\"); for (int i = 0; i &lt; n; i++) { printf(\"%d \", num[i]); } printf(\"]\\n\"); } int main() { srand(time(0)); #define max_n 20 int arr[max_n]; randint(arr, max_n); TEST(arr, max_n, insert_sort, num, max_n); TEST(arr, max_n, bubble_sort, num, max_n); TEST(arr, max_n, merge_sort, num, 0, max_n - 1); #undef max_n return 0; } 不稳定排序 选择排序 时间复杂度：O(n^2) 不稳定排序 比如 5 3 2 5 1 经过排序后 第一个5的位置变到了最后一个 两个5的相对位置发生了改变 快速排序 时间复杂度：O(nlog·N) 选一个基数 让左半边小于这个基数 右半边大于这个基数 ①选择头部元素作为基数 ②有头尾两个指针 尾指针找第一个小于基数的值然后放入头部中 头指针找第一个大于基数的值放入刚刚移走的值的位置 ③最后指针重叠 放入基数 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;string.h&gt; //^= 两个值不能异或自己 #define swap(a, b) {\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\ } #define TEST(arr, n, func, args...) {\\ int *num = (int *)malloc(sizeof(int) * n);\\ memcpy(num, arr, sizeof(int) * n);\\ output(num, n);\\ printf(\"%s = \", #func);\\ func(args);\\ output(num, n);\\ free(num);\\ } void select_sort(int *num, int n) { for (int i = 0; i &lt; n - 1; i++) { int ind = i; for (int j = i + 1; j &lt; n; j++) { if (num[ind] &gt; num[j]) ind = j; } swap(num[i], num[ind]); } return ; } void quick_sort(int *num, int l, int r) { if (l &gt; r) return ; int x = l, y = r, z = num[x]; while (x &lt; y) { while (x &lt; y &amp;&amp; num[y] &gt; z) y--; if (x &lt; y) num[x++] = num[y]; while (x &lt; y &amp;&amp; num[x] &lt; z) x++; if (x &lt; y) num[y--] = num[x]; } num[x] = z; quick_sort(num, l, x - 1); quick_sort(num, x + 1, r); return ; } void randint(int *num, int n) { while (n--) num[n] = rand() % 100; return ; } void output(int *num, int n) { printf(\"[\"); for (int i = 0; i &lt; n; i++) { printf(\"%d \", num[i]); } printf(\"]\\n\"); return ; } int main() { srand(time(0)); #define max_n 20 int arr[max_n]; randint(arr, max_n); TEST(arr, max_n, select_sort, num, max_n); TEST(arr, max_n, quick_sort, num, 0, max_n - 1); return 0; } 快速排序优化 查找 二分查找 虚拟头尾指针 一堆0的情况 特殊情况① 1111111100000000 1 表示满足某种性质 0 表示不满足某种性质 如果我们的数据全是0 0000000000000 最后mid指向第一个0 我们说不清到底是找到了答案还是没找到 所以我们引入了虚拟头指针 去判断它是否等于-1 特殊情况② 00000000011111111111 三分查找 #include &lt;stdio.h&gt; #define P(func) {\\ printf(\"%s = %d\\n\", #func, func);\\ } int binary_search1(int *num, int n, int x) { int head = 0, tail = n - 1, mid; while (head &lt;= tail) { mid = (head + tail) &gt;&gt; 1; if (num[mid] == x) return mid; if (num[mid] &lt; x) head = mid + 1; else tail = mid - 1; } return -1; } //111111000000 //head 虚拟头指针 int binary_search2(int *num, int n) { int head = -1, tail = n - 1, mid; while (head &lt; tail) { mid = (head + tail + 1) &gt;&gt; 1; if (num[mid] == 1) head = mid; else tail = mid - 1; } return head; } //00000011111111 //tail 虚拟尾指针 int binary_search3(int *num, int n) { int head = 0, tail = n, mid; while (head &lt; tail) { mid = (head + tail) &gt;&gt; 1; if (num[mid] == 1) tail = mid; else head = mid + 1; } return head == n ? -1 : head; } int main() { int arr1[10] = {1, 3, 5, 7, 9, 11, 13, 17, 19, 21}; int arr2[10] = {1, 1, 1, 1, 0, 0, 0, 0, 0, 0}; int arr3[10] = {0, 0, 0, 0, 0, 0, 1, 1, 1, 1}; P(binary_search1(arr1, 10, 7)); P(binary_search2(arr2, 10)); P(binary_search3(arr3, 10)); return 0; } 哈希表 时间复杂度：趋近与O(1) 是一种用来查找的数据结构（下标与值的访问） 可以将任意一种类型映射成数组下标的形式进行访问 冲突处理方法（无法避免，但是可以减少发生的概率） 放入元素 ：当前我要插入16这个值 用16取模与当前的容量 放入到下标为【7】的位置中 发生冲突： 我要插入7这个值 7%9 = 7 此时我要把7放入到下标为【7】的位置中 但是【7】的位置中已存在值 这时冲突便发生了 这是就引出了哈希表很重要的结构： 冲突处理方法 ①开放定址： 当前7的位置有值 那我就去寻找后面的位置 是否有值 如果没有值就将7放入8的位置 容易产生数据堆聚问题 ：数据会集中存储在空间中的某一块区域 ②再哈希法：在我的哈希表中 我设置了不止一种哈希函数 一种不行 我再用下一种 ③拉链法：在当前位置我不存储一个元素，我们去存储一个链表，将这个值封装一个节点存在链表的后面 ④建立公共溢出区：这个区域专门用来存储冲突元素的——用一种额外的数据结构维护（红黑树） #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef struct Node { char *str; struct Node *next; } Node; typedef struct HashTable { Node **data;//哈希表(也是顺序表)里面存储的是一个地址 地址所指向的类型是Node*类型 拉链法 int size; } HashTable; Node *init_node(char *str, Node *head) { Node *p = (Node *)malloc(sizeof(Node)); p-&gt;str = strdup(str); p-&gt;next = head; //头插法 return p; } HashTable *init_hashtable(int n) { HashTable *h = (HashTable *)malloc(sizeof(HashTable)); //利用率和哈希函数冲突概率有关 我们把n扩大一倍 使其只有50%利用率 h-&gt;size = n &lt;&lt; 1;//哈希表的空间利用率不可能达到100% 一般的空间利用率为50%——90% 工业上达到70%才可以使用 h-&gt;data = (Node **)calloc(h-&gt;size,sizeof(Node *));//数据的每一位都为0值 都是空地址 return h; } //哈希函数 int BKDRHash(char *str) { //seed是一个素数就行 int seed = 31, hash = 0; for (int i = 0; str[i]; i++) hash = hash * seed + str[i]; //hash有可能超出整型范围 变成一个负数 //这里的0x7fffffff 表示的是符号位为0 其余位为1的数 return hash &amp; 0x7fffffff; } int insert(HashTable *h, char *str) { int hash = BKDRHash(str); int ind = hash % h-&gt;size; //将字符串插入到下标为ind的这个位置所对应的链表中 h-&gt;data[ind] = init_node(str, h-&gt;data[ind]); return 1; } int search(HashTable *h, char *str) { int hash = BKDRHash(str); int ind = hash % h-&gt;size; //p指向ind这位链表里存的头节点 Node *p = h-&gt;data[ind]; //沿着链表的头节点 遍历链表的每一位 strcmp返回值不为0时代表没找到 while (p &amp;&amp; strcmp(p-&gt;str, str)) p = p-&gt;next; //如果p 不等于NULL 说明是因为strcmp返回值为0退出的循环 也就是说找到了值 return p != NULL; } void clear_node(Node *node) { if (node == NULL) return ; Node *p = node, *q; while (p) { q = p-&gt;next; free(p-&gt;str); free(p); p = q; } return ; } void clear_hashtable(HashTable *h) { if (h == NULL) return ; for (int i = 0; i &lt; h-&gt;size; i++) { clear_node(h-&gt;data[i]); } free(h-&gt;data); free(h); return ; } int main() { int op; #define max_n 100 char str[max_n + 5] = {0}; HashTable *h = init_hashtable(max_n + 5); while (~scanf(\"%d%s\", &amp;op, str)) { switch (op) { case 0: printf(\"insert %s to HashTable\\n\", str); insert(h, str); break; case 1: printf(\"search %s from HashTable result = %d\\n\", str, search(h, str)); break; } } #undef max_n clear_hashtable(h); return 0; } 堆与优先队列 完全二叉树默认从1开始编号 这样可以保证左孩子、右孩子编号简洁 [否则] 左孩子编号需为2 i + 1，右孩子编号需为2 i + 2 ==数据结构： 你定义了一种性质，并且能维护这一种性质，那么这种结构就是一个新的数据结构== 优先队列是堆的一个别名 堆在思维逻辑上就是一颗完全二叉树 尾部插入元素(O(logn)) 一开始以7为根节点 13为左孩子 右孩子为空 这个三元组进行调整 头部弹出调整（删除操作） 从头部删除元素 并维护堆的性质进行调整 我们让最后一个孩子作为头部元素 自上而下进行调整 堆排序 我们将堆顶元素和堆尾元素置换 每次调整n-1个元素 时间复杂度O(nlogn)：因为每次是一层一层遍历 大顶堆：从小到大排序 小顶堆：从大到小排序 普通队列与堆的比较 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define swap(a, b) {\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\ } typedef struct priority_queue { int *data; int cnt, size;//个数， 容量 } priority_queue; priority_queue *init(int n) { priority_queue *q = (priority_queue *)malloc(sizeof(priority_queue)); //由于优先队列是以数组的形式进行存储 且在逻辑上是一棵二叉树 所以在这里多开一位 //目的：可以方便计算 q-&gt;data = (int *)malloc(sizeof(int) * (n + 1)); q-&gt;cnt = 0; q-&gt;size = n; return q; } int empty(priority_queue *q) { return q-&gt;cnt == 0; } //堆顶弹出元素 int top(priority_queue *q) { return q-&gt;data[1]; } int push(priority_queue *q, int val) { if (q == NULL) return 0; if (q-&gt;cnt == q-&gt;size) return 0; //判断堆是否满 q-&gt;data[++(q-&gt;cnt)] = val; //++(q-&gt;cnt)是因为我们从1开始存储所以个数要先加1 int ind = q-&gt;cnt; //ind记录的是最后插入元素的下标 //由于我们插入一个元素 要进行向上调整 也就是当前节点需要跟父节点进行比较 // ind &gt;&gt; 1 表示我们的父节点 维护大顶堆 while (ind &gt;&gt; 1 &amp;&amp; q-&gt;data[ind] &gt; q-&gt;data[ind &gt;&gt; 1]) { swap(q-&gt;data[ind], q-&gt;data[ind &gt;&gt; 1]); ind &gt;&gt;= 1; //交换后当前节点等于父节点 } return 1; } int pop(priority_queue *q) { if (q == NULL) return 0; if (empty(q)) return 0; //我们将最后一个节点覆盖掉第一个节点 并让个数减1 q-&gt;data[1] = q-&gt;data[q-&gt;cnt--]; int ind = 1; //调整下标 //左孩子的下标没有超过q-&gt;cnt的下标的话 说明ind这个节点有左孩子 while ((ind &lt;&lt; 1) &lt;= q-&gt;cnt) { //😱(ind &lt;&lt; 1 | 1) 骚操作 表示的是ind * 2 + 1 int temp = ind, l = ind &lt;&lt; 1, r = ind &lt;&lt; 1 | 1; if (q-&gt;data[l] &gt; q-&gt;data[temp]) temp = l; if (r &lt;= q-&gt;cnt &amp;&amp; q-&gt;data[r] &gt; q-&gt;data[temp]) temp = r; if (temp == ind) break; swap(q-&gt;data[ind], q-&gt;data[temp]); ind = temp; } return 1; } void clear(priority_queue *q) { if (q == NULL) return ; free(q-&gt;data); free(q); return ; } int main() { srand(time(0)); #define max_op 20 priority_queue *q = init(max_op); for (int i = 0; i &lt; max_op; i++) { int val = rand() % 100; push(q, val); printf(\"insert %d to the priority_queue!\\n\", val); } for (int i = 0; i &lt; max_op; i++) { printf(\"%d \", top(q)); pop(q); } printf(\"\\n\"); #undef max_op clear(q); return 0; } 堆排序 根据其性质，全部弹出，将得到一个排好序的序列 ⭐思维转变：堆顶元素的弹出操作 ==&gt; 堆顶元素与堆尾元素交换 【如此操作】 大顶堆的元素全部弹出👉原数组存储了一个从小到大的排序序列 [至此，从大顶堆，得到一个特殊的小顶堆] 时间复杂度：O(NlogN) 消耗的时间在于调整操作，每次调整的时间复杂度是O(logN)，共N个元素，需调整N - 1次 弹出操作的时间复杂度是O(1)的 时间效率一定不会退化 建堆【若要使用堆排序，首先需要维护一个堆，也就是用普通的序列建堆，下面有2种思路】 常规思路又叫插入建堆法 按照前述尾部插入的调整方法：自下向上 从第0层 [默认根结点在第0层] 开始，计算每一层的最多调整次数： 第 i 层元素的调整次数为 i，第 i 层的结点数为2 ^ i→ 第 i 层的总调整次数为 i * (2 ^ i) 最坏的建堆时间复杂度O(NlogN)，计算过程如下： 总的调整次数 S = (n - 1) * 2 ^ (n + 1) + 1，过程如下： 利用裂项相消法 上面的n对应层数 - 1 [从第0层开始的]，若令总的结点数为N，则n ≈ log[2]N ❗【层数n→结点数N的换算】将n ≈ log[2]N代入S，得到S ≈ Nlog[2]N 即最坏的时间复杂度为：O(NlogN) 线性思路⭐也就是【线性建堆法】 如图所示 常规思路：越到下面层，需要的调整次数越多，也就是权重越大 ❗ 那是否可以思维反转，把大权重放到前面，让下面结点数多的层的权重减小 线性思路：可以！从倒数第二层开始排，【自上向下】调整 🆒最坏的建堆时间复杂度O(N) 同样利用裂项相消法得到总的调整次数 S = 2 ^ (n + 1) - 2 - n 把层数n换算到结点数N，得到S ≈ 2N - 2 - log[2]N 即最坏的时间复杂度为：O(N) ⭐推荐视频 Linear Time BuildHeap ——Youtube 比较了常规建堆和线性建堆两种思路，并有直观的动画演示，加深印象 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define swap(a, b) {\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\ } void downUpdate(int *arr, int n, int ind) { while ((ind &lt;&lt; 1) &lt;= n) { int temp = ind, l = ind &lt;&lt; 1, r = ind &lt;&lt; 1 | 1; if (arr[l] &gt; arr[temp]) temp = l; if (r &lt;= n &amp;&amp; arr[r] &gt; arr[temp]) temp = r; if (ind == temp) break; swap(arr[temp], arr[ind]); ind = temp; } return ; } void heap_sort(int *arr, int n) { arr -= 1; //从最后一个结点的父结点开始调整 for (int i = n &gt;&gt; 1; i &gt;= 1; i--) { downUpdate(arr, n, i); } for (int i = n; i &gt; 1; i--) { swap(arr[i], arr[1]); downUpdate(arr, i - 1, 1); //从上到下调整 } return ; } void output(int *arr, int n) { printf(\"[\"); for (int i = 0; i &lt; n; i++) { printf(\"%d \", arr[i]); } printf(\"]\\n\"); return ; } int main() { srand(time(0)); #define max_n 20 int *arr = (int *)malloc(sizeof(int) * max_n); for (int i = 0; i &lt; max_n; i++) { arr[i] = rand() % 100; } output(arr, max_n); heap_sort(arr, max_n); output(arr, max_n); free(arr); #undef max_n return 0; } 森林与并查集并查集能解决的问题： 具有连通性关系的问题 确认连通关系：广义上来说 是将两个集合进行合并成具有连通关系的集合 可以判断我们两个点在一个集合中是否具有连通关系 ==quick-find算法== 核心思想：染色 一个颜色，对应一个类别 初始化：个体独立，都写成自己的索引，属于一个独立的集合里 ⭐把和自己连通的所有点的颜色改成要染的颜色 ==quick_union算法== 找代表元素👉（找大哥） 对于两个点 我们如果想判断连通性 那么我们就去查看他们的大哥是不是同一个 对于集合和集合之间建立的连通关系可以认为是集合和集合之间的合并操作 👉 （逻辑上）两颗子树的合并操作 👉 最终会在一个根结点下面 也就只有一个代表元素 首先链表是一棵极端的树 当我们用这种算法时两棵子树可能退化成链表 且有n个节点 则此时的树高也为n 合并操作将退化为O(n) →O(树高) 联通操作将退化为O(n) →O(树高) ==Weighted quick_union算法== 按秩优化 如何避免退化？→保证枝繁叶茂 合并依据1：树高，矮树挂在高树下[两两结合] 高度为 h 的树，至少需要的结点个数N为2 ^ (h - 1) 即树高h = log[2]N + 1 ≈ log[2]N [PS] 只有两棵一样树高的树合并，才会使高度增加 合并依据2：结点数量，结点少的树挂在结点多的树下 两种优化方式都能得到O(logN)，但是合并依据2【结点数量】更优秀一些 ⭐为什么合并依据2更优秀 【示例】什么是平均查找次数 如下图所示，计算了A、B树的平均查找次数 结点深度即为结点的查找次数，平均查找次数 = 总查找次数 / 总结点数 此示例，B树的查找操作更快 【推导】合并依据2直接决定平均查找次数 对于有SA、SB个结点的A、B树，它们的总查找次数LA、LB分别为： 其中，li 代表第 i 个结点的深度 此时进行合并操作，分别计算①A→B和②B→A的平均查找次数 ①当A树作为子树合并到B树时，为 A树中的所有结点需要多查找一次 ②当B树作为子树合并到A树时，为 B树中的所有结点需要多查找一次 ❗【比较两种方式的平均查找次数】 和树高[LA、LB]没有直接关系，而分子的结点数量[SA、SB]【直接】决定查找次数，次数越小越好 👉谁的结点数少，就作为子树被合并 ❓思考：上面的推导是否证明高度无法作为合并依据呢？ ❌否，高度间接影响着结点数量，一般情况高度越低，结点数量越少 但是，对于特殊情况，A树比B树高，而A树结点数量却比B树少时，还是按照【结点数量】作为合并依据，将A树作为子树合并到B树里 所以以结点数作为合并依据更优秀！👇合并思路如下 在合并两棵子树时 如果结点数一样，就按照普通Quick-Union的思路换 如果不一样，结点数少的子树的根结点接在👉结点数多的子树的根结点下面 [PS]换句话说 在换大哥时 如果小弟数量一样，就按照普通Quick-Union的思路换 如果不一样，小弟少的大哥得跟👉小弟多的大哥混 ==Quick-Find vs. Quick-Union== 【关键】理解Quick-Union 0-&gt;1-&gt;2-&gt;4-&gt;5、3-&gt;4-&gt;5；8-&gt;9-&gt;7-&gt;6 查找、合并边界：自己的代表元素就是本身时，停止 ==Quick-Union vs. weighted Quick-Union== 【关键】理解weighted的含义 当两个集合的元素个数不一样时 元素少的集合的代表元素的值👉元素多的集合的代表元素的值 小弟少的大哥得跟着小弟多的大哥混 结果可视化 很明显，weighted方法得到的树更矮，合并、查找效率更高 从练习题入手并查集 样例输入 6 5 1 1 2 2 1 3 1 2 4 1 4 3 2 1 3 样例输出 No Yes quick_find #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct UnionSet { int *color; //需要一片连续的空间存储每个元素的颜色 int n; //color指向这片连续空间的首地址 } UnionSet; UnionSet *init(int n) { UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet)); u-&gt;color = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;n = n; for (int i = 1; i &lt;= n; i++) { u-&gt;color[i] = i; // 将每个元素初始化为自己 } return u; } int find(UnionSet *u, int x) { return u-&gt;color[x]; } //合并 int merge(UnionSet *u, int a, int b) { if (find(u, a) == find(u, b)) return 0; //判断a和b是否连通 int color_a = u-&gt;color[a]; //保存前一个变量的颜色 //把所有a的颜色 改为 b的颜色 for (int i = 1; i &lt;= u-&gt;n; i++) { if (u-&gt;color[i] - color_a) continue; //若当前i的颜色等与a的颜色 则执行下次循环 否则 u-&gt;color[i] = u-&gt;color[b]; //将i的颜色改为b的颜色 } return 1; } void clear(UnionSet *u) { if (u == NULL) return ; free(u-&gt;color); free(u); return ; } int main() { int n, m; scanf(\"%d%d\", &amp;n, &amp;m); UnionSet *u = init(n); for (int i = 0; i &lt; m; i++) { int a, b, c; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); switch (a) { case 1: merge(u, b, c); break; case 2: printf(\"%s\\n\", find(u, b) == find(u, c) ? \"Yes\" : \"No\"); break; } } clear(u); return 0; } Weighted quick_union + 路径压缩 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define swap(a, b) {\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\ } typedef struct UnionSet { int *father; int *size; //记录相关的节点个数 weighted quick-union 优化 int n; } UnionSet; UnionSet *init(int n) { UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet)); u-&gt;father = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;size = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;n = n; for (int i = 1; i &lt;= n; i++) { u-&gt;father[i] = i; u-&gt;size[i] = 1; //最开始相关的节点数为自己 = 1 } return u; } int find(UnionSet *u, int x) { //if (u-&gt;father[x] == x) return x;//返回的是当前元素的代表元素 //return find(u, u-&gt;father[x]); //否则我们就递归去找它父亲的父亲 //优化 ：路径压缩 找到最直接的父亲 在路径压缩面前 可以去掉按节点合并的优化操作 其效率差不多 return u-&gt;father[x] = (u-&gt;father[x] == x ? x : find(u, u-&gt;father[x])); } int merge(UnionSet *u, int a, int b) { int fa = find(u, a), fb = find(u, b); if (fa == fb) return 0; if (u-&gt;size[fa] &lt; u-&gt;size[fb]) swap(fa, fb); //当fa的节点个数小于fb的节点个数 交换它们 保证fa的节点数是最大的 u-&gt;father[fb] = fa; //把fa当做合并后的根节点 u-&gt;size[fa] += u-&gt;size[fb]; //当fb作为子树时 fa整体的节点个数要加上fb的 return 1; } void clear(UnionSet *u) { if (u == NULL) return ; free(u-&gt;father); free(u-&gt;size); free(u); return ; } int main() { int n, m; scanf(\"%d%d\", &amp;n, &amp;m); UnionSet *u = init(n); for (int i = 0; i &lt; m; i++) { int a, b, c; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); switch (a) { case 1: merge(u, b, c); break; case 2: printf(\"%s\\n\", find(u, b) == find(u, c) ? \"Yes\" : \"No\"); break; } } clear(u); return 0; }","categories":[],"tags":[{"name":"Data structure, C","slug":"Data-structure-C","permalink":"http://srymaker0.com/tags/Data-structure-C/"}]},{"title":"数据结构之Leetcode刷题集","slug":"apage_03_数据结构力扣刷题集","date":"2021-05-05T05:26:52.000Z","updated":"2022-01-03T06:44:42.205Z","comments":true,"path":"posts/1124.html","link":"","permalink":"http://srymaker0.com/posts/1124","excerpt":"","text":"传送门 1.链表 2.栈 3.队列 4.二叉树 5.堆与优先队列 6.并查集 7.快速排序+优化 8.归并排序 9.有趣的排序 10.二分查找","categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://srymaker0.com/tags/Leetcode/"}]},{"title":"CPP个人笔记","slug":"apage_01_CPP个人笔记","date":"2021-05-03T09:26:52.000Z","updated":"2022-01-03T06:44:48.735Z","comments":true,"path":"posts/db87.html","link":"","permalink":"http://srymaker0.com/posts/db87","excerpt":"","text":"冲, 兄弟们 1.从c到c++ 2.构造与析构 3.类与对象 4.继承 5.多态 6.auto、constexpr、nullptr、左值与右值、移动构造 7.模板 8.异常 9.C++线程","categories":[],"tags":[{"name":"C++, 面向对象","slug":"C-面向对象","permalink":"http://srymaker0.com/tags/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]}],"categories":[],"tags":[{"name":"Innodb","slug":"Innodb","permalink":"http://srymaker0.com/tags/Innodb/"},{"name":"网络编程","slug":"网络编程","permalink":"http://srymaker0.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"shell","slug":"shell","permalink":"http://srymaker0.com/tags/shell/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://srymaker0.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"面试","slug":"面试","permalink":"http://srymaker0.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Data structure, C","slug":"Data-structure-C","permalink":"http://srymaker0.com/tags/Data-structure-C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://srymaker0.com/tags/Leetcode/"},{"name":"C++, 面向对象","slug":"C-面向对象","permalink":"http://srymaker0.com/tags/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]}